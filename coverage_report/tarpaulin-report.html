<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <style>:root {
  --color: black;
  --bg: white;
  --head-bg: white;
  --link: #338;

  --blue: #ccf;
  --red: #fcc;
  --yellow: #ffc;
  --green: #cfc;
}

[data-theme='dark'] {
  --color: white;
  --bg: black;
  --head-bg: #333;
  --link: #aaf;

  --blue: #225;
  --red: #522;
  --yellow: #552;
  --green: #252;
}

html,
body {
  margin: 0;
  padding: 0;
  color: var(--color);
  background: var(--bg);
}

.app {
  margin: 10px;
  padding: 0;
}

.files-list {
  margin: 10px 0 0;
  width: 100%;
  border-collapse: collapse;
}
.files-list__head {
  border: 1px solid #999;
}
.files-list__head > tr > th {
  padding: 10px;
  border: 1px solid #999;
  text-align: left;
  font-weight: normal;
  background: var(--head-bg);
}
.files-list__body {
}
.files-list__file {
  cursor: pointer;
}
.files-list__file:hover {
  background: var(--blue);
}
.files-list__file > td {
  padding: 10px;
  border: 1px solid #999;
}
.files-list__file > td:first-child::before {
  content: '\01F4C4';
  margin-right: 1em;
}
.files-list__file_low {
  background: var(--red);
}
.files-list__file_medium {
  background: var(--yellow);
}
.files-list__file_high {
  background: var(--green);
}
.files-list__file_folder > td:first-child::before {
  content: '\01F4C1';
  margin-right: 1em;
}

.file-header {
  border: 1px solid #999;
  display: flex;
  justify-content: space-between;
  align-items: center;
  position: sticky;
  top: 0;
  background: var(--bg);
}

.file-header__back {
  margin: 10px;
  cursor: pointer;
  flex-shrink: 0;
  flex-grow: 0;
  text-decoration: underline;
  color: var(--link);
}

.file-header__name {
  margin: 10px;
  flex-shrink: 2;
  flex-grow: 2;
}

.file-header__stat {
  margin: 10px;
  flex-shrink: 0;
  flex-grow: 0;
}

.file-content {
  margin: 10px 0 0;
  border: 1px solid #999;
  padding: 10px;
  counter-reset: line;
  display: flex;
  flex-direction: column;
}

.code-line::before {
  content: counter(line);
  margin-right: 10px;
}
.code-line {
  margin: 0;
  padding: 0.3em;
  height: 1em;
  counter-increment: line;
}
.code-line_covered {
  background: var(--green);
}
.code-line_uncovered {
  background: var(--red);
}

#theme-toggle-label {
  margin-left: 1ch;
}
</style>
</head>
<body>
    <div id="root"></div>
    <script>
        var data = {"files":[{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","content-registry","src","constants.rs"],"content":"/// Seeds\r\npub const REGISTRY_CONFIG_SEED: \u0026[u8] = b\"registry-config\";\r\npub const CONTENT_RECORD_SEED: \u0026[u8] = b\"content-record\";\r\npub const USER_ENERGY_SEED: \u0026[u8] = b\"user-energy\";\r\npub const RATE_LIMIT_SEED: \u0026[u8] = b\"rate-limit\";\r\npub const ENERGY_CONFIG_SEED: \u0026[u8] = b\"energy-config\";\r\n\r\n/// Energy costs by action\r\npub const ENERGY_COST_TEXT_POST: u16 = 10;\r\npub const ENERGY_COST_IMAGE_POST: u16 = 20;\r\npub const ENERGY_COST_VIDEO_POST: u16 = 50;\r\npub const ENERGY_COST_THREAD: u16 = 40;\r\npub const ENERGY_COST_REPLY: u16 = 5;\r\npub const ENERGY_COST_REPOST: u16 = 8;\r\npub const ENERGY_COST_EDIT_AFTER_1H: u16 = 5;\r\n\r\n/// Energy regen rate per hour by tier\r\npub const REGEN_RATE_NONE: u16 = 20;\r\npub const REGEN_RATE_BRONZE: u16 = 50;\r\npub const REGEN_RATE_SILVER: u16 = 80;\r\npub const REGEN_RATE_GOLD: u16 = 120;\r\npub const REGEN_RATE_PLATINUM: u16 = 200;\r\n\r\n/// Max energy by tier\r\npub const MAX_ENERGY_NONE: u16 = 200;\r\npub const MAX_ENERGY_BRONZE: u16 = 500;\r\npub const MAX_ENERGY_SILVER: u16 = 800;\r\npub const MAX_ENERGY_GOLD: u16 = 1200;\r\npub const MAX_ENERGY_PLATINUM: u16 = 2000;\r\n\r\n/// Engagement thresholds for refunds\r\npub const REFUND_THRESHOLD_10: u32 = 10;    // 25% refund\r\npub const REFUND_THRESHOLD_50: u32 = 50;    // 50% refund\r\npub const REFUND_THRESHOLD_100: u32 = 100;  // 100% refund\r\npub const REFUND_THRESHOLD_1000: u32 = 1000; // 150% refund (viral)\r\n\r\n/// Timing\r\npub const ENGAGEMENT_CHECK_DELAY: i64 = 24 * 60 * 60; // 24 hours\r\npub const FREE_EDIT_WINDOW: i64 = 60 * 60; // 1 hour\r\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","content-registry","src","contexts","claim_refund.rs"],"content":"use anchor_lang::prelude::*;\r\nuse crate::constants::*;\r\nuse crate::state::{ContentRecord, UserEnergy};\r\n\r\n#[derive(Accounts)]\r\npub struct ClaimRefund\u003c'info\u003e {\r\n    #[account(\r\n        mut,\r\n        seeds = [CONTENT_RECORD_SEED, content_record.tracking_id.as_ref()],\r\n        bump = content_record.bump,\r\n        has_one = author\r\n    )]\r\n    pub content_record: Account\u003c'info, ContentRecord\u003e,\r\n    \r\n    #[account(\r\n        mut,\r\n        seeds = [USER_ENERGY_SEED, author.key().as_ref()],\r\n        bump = user_energy.bump\r\n    )]\r\n    pub user_energy: Account\u003c'info, UserEnergy\u003e,\r\n    \r\n    pub author: Signer\u003c'info\u003e,\r\n}\r\n\r\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","content-registry","src","contexts","create_content.rs"],"content":"use anchor_lang::prelude::*;\r\nuse crate::constants::*;\r\nuse crate::state::{RegistryConfig, ContentRecord, UserEnergy, UserRateLimit};\r\n\r\n#[derive(Accounts)]\r\n#[instruction(tracking_id: [u8; 32])]\r\npub struct CreateContent\u003c'info\u003e {\r\n    #[account(\r\n        mut,\r\n        seeds = [REGISTRY_CONFIG_SEED],\r\n        bump = registry_config.bump\r\n    )]\r\n    pub registry_config: Account\u003c'info, RegistryConfig\u003e,\r\n    \r\n    #[account(\r\n        init,\r\n        payer = author,\r\n        space = ContentRecord::LEN,\r\n        seeds = [CONTENT_RECORD_SEED, tracking_id.as_ref()],\r\n        bump\r\n    )]\r\n    pub content_record: Account\u003c'info, ContentRecord\u003e,\r\n    \r\n    #[account(\r\n        mut,\r\n        seeds = [USER_ENERGY_SEED, author.key().as_ref()],\r\n        bump = user_energy.bump\r\n    )]\r\n    pub user_energy: Account\u003c'info, UserEnergy\u003e,\r\n    \r\n    #[account(\r\n        init_if_needed,\r\n        payer = author,\r\n        space = UserRateLimit::LEN,\r\n        seeds = [RATE_LIMIT_SEED, author.key().as_ref()],\r\n        bump\r\n    )]\r\n    pub rate_limit: Account\u003c'info, UserRateLimit\u003e,\r\n    \r\n    #[account(mut)]\r\n    pub author: Signer\u003c'info\u003e,\r\n    \r\n    pub system_program: Program\u003c'info, System\u003e,\r\n}\r\n\r\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","content-registry","src","contexts","delete_content.rs"],"content":"use anchor_lang::prelude::*;\r\nuse crate::constants::*;\r\nuse crate::state::{RegistryConfig, ContentRecord};\r\n\r\n#[derive(Accounts)]\r\npub struct DeleteContent\u003c'info\u003e {\r\n    #[account(\r\n        mut,\r\n        seeds = [REGISTRY_CONFIG_SEED],\r\n        bump = registry_config.bump\r\n    )]\r\n    pub registry_config: Account\u003c'info, RegistryConfig\u003e,\r\n    \r\n    #[account(\r\n        mut,\r\n        seeds = [CONTENT_RECORD_SEED, content_record.tracking_id.as_ref()],\r\n        bump = content_record.bump,\r\n        has_one = author\r\n    )]\r\n    pub content_record: Account\u003c'info, ContentRecord\u003e,\r\n    \r\n    pub author: Signer\u003c'info\u003e,\r\n}\r\n\r\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","content-registry","src","contexts","edit_content.rs"],"content":"use anchor_lang::prelude::*;\r\nuse crate::constants::*;\r\nuse crate::state::{ContentRecord, UserEnergy};\r\n\r\n#[derive(Accounts)]\r\npub struct EditContent\u003c'info\u003e {\r\n    #[account(\r\n        mut,\r\n        seeds = [CONTENT_RECORD_SEED, content_record.tracking_id.as_ref()],\r\n        bump = content_record.bump,\r\n        has_one = author\r\n    )]\r\n    pub content_record: Account\u003c'info, ContentRecord\u003e,\r\n    \r\n    #[account(\r\n        mut,\r\n        seeds = [USER_ENERGY_SEED, author.key().as_ref()],\r\n        bump = user_energy.bump\r\n    )]\r\n    pub user_energy: Account\u003c'info, UserEnergy\u003e,\r\n    \r\n    pub author: Signer\u003c'info\u003e,\r\n}\r\n\r\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","content-registry","src","contexts","get_content.rs"],"content":"use anchor_lang::prelude::*;\r\nuse crate::constants::CONTENT_RECORD_SEED;\r\nuse crate::state::ContentRecord;\r\n\r\n#[derive(Accounts)]\r\npub struct GetContent\u003c'info\u003e {\r\n    #[account(\r\n        seeds = [CONTENT_RECORD_SEED, content_record.tracking_id.as_ref()],\r\n        bump = content_record.bump\r\n    )]\r\n    pub content_record: Account\u003c'info, ContentRecord\u003e,\r\n}\r\n\r\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","content-registry","src","contexts","get_energy.rs"],"content":"use anchor_lang::prelude::*;\r\nuse crate::constants::USER_ENERGY_SEED;\r\nuse crate::state::UserEnergy;\r\n\r\n#[derive(Accounts)]\r\npub struct GetEnergy\u003c'info\u003e {\r\n    #[account(\r\n        seeds = [USER_ENERGY_SEED, user_energy.user.as_ref()],\r\n        bump = user_energy.bump\r\n    )]\r\n    pub user_energy: Account\u003c'info, UserEnergy\u003e,\r\n}\r\n\r\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","content-registry","src","contexts","initialize.rs"],"content":"use anchor_lang::prelude::*;\r\nuse crate::constants::REGISTRY_CONFIG_SEED;\r\nuse crate::state::RegistryConfig;\r\n\r\n#[derive(Accounts)]\r\npub struct Initialize\u003c'info\u003e {\r\n    #[account(\r\n        init,\r\n        payer = authority,\r\n        space = RegistryConfig::LEN,\r\n        seeds = [REGISTRY_CONFIG_SEED],\r\n        bump\r\n    )]\r\n    pub registry_config: Account\u003c'info, RegistryConfig\u003e,\r\n    \r\n    #[account(mut)]\r\n    pub authority: Signer\u003c'info\u003e,\r\n    \r\n    pub system_program: Program\u003c'info, System\u003e,\r\n}\r\n\r\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","content-registry","src","contexts","initialize_energy.rs"],"content":"use anchor_lang::prelude::*;\r\nuse crate::constants::ENERGY_CONFIG_SEED;\r\nuse crate::state::EnergyConfig;\r\n\r\n#[derive(Accounts)]\r\npub struct InitializeEnergy\u003c'info\u003e {\r\n    #[account(\r\n        init,\r\n        payer = authority,\r\n        space = EnergyConfig::LEN,\r\n        seeds = [ENERGY_CONFIG_SEED],\r\n        bump\r\n    )]\r\n    pub energy_config: Account\u003c'info, EnergyConfig\u003e,\r\n    \r\n    #[account(mut)]\r\n    pub authority: Signer\u003c'info\u003e,\r\n    \r\n    pub system_program: Program\u003c'info, System\u003e,\r\n}\r\n\r\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","content-registry","src","contexts","initialize_user_energy.rs"],"content":"use anchor_lang::prelude::*;\r\nuse crate::constants::USER_ENERGY_SEED;\r\nuse crate::state::UserEnergy;\r\n\r\n#[derive(Accounts)]\r\npub struct InitializeUserEnergy\u003c'info\u003e {\r\n    #[account(\r\n        init,\r\n        payer = user,\r\n        space = UserEnergy::LEN,\r\n        seeds = [USER_ENERGY_SEED, user.key().as_ref()],\r\n        bump\r\n    )]\r\n    pub user_energy: Account\u003c'info, UserEnergy\u003e,\r\n    \r\n    #[account(mut)]\r\n    pub user: Signer\u003c'info\u003e,\r\n    \r\n    pub system_program: Program\u003c'info, System\u003e,\r\n}\r\n\r\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","content-registry","src","contexts","mod.rs"],"content":"pub mod initialize;\r\npub mod initialize_energy;\r\npub mod create_content;\r\npub mod edit_content;\r\npub mod delete_content;\r\npub mod update_engagement;\r\npub mod claim_refund;\r\npub mod initialize_user_energy;\r\npub mod update_user_tier;\r\npub mod update_config;\r\npub mod update_authority;\r\npub mod get_content;\r\npub mod get_energy;\r\n\r\npub use initialize::*;\r\npub use initialize_energy::*;\r\npub use create_content::*;\r\npub use edit_content::*;\r\npub use delete_content::*;\r\npub use update_engagement::*;\r\npub use claim_refund::*;\r\npub use initialize_user_energy::*;\r\npub use update_user_tier::*;\r\npub use update_config::*;\r\npub use update_authority::*;\r\npub use get_content::*;\r\npub use get_energy::*;\r\n\r\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","content-registry","src","contexts","update_authority.rs"],"content":"use anchor_lang::prelude::*;\r\nuse crate::constants::REGISTRY_CONFIG_SEED;\r\nuse crate::errors::ContentError;\r\nuse crate::state::RegistryConfig;\r\n\r\n#[derive(Accounts)]\r\npub struct UpdateAuthority\u003c'info\u003e {\r\n    #[account(\r\n        mut,\r\n        seeds = [REGISTRY_CONFIG_SEED],\r\n        bump = registry_config.bump,\r\n        has_one = authority @ ContentError::Unauthorized\r\n    )]\r\n    pub registry_config: Account\u003c'info, RegistryConfig\u003e,\r\n    \r\n    pub authority: Signer\u003c'info\u003e,\r\n}\r\n\r\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","content-registry","src","contexts","update_config.rs"],"content":"use anchor_lang::prelude::*;\r\nuse crate::constants::REGISTRY_CONFIG_SEED;\r\nuse crate::errors::ContentError;\r\nuse crate::state::RegistryConfig;\r\n\r\n#[derive(Accounts)]\r\npub struct UpdateConfig\u003c'info\u003e {\r\n    #[account(\r\n        mut,\r\n        seeds = [REGISTRY_CONFIG_SEED],\r\n        bump = registry_config.bump,\r\n        has_one = authority @ ContentError::Unauthorized\r\n    )]\r\n    pub registry_config: Account\u003c'info, RegistryConfig\u003e,\r\n    \r\n    pub authority: Signer\u003c'info\u003e,\r\n}\r\n\r\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","content-registry","src","contexts","update_engagement.rs"],"content":"use anchor_lang::prelude::*;\r\nuse crate::constants::*;\r\nuse crate::errors::ContentError;\r\nuse crate::state::{ContentRecord, RegistryConfig};\r\n\r\n#[derive(Accounts)]\r\npub struct UpdateEngagement\u003c'info\u003e {\r\n    #[account(\r\n        mut,\r\n        seeds = [CONTENT_RECORD_SEED, content_record.tracking_id.as_ref()],\r\n        bump = content_record.bump\r\n    )]\r\n    pub content_record: Account\u003c'info, ContentRecord\u003e,\r\n    \r\n    #[account(\r\n        seeds = [REGISTRY_CONFIG_SEED],\r\n        bump = registry_config.bump,\r\n        has_one = authority @ ContentError::Unauthorized\r\n    )]\r\n    pub registry_config: Account\u003c'info, RegistryConfig\u003e,\r\n    \r\n    pub authority: Signer\u003c'info\u003e,\r\n}\r\n\r\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","content-registry","src","contexts","update_user_tier.rs"],"content":"use anchor_lang::prelude::*;\r\nuse crate::constants::*;\r\nuse crate::errors::ContentError;\r\nuse crate::state::{UserEnergy, RegistryConfig};\r\n\r\n#[derive(Accounts)]\r\npub struct UpdateUserTier\u003c'info\u003e {\r\n    #[account(\r\n        mut,\r\n        seeds = [USER_ENERGY_SEED, user_energy.user.as_ref()],\r\n        bump = user_energy.bump\r\n    )]\r\n    pub user_energy: Account\u003c'info, UserEnergy\u003e,\r\n    \r\n    #[account(\r\n        seeds = [REGISTRY_CONFIG_SEED],\r\n        bump = registry_config.bump,\r\n        has_one = authority @ ContentError::Unauthorized\r\n    )]\r\n    pub registry_config: Account\u003c'info, RegistryConfig\u003e,\r\n    \r\n    pub authority: Signer\u003c'info\u003e,\r\n}\r\n\r\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","content-registry","src","errors.rs"],"content":"use anchor_lang::prelude::*;\r\n\r\n#[error_code]\r\npub enum ContentError {\r\n    #[msg(\"Unauthorized: Only the authority can perform this action\")]\r\n    Unauthorized,\r\n    #[msg(\"Content registry is paused\")]\r\n    RegistryPaused,\r\n    #[msg(\"Content not found\")]\r\n    ContentNotFound,\r\n    #[msg(\"Content already deleted\")]\r\n    ContentAlreadyDeleted,\r\n    #[msg(\"Cannot edit deleted content\")]\r\n    CannotEditDeleted,\r\n    #[msg(\"Insufficient energy for this action\")]\r\n    InsufficientEnergy,\r\n    #[msg(\"Daily post cap exceeded\")]\r\n    DailyCapExceeded,\r\n    #[msg(\"Cooldown period not elapsed\")]\r\n    CooldownNotElapsed,\r\n    #[msg(\"Invalid content type\")]\r\n    InvalidContentType,\r\n    #[msg(\"Content URI too long (max 128 chars)\")]\r\n    ContentURITooLong,\r\n    #[msg(\"Energy refund already claimed\")]\r\n    RefundAlreadyClaimed,\r\n    #[msg(\"Engagement check period not elapsed\")]\r\n    RefundNotReady,\r\n    #[msg(\"Arithmetic overflow\")]\r\n    Overflow,\r\n}\r\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","content-registry","src","events.rs"],"content":"use anchor_lang::prelude::*;\r\n\r\n#[event]\r\npub struct ContentCreated {\r\n    pub tracking_id: [u8; 32],\r\n    pub author: Pubkey,\r\n    pub content_type: u8,\r\n    pub content_hash: [u8; 32],\r\n    pub timestamp: i64,\r\n}\r\n\r\n#[event]\r\npub struct ContentEdited {\r\n    pub tracking_id: [u8; 32],\r\n    pub author: Pubkey,\r\n    pub version: u16,\r\n    pub new_hash: [u8; 32],\r\n    pub timestamp: i64,\r\n}\r\n\r\n#[event]\r\npub struct ContentDeleted {\r\n    pub tracking_id: [u8; 32],\r\n    pub author: Pubkey,\r\n    pub timestamp: i64,\r\n}\r\n\r\n#[event]\r\npub struct EnergySpent {\r\n    pub user: Pubkey,\r\n    pub amount: u16,\r\n    pub action: String,\r\n    pub remaining: u16,\r\n}\r\n\r\n#[event]\r\npub struct EnergyRefunded {\r\n    pub user: Pubkey,\r\n    pub content_id: [u8; 32],\r\n    pub refund_amount: u16,\r\n    pub engagement_count: u32,\r\n}\r\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","content-registry","src","instructions","admin","initialize.rs"],"content":"use anchor_lang::prelude::*;\r\nuse crate::contexts::Initialize;\r\n\r\npub fn handler(\r\n    ctx: Context\u003cInitialize\u003e,\r\n    identity_program: Pubkey,\r\n    staking_program: Pubkey,\r\n) -\u003e Result\u003c()\u003e {\r\n    let config = \u0026mut ctx.accounts.registry_config;\r\n    \r\n    config.authority = ctx.accounts.authority.key();\r\n    config.identity_program = identity_program;\r\n    config.staking_program = staking_program;\r\n    config.total_content_count = 0;\r\n    config.active_content_count = 0;\r\n    config.paused = false;\r\n    config.bump = ctx.bumps.registry_config;\r\n    \r\n    msg!(\"Content registry initialized\");\r\n    Ok(())\r\n}\r\n\r\n","traces":[{"line":4,"address":[],"length":0,"stats":{"Line":0}},{"line":9,"address":[],"length":0,"stats":{"Line":0}},{"line":11,"address":[],"length":0,"stats":{"Line":0}},{"line":12,"address":[],"length":0,"stats":{"Line":0}},{"line":13,"address":[],"length":0,"stats":{"Line":0}},{"line":14,"address":[],"length":0,"stats":{"Line":0}},{"line":15,"address":[],"length":0,"stats":{"Line":0}},{"line":16,"address":[],"length":0,"stats":{"Line":0}},{"line":17,"address":[],"length":0,"stats":{"Line":0}},{"line":19,"address":[],"length":0,"stats":{"Line":0}},{"line":20,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":11},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","content-registry","src","instructions","admin","initialize_energy.rs"],"content":"use anchor_lang::prelude::*;\r\nuse crate::constants::*;\r\nuse crate::contexts::InitializeEnergy;\r\n\r\npub fn handler(ctx: Context\u003cInitializeEnergy\u003e) -\u003e Result\u003c()\u003e {\r\n    let energy_config = \u0026mut ctx.accounts.energy_config;\r\n    \r\n    energy_config.authority = ctx.accounts.authority.key();\r\n    energy_config.base_regen_rate = REGEN_RATE_NONE;\r\n    energy_config.engagement_check_delay = ENGAGEMENT_CHECK_DELAY;\r\n    energy_config.viral_threshold = REFUND_THRESHOLD_1000;\r\n    energy_config.paused = false;\r\n    energy_config.bump = ctx.bumps.energy_config;\r\n    \r\n    msg!(\"Energy system initialized\");\r\n    Ok(())\r\n}\r\n\r\n","traces":[{"line":5,"address":[],"length":0,"stats":{"Line":0}},{"line":6,"address":[],"length":0,"stats":{"Line":0}},{"line":8,"address":[],"length":0,"stats":{"Line":0}},{"line":9,"address":[],"length":0,"stats":{"Line":0}},{"line":10,"address":[],"length":0,"stats":{"Line":0}},{"line":11,"address":[],"length":0,"stats":{"Line":0}},{"line":12,"address":[],"length":0,"stats":{"Line":0}},{"line":13,"address":[],"length":0,"stats":{"Line":0}},{"line":15,"address":[],"length":0,"stats":{"Line":0}},{"line":16,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":10},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","content-registry","src","instructions","admin","mod.rs"],"content":"pub mod initialize;\r\npub mod initialize_energy;\r\npub mod set_paused;\r\npub mod update_authority;\r\n\r\npub use initialize::*;\r\npub use initialize_energy::*;\r\npub use set_paused::*;\r\npub use update_authority::*;\r\n\r\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","content-registry","src","instructions","admin","set_paused.rs"],"content":"use anchor_lang::prelude::*;\r\nuse crate::contexts::UpdateConfig;\r\n\r\npub fn handler(ctx: Context\u003cUpdateConfig\u003e, paused: bool) -\u003e Result\u003c()\u003e {\r\n    ctx.accounts.registry_config.paused = paused;\r\n    msg!(\"Content registry paused: {}\", paused);\r\n    Ok(())\r\n}\r\n\r\n","traces":[{"line":4,"address":[],"length":0,"stats":{"Line":0}},{"line":5,"address":[],"length":0,"stats":{"Line":0}},{"line":6,"address":[],"length":0,"stats":{"Line":0}},{"line":7,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":4},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","content-registry","src","instructions","admin","update_authority.rs"],"content":"use anchor_lang::prelude::*;\r\nuse crate::contexts::UpdateAuthority;\r\n\r\npub fn handler(ctx: Context\u003cUpdateAuthority\u003e, new_authority: Pubkey) -\u003e Result\u003c()\u003e {\r\n    ctx.accounts.registry_config.authority = new_authority;\r\n    msg!(\"Authority updated to: {}\", new_authority);\r\n    Ok(())\r\n}\r\n\r\n","traces":[{"line":4,"address":[],"length":0,"stats":{"Line":0}},{"line":5,"address":[],"length":0,"stats":{"Line":0}},{"line":6,"address":[],"length":0,"stats":{"Line":0}},{"line":7,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":4},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","content-registry","src","instructions","content","create.rs"],"content":"use anchor_lang::prelude::*;\r\nuse crate::contexts::CreateContent;\r\nuse crate::errors::ContentError;\r\nuse crate::events::{ContentCreated, EnergySpent};\r\nuse crate::state::{ContentType, ContentState};\r\nuse crate::utils::{regenerate_energy, check_and_update_rate_limit};\r\n\r\npub fn handler(\r\n    ctx: Context\u003cCreateContent\u003e,\r\n    tracking_id: [u8; 32],\r\n    content_hash: [u8; 32],\r\n    content_uri: String,\r\n    content_type: u8,\r\n) -\u003e Result\u003c()\u003e {\r\n    require!(!ctx.accounts.registry_config.paused, ContentError::RegistryPaused);\r\n    require!(content_uri.len() \u003c= 128, ContentError::ContentURITooLong);\r\n    \r\n    let content_type_enum = ContentType::from_u8(content_type)\r\n        .ok_or(ContentError::InvalidContentType)?;\r\n    \r\n    let clock = Clock::get()?;\r\n    \r\n    // Check and spend energy\r\n    let user_energy = \u0026mut ctx.accounts.user_energy;\r\n    let energy_cost = content_type_enum.energy_cost();\r\n    \r\n    // Regenerate energy first\r\n    regenerate_energy(user_energy, clock.unix_timestamp)?;\r\n    \r\n    require!(\r\n        user_energy.current_energy \u003e= energy_cost,\r\n        ContentError::InsufficientEnergy\r\n    );\r\n    \r\n    // Check rate limit\r\n    let rate_limit = \u0026mut ctx.accounts.rate_limit;\r\n    check_and_update_rate_limit(rate_limit, user_energy.tier, clock.unix_timestamp)?;\r\n    \r\n    // Spend energy\r\n    user_energy.current_energy = user_energy.current_energy.saturating_sub(energy_cost);\r\n    user_energy.energy_spent_today = user_energy.energy_spent_today.saturating_add(energy_cost as u32);\r\n    \r\n    // Create content record\r\n    let content = \u0026mut ctx.accounts.content_record;\r\n    content.tracking_id = tracking_id;\r\n    content.author = ctx.accounts.author.key();\r\n    content.content_hash = content_hash;\r\n    \r\n    let uri_bytes = content_uri.as_bytes();\r\n    content.content_uri[..uri_bytes.len()].copy_from_slice(uri_bytes);\r\n    content.uri_len = uri_bytes.len() as u8;\r\n    \r\n    content.content_type = content_type;\r\n    content.state = ContentState::Active as u8;\r\n    content.version = 1;\r\n    content.created_at = clock.unix_timestamp;\r\n    content.updated_at = clock.unix_timestamp;\r\n    content.previous_hash = [0u8; 32];\r\n    content.energy_spent = energy_cost;\r\n    content.refund_claimed = false;\r\n    content.engagement_count = 0;\r\n    content.bump = ctx.bumps.content_record;\r\n    \r\n    // Update registry stats\r\n    let config = \u0026mut ctx.accounts.registry_config;\r\n    config.total_content_count = config.total_content_count.saturating_add(1);\r\n    config.active_content_count = config.active_content_count.saturating_add(1);\r\n    \r\n    emit!(ContentCreated {\r\n        tracking_id,\r\n        author: content.author,\r\n        content_type,\r\n        content_hash,\r\n        timestamp: clock.unix_timestamp,\r\n    });\r\n    \r\n    emit!(EnergySpent {\r\n        user: content.author,\r\n        amount: energy_cost,\r\n        action: \"create_content\".to_string(),\r\n        remaining: user_energy.current_energy,\r\n    });\r\n    \r\n    msg!(\"Content created: {:?}\", tracking_id);\r\n    Ok(())\r\n}\r\n\r\n","traces":[{"line":8,"address":[],"length":0,"stats":{"Line":0}},{"line":15,"address":[],"length":0,"stats":{"Line":0}},{"line":16,"address":[],"length":0,"stats":{"Line":0}},{"line":18,"address":[],"length":0,"stats":{"Line":0}},{"line":19,"address":[],"length":0,"stats":{"Line":0}},{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":49},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","content-registry","src","instructions","content","delete.rs"],"content":"use anchor_lang::prelude::*;\r\nuse crate::contexts::DeleteContent;\r\nuse crate::errors::ContentError;\r\nuse crate::events::ContentDeleted;\r\nuse crate::state::ContentState;\r\n\r\npub fn handler(ctx: Context\u003cDeleteContent\u003e) -\u003e Result\u003c()\u003e {\r\n    let content = \u0026mut ctx.accounts.content_record;\r\n    \r\n    require!(\r\n        content.state != ContentState::Deleted as u8,\r\n        ContentError::ContentAlreadyDeleted\r\n    );\r\n    \r\n    let clock = Clock::get()?;\r\n    \r\n    content.state = ContentState::Deleted as u8;\r\n    content.updated_at = clock.unix_timestamp;\r\n    \r\n    // Update registry stats\r\n    let config = \u0026mut ctx.accounts.registry_config;\r\n    config.active_content_count = config.active_content_count.saturating_sub(1);\r\n    \r\n    emit!(ContentDeleted {\r\n        tracking_id: content.tracking_id,\r\n        author: content.author,\r\n        timestamp: clock.unix_timestamp,\r\n    });\r\n    \r\n    msg!(\"Content deleted\");\r\n    Ok(())\r\n}\r\n\r\n","traces":[{"line":7,"address":[],"length":0,"stats":{"Line":0}},{"line":8,"address":[],"length":0,"stats":{"Line":0}},{"line":10,"address":[],"length":0,"stats":{"Line":0}},{"line":11,"address":[],"length":0,"stats":{"Line":0}},{"line":12,"address":[],"length":0,"stats":{"Line":0}},{"line":15,"address":[],"length":0,"stats":{"Line":0}},{"line":17,"address":[],"length":0,"stats":{"Line":0}},{"line":18,"address":[],"length":0,"stats":{"Line":0}},{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":31,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":16},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","content-registry","src","instructions","content","edit.rs"],"content":"use anchor_lang::prelude::*;\r\nuse crate::constants::*;\r\nuse crate::contexts::EditContent;\r\nuse crate::errors::ContentError;\r\nuse crate::events::ContentEdited;\r\nuse crate::state::ContentState;\r\nuse crate::utils::regenerate_energy;\r\n\r\npub fn handler(\r\n    ctx: Context\u003cEditContent\u003e,\r\n    new_content_hash: [u8; 32],\r\n    new_content_uri: String,\r\n) -\u003e Result\u003c()\u003e {\r\n    let content = \u0026mut ctx.accounts.content_record;\r\n    \r\n    require!(\r\n        content.state != ContentState::Deleted as u8,\r\n        ContentError::CannotEditDeleted\r\n    );\r\n    require!(new_content_uri.len() \u003c= 128, ContentError::ContentURITooLong);\r\n    \r\n    let clock = Clock::get()?;\r\n    let time_since_creation = clock.unix_timestamp - content.created_at;\r\n    \r\n    // Free edits within 1 hour of creation\r\n    if time_since_creation \u003e FREE_EDIT_WINDOW {\r\n        let user_energy = \u0026mut ctx.accounts.user_energy;\r\n        regenerate_energy(user_energy, clock.unix_timestamp)?;\r\n        \r\n        require!(\r\n            user_energy.current_energy \u003e= ENERGY_COST_EDIT_AFTER_1H,\r\n            ContentError::InsufficientEnergy\r\n        );\r\n        \r\n        user_energy.current_energy = user_energy.current_energy.saturating_sub(ENERGY_COST_EDIT_AFTER_1H);\r\n    }\r\n    \r\n    // Store previous hash for history\r\n    content.previous_hash = content.content_hash;\r\n    content.content_hash = new_content_hash;\r\n    \r\n    let uri_bytes = new_content_uri.as_bytes();\r\n    content.content_uri = [0u8; 128];\r\n    content.content_uri[..uri_bytes.len()].copy_from_slice(uri_bytes);\r\n    content.uri_len = uri_bytes.len() as u8;\r\n    \r\n    content.state = ContentState::Edited as u8;\r\n    content.version = content.version.saturating_add(1);\r\n    content.updated_at = clock.unix_timestamp;\r\n    \r\n    emit!(ContentEdited {\r\n        tracking_id: content.tracking_id,\r\n        author: content.author,\r\n        version: content.version,\r\n        new_hash: new_content_hash,\r\n        timestamp: clock.unix_timestamp,\r\n    });\r\n    \r\n    msg!(\"Content edited: version {}\", content.version);\r\n    Ok(())\r\n}\r\n\r\n","traces":[{"line":9,"address":[],"length":0,"stats":{"Line":0}},{"line":14,"address":[],"length":0,"stats":{"Line":0}},{"line":16,"address":[],"length":0,"stats":{"Line":0}},{"line":17,"address":[],"length":0,"stats":{"Line":0}},{"line":18,"address":[],"length":0,"stats":{"Line":0}},{"line":20,"address":[],"length":0,"stats":{"Line":0}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":32},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","content-registry","src","instructions","content","mod.rs"],"content":"pub mod create;\r\npub mod edit;\r\npub mod delete;\r\npub mod update_engagement;\r\n\r\npub use create::*;\r\npub use edit::*;\r\npub use delete::*;\r\npub use update_engagement::*;\r\n\r\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","content-registry","src","instructions","content","update_engagement.rs"],"content":"use anchor_lang::prelude::*;\r\nuse crate::contexts::UpdateEngagement;\r\n\r\npub fn handler(\r\n    ctx: Context\u003cUpdateEngagement\u003e,\r\n    engagement_count: u32,\r\n) -\u003e Result\u003c()\u003e {\r\n    let content = \u0026mut ctx.accounts.content_record;\r\n    content.engagement_count = engagement_count;\r\n    \r\n    msg!(\"Engagement updated: {}\", engagement_count);\r\n    Ok(())\r\n}\r\n\r\n","traces":[{"line":4,"address":[],"length":0,"stats":{"Line":0}},{"line":8,"address":[],"length":0,"stats":{"Line":0}},{"line":9,"address":[],"length":0,"stats":{"Line":0}},{"line":11,"address":[],"length":0,"stats":{"Line":0}},{"line":12,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":5},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","content-registry","src","instructions","energy","claim_refund.rs"],"content":"use anchor_lang::prelude::*;\r\nuse crate::constants::*;\r\nuse crate::contexts::ClaimRefund;\r\nuse crate::errors::ContentError;\r\nuse crate::events::EnergyRefunded;\r\n\r\npub fn handler(ctx: Context\u003cClaimRefund\u003e) -\u003e Result\u003c()\u003e {\r\n    let content = \u0026mut ctx.accounts.content_record;\r\n    \r\n    require!(!content.refund_claimed, ContentError::RefundAlreadyClaimed);\r\n    \r\n    let clock = Clock::get()?;\r\n    let elapsed = clock.unix_timestamp - content.created_at;\r\n    \r\n    require!(\r\n        elapsed \u003e= ENGAGEMENT_CHECK_DELAY,\r\n        ContentError::RefundNotReady\r\n    );\r\n    \r\n    // Calculate refund based on engagement\r\n    let refund_pct = if content.engagement_count \u003e= REFUND_THRESHOLD_1000 {\r\n        150 // 150% (bonus energy!)\r\n    } else if content.engagement_count \u003e= REFUND_THRESHOLD_100 {\r\n        100 // 100%\r\n    } else if content.engagement_count \u003e= REFUND_THRESHOLD_50 {\r\n        50 // 50%\r\n    } else if content.engagement_count \u003e= REFUND_THRESHOLD_10 {\r\n        25 // 25%\r\n    } else {\r\n        0 // No refund\r\n    };\r\n    \r\n    if refund_pct \u003e 0 {\r\n        let refund_amount = ((content.energy_spent as u32 * refund_pct) / 100) as u16;\r\n        \r\n        let user_energy = \u0026mut ctx.accounts.user_energy;\r\n        user_energy.current_energy = user_energy.current_energy\r\n            .saturating_add(refund_amount)\r\n            .min(user_energy.max_energy);\r\n        user_energy.energy_refunded_today = user_energy.energy_refunded_today\r\n            .saturating_add(refund_amount as u32);\r\n        \r\n        emit!(EnergyRefunded {\r\n            user: user_energy.user,\r\n            content_id: content.tracking_id,\r\n            refund_amount,\r\n            engagement_count: content.engagement_count,\r\n        });\r\n        \r\n        msg!(\"Energy refunded: {} ({}%)\", refund_amount, refund_pct);\r\n    }\r\n    \r\n    content.refund_claimed = true;\r\n    \r\n    Ok(())\r\n}\r\n\r\n","traces":[{"line":7,"address":[],"length":0,"stats":{"Line":0}},{"line":8,"address":[],"length":0,"stats":{"Line":0}},{"line":10,"address":[],"length":0,"stats":{"Line":0}},{"line":12,"address":[],"length":0,"stats":{"Line":0}},{"line":13,"address":[],"length":0,"stats":{"Line":0}},{"line":15,"address":[],"length":0,"stats":{"Line":0}},{"line":16,"address":[],"length":0,"stats":{"Line":0}},{"line":17,"address":[],"length":0,"stats":{"Line":0}},{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":33},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","content-registry","src","instructions","energy","initialize_user.rs"],"content":"use anchor_lang::prelude::*;\r\nuse crate::contexts::InitializeUserEnergy;\r\nuse crate::state::UserEnergy;\r\n\r\npub fn handler(ctx: Context\u003cInitializeUserEnergy\u003e, tier: u8) -\u003e Result\u003c()\u003e {\r\n    let clock = Clock::get()?;\r\n    let user_energy = \u0026mut ctx.accounts.user_energy;\r\n    \r\n    user_energy.user = ctx.accounts.user.key();\r\n    user_energy.tier = tier;\r\n    user_energy.max_energy = UserEnergy::max_energy_for_tier(tier);\r\n    user_energy.regen_rate = UserEnergy::regen_rate_for_tier(tier);\r\n    user_energy.current_energy = user_energy.max_energy; // Start full\r\n    user_energy.last_regen_time = clock.unix_timestamp;\r\n    user_energy.energy_spent_today = 0;\r\n    user_energy.energy_refunded_today = 0;\r\n    user_energy.last_reset = clock.unix_timestamp;\r\n    user_energy.bump = ctx.bumps.user_energy;\r\n    \r\n    msg!(\"User energy initialized: tier {}, max {}\", tier, user_energy.max_energy);\r\n    Ok(())\r\n}\r\n\r\n","traces":[{"line":5,"address":[],"length":0,"stats":{"Line":0}},{"line":6,"address":[],"length":0,"stats":{"Line":0}},{"line":7,"address":[],"length":0,"stats":{"Line":0}},{"line":9,"address":[],"length":0,"stats":{"Line":0}},{"line":10,"address":[],"length":0,"stats":{"Line":0}},{"line":11,"address":[],"length":0,"stats":{"Line":0}},{"line":12,"address":[],"length":0,"stats":{"Line":0}},{"line":13,"address":[],"length":0,"stats":{"Line":0}},{"line":14,"address":[],"length":0,"stats":{"Line":0}},{"line":15,"address":[],"length":0,"stats":{"Line":0}},{"line":16,"address":[],"length":0,"stats":{"Line":0}},{"line":17,"address":[],"length":0,"stats":{"Line":0}},{"line":18,"address":[],"length":0,"stats":{"Line":0}},{"line":20,"address":[],"length":0,"stats":{"Line":0}},{"line":21,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":15},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","content-registry","src","instructions","energy","mod.rs"],"content":"pub mod claim_refund;\r\npub mod initialize_user;\r\npub mod update_tier;\r\n\r\npub use claim_refund::*;\r\npub use initialize_user::*;\r\npub use update_tier::*;\r\n\r\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","content-registry","src","instructions","energy","update_tier.rs"],"content":"use anchor_lang::prelude::*;\r\nuse crate::contexts::UpdateUserTier;\r\nuse crate::state::UserEnergy;\r\n\r\npub fn handler(ctx: Context\u003cUpdateUserTier\u003e, new_tier: u8) -\u003e Result\u003c()\u003e {\r\n    let user_energy = \u0026mut ctx.accounts.user_energy;\r\n    \r\n    user_energy.tier = new_tier;\r\n    user_energy.max_energy = UserEnergy::max_energy_for_tier(new_tier);\r\n    user_energy.regen_rate = UserEnergy::regen_rate_for_tier(new_tier);\r\n    \r\n    // Cap current energy at new max\r\n    if user_energy.current_energy \u003e user_energy.max_energy {\r\n        user_energy.current_energy = user_energy.max_energy;\r\n    }\r\n    \r\n    msg!(\"User tier updated: {}\", new_tier);\r\n    Ok(())\r\n}\r\n\r\n","traces":[{"line":5,"address":[],"length":0,"stats":{"Line":0}},{"line":6,"address":[],"length":0,"stats":{"Line":0}},{"line":8,"address":[],"length":0,"stats":{"Line":0}},{"line":9,"address":[],"length":0,"stats":{"Line":0}},{"line":10,"address":[],"length":0,"stats":{"Line":0}},{"line":13,"address":[],"length":0,"stats":{"Line":0}},{"line":14,"address":[],"length":0,"stats":{"Line":0}},{"line":17,"address":[],"length":0,"stats":{"Line":0}},{"line":18,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":9},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","content-registry","src","instructions","mod.rs"],"content":"pub mod admin;\r\npub mod content;\r\npub mod energy;\r\npub mod query;\r\n\r\npub use admin::*;\r\npub use content::*;\r\npub use energy::*;\r\npub use query::*;\r\n\r\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","content-registry","src","instructions","query","get_content.rs"],"content":"use anchor_lang::prelude::*;\r\nuse crate::contexts::GetContent;\r\n\r\npub fn handler(ctx: Context\u003cGetContent\u003e) -\u003e Result\u003c()\u003e {\r\n    let content = \u0026ctx.accounts.content_record;\r\n    msg!(\"Tracking ID: {:?}\", content.tracking_id);\r\n    msg!(\"Author: {}\", content.author);\r\n    msg!(\"Type: {}\", content.content_type);\r\n    msg!(\"State: {}\", content.state);\r\n    msg!(\"Version: {}\", content.version);\r\n    Ok(())\r\n}\r\n\r\n","traces":[{"line":4,"address":[],"length":0,"stats":{"Line":0}},{"line":5,"address":[],"length":0,"stats":{"Line":0}},{"line":6,"address":[],"length":0,"stats":{"Line":0}},{"line":7,"address":[],"length":0,"stats":{"Line":0}},{"line":8,"address":[],"length":0,"stats":{"Line":0}},{"line":9,"address":[],"length":0,"stats":{"Line":0}},{"line":10,"address":[],"length":0,"stats":{"Line":0}},{"line":11,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":8},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","content-registry","src","instructions","query","get_energy.rs"],"content":"use anchor_lang::prelude::*;\r\nuse crate::contexts::GetEnergy;\r\n\r\npub fn handler(ctx: Context\u003cGetEnergy\u003e) -\u003e Result\u003c()\u003e {\r\n    let energy = \u0026ctx.accounts.user_energy;\r\n    msg!(\"User: {}\", energy.user);\r\n    msg!(\"Current: {}/{}\", energy.current_energy, energy.max_energy);\r\n    msg!(\"Regen rate: {}/hr\", energy.regen_rate);\r\n    msg!(\"Tier: {}\", energy.tier);\r\n    Ok(())\r\n}\r\n\r\n","traces":[{"line":4,"address":[],"length":0,"stats":{"Line":0}},{"line":5,"address":[],"length":0,"stats":{"Line":0}},{"line":6,"address":[],"length":0,"stats":{"Line":0}},{"line":7,"address":[],"length":0,"stats":{"Line":0}},{"line":8,"address":[],"length":0,"stats":{"Line":0}},{"line":9,"address":[],"length":0,"stats":{"Line":0}},{"line":10,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":7},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","content-registry","src","instructions","query","mod.rs"],"content":"pub mod get_content;\r\npub mod get_energy;\r\n\r\npub use get_content::*;\r\npub use get_energy::*;\r\n\r\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","content-registry","src","lib.rs"],"content":"use anchor_lang::prelude::*;\r\n\r\ndeclare_id!(\"MJn1A4MPCBPJGWWuZrtq7bHSo2G289sUwW3ej2wcmLV\");\r\n\r\n/// Content Registry Protocol\r\n/// \r\n/// On-chain tracking hash with state management.\r\n/// Each piece of content gets a unique tracking hash stored on-chain.\r\n/// \r\n/// Content Types:\r\n/// - Post (text/image)\r\n/// - Article (long-form)\r\n/// - Media (video/audio)\r\n/// - NFT (tokenized content)\r\n/// - Thread (multi-post)\r\n/// \r\n/// State Flow: Active → Edited → Deleted (soft) → Archived\r\n\r\npub mod constants;\r\npub mod errors;\r\npub mod events;\r\npub mod state;\r\npub mod contexts;\r\npub mod instructions;\r\npub mod utils;\r\n\r\n#[cfg(test)]\r\nmod tests;\r\n\r\nuse contexts::*;\r\nuse instructions::*;\r\n\r\n#[program]\r\npub mod content_registry {\r\n    use super::*;\r\n\r\n    /// Initialize the content registry\r\n    pub fn initialize(\r\n        ctx: Context\u003cInitialize\u003e,\r\n        identity_program: Pubkey,\r\n        staking_program: Pubkey,\r\n    ) -\u003e Result\u003c()\u003e {\r\n        admin::initialize::handler(ctx, identity_program, staking_program)\r\n    }\r\n    \r\n    /// Initialize energy system config\r\n    pub fn initialize_energy(ctx: Context\u003cInitializeEnergy\u003e) -\u003e Result\u003c()\u003e {\r\n        admin::initialize_energy::handler(ctx)\r\n    }\r\n    \r\n    /// Create content record\r\n    pub fn create_content(\r\n        ctx: Context\u003cCreateContent\u003e,\r\n        tracking_id: [u8; 32],\r\n        content_hash: [u8; 32],\r\n        content_uri: String,\r\n        content_type: u8,\r\n    ) -\u003e Result\u003c()\u003e {\r\n        content::create::handler(ctx, tracking_id, content_hash, content_uri, content_type)\r\n    }\r\n    \r\n    /// Edit content (update hash and URI)\r\n    pub fn edit_content(\r\n        ctx: Context\u003cEditContent\u003e,\r\n        new_content_hash: [u8; 32],\r\n        new_content_uri: String,\r\n    ) -\u003e Result\u003c()\u003e {\r\n        content::edit::handler(ctx, new_content_hash, new_content_uri)\r\n    }\r\n    \r\n    /// Soft delete content\r\n    pub fn delete_content(ctx: Context\u003cDeleteContent\u003e) -\u003e Result\u003c()\u003e {\r\n        content::delete::handler(ctx)\r\n    }\r\n    \r\n    /// Update engagement count (oracle/backend call)\r\n    pub fn update_engagement(\r\n        ctx: Context\u003cUpdateEngagement\u003e,\r\n        engagement_count: u32,\r\n    ) -\u003e Result\u003c()\u003e {\r\n        content::update_engagement::handler(ctx, engagement_count)\r\n    }\r\n    \r\n    /// Claim energy refund based on engagement\r\n    pub fn claim_energy_refund(ctx: Context\u003cClaimRefund\u003e) -\u003e Result\u003c()\u003e {\r\n        energy::claim_refund::handler(ctx)\r\n    }\r\n    \r\n    /// Initialize user energy account\r\n    pub fn initialize_user_energy(\r\n        ctx: Context\u003cInitializeUserEnergy\u003e,\r\n        tier: u8,\r\n    ) -\u003e Result\u003c()\u003e {\r\n        energy::initialize_user::handler(ctx, tier)\r\n    }\r\n    \r\n    /// Update user tier (from staking program)\r\n    pub fn update_user_tier(\r\n        ctx: Context\u003cUpdateUserTier\u003e,\r\n        new_tier: u8,\r\n    ) -\u003e Result\u003c()\u003e {\r\n        energy::update_tier::handler(ctx, new_tier)\r\n    }\r\n    \r\n    /// Pause/unpause registry\r\n    pub fn set_paused(ctx: Context\u003cUpdateConfig\u003e, paused: bool) -\u003e Result\u003c()\u003e {\r\n        admin::set_paused::handler(ctx, paused)\r\n    }\r\n    \r\n    /// Update authority\r\n    pub fn update_authority(ctx: Context\u003cUpdateAuthority\u003e, new_authority: Pubkey) -\u003e Result\u003c()\u003e {\r\n        admin::update_authority::handler(ctx, new_authority)\r\n    }\r\n    \r\n    /// Get content info\r\n    pub fn get_content(ctx: Context\u003cGetContent\u003e) -\u003e Result\u003c()\u003e {\r\n        query::get_content::handler(ctx)\r\n    }\r\n    \r\n    /// Get user energy stats\r\n    pub fn get_energy(ctx: Context\u003cGetEnergy\u003e) -\u003e Result\u003c()\u003e {\r\n        query::get_energy::handler(ctx)\r\n    }\r\n}\r\n","traces":[{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":98,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":112,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":0}},{"line":122,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":26},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","content-registry","src","state","config.rs"],"content":"use anchor_lang::prelude::*;\r\n\r\n/// Global registry configuration\r\n#[account]\r\n#[derive(Default)]\r\npub struct RegistryConfig {\r\n    /// Admin authority\r\n    pub authority: Pubkey,\r\n    /// Identity protocol for verification\r\n    pub identity_program: Pubkey,\r\n    /// Staking program for tier lookup\r\n    pub staking_program: Pubkey,\r\n    /// Total content count\r\n    pub total_content_count: u64,\r\n    /// Total active content\r\n    pub active_content_count: u64,\r\n    /// Whether registry is paused\r\n    pub paused: bool,\r\n    /// PDA bump\r\n    pub bump: u8,\r\n}\r\n\r\nimpl RegistryConfig {\r\n    pub const LEN: usize = 8 + // discriminator\r\n        32 + // authority\r\n        32 + // identity_program\r\n        32 + // staking_program\r\n        8 +  // total_content_count\r\n        8 +  // active_content_count\r\n        1 +  // paused\r\n        1;   // bump\r\n}\r\n\r\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","content-registry","src","state","content_record.rs"],"content":"use anchor_lang::prelude::*;\r\n\r\n/// Individual content record\r\n#[account]\r\npub struct ContentRecord {\r\n    /// Unique tracking ID (hash)\r\n    pub tracking_id: [u8; 32],\r\n    /// Content author\r\n    pub author: Pubkey,\r\n    /// SHA256 of current content\r\n    pub content_hash: [u8; 32],\r\n    /// IPFS/Arweave CID (max 128)\r\n    pub content_uri: [u8; 128],\r\n    /// URI length\r\n    pub uri_len: u8,\r\n    /// Content type\r\n    pub content_type: u8,\r\n    /// Current state\r\n    pub state: u8,\r\n    /// Version (edit count)\r\n    pub version: u16,\r\n    /// Original creation timestamp\r\n    pub created_at: i64,\r\n    /// Last state change\r\n    pub updated_at: i64,\r\n    /// Hash before last edit (for history)\r\n    pub previous_hash: [u8; 32],\r\n    /// Energy spent on creation\r\n    pub energy_spent: u16,\r\n    /// Whether energy refund was claimed\r\n    pub refund_claimed: bool,\r\n    /// Engagement count (likes) for refund calculation\r\n    pub engagement_count: u32,\r\n    /// PDA bump\r\n    pub bump: u8,\r\n}\r\n\r\nimpl Default for ContentRecord {\r\n    fn default() -\u003e Self {\r\n        Self {\r\n            tracking_id: [0u8; 32],\r\n            author: Pubkey::default(),\r\n            content_hash: [0u8; 32],\r\n            content_uri: [0u8; 128],\r\n            uri_len: 0,\r\n            content_type: 0,\r\n            state: 0,\r\n            version: 0,\r\n            created_at: 0,\r\n            updated_at: 0,\r\n            previous_hash: [0u8; 32],\r\n            energy_spent: 0,\r\n            refund_claimed: false,\r\n            engagement_count: 0,\r\n            bump: 0,\r\n        }\r\n    }\r\n}\r\n\r\nimpl ContentRecord {\r\n    pub const LEN: usize = 8 + // discriminator\r\n        32 + // tracking_id\r\n        32 + // author\r\n        32 + // content_hash\r\n        128 + // content_uri\r\n        1 +  // uri_len\r\n        1 +  // content_type\r\n        1 +  // state\r\n        2 +  // version\r\n        8 +  // created_at\r\n        8 +  // updated_at\r\n        32 + // previous_hash\r\n        2 +  // energy_spent\r\n        1 +  // refund_claimed\r\n        4 +  // engagement_count\r\n        1;   // bump\r\n}\r\n","traces":[{"line":39,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":41,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":42,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":43,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":44,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":51,"address":[],"length":0,"stats":{"Line":216172782113783808}}],"covered":6,"coverable":6},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","content-registry","src","state","content_state.rs"],"content":"use anchor_lang::prelude::*;\r\n\r\n/// Content state enum\r\n#[derive(AnchorSerialize, AnchorDeserialize, Clone, Copy, PartialEq, Eq, Default)]\r\npub enum ContentState {\r\n    #[default]\r\n    Active = 0,\r\n    Edited = 1,\r\n    Deleted = 2,\r\n    Archived = 3,\r\n}\r\n\r\nimpl ContentState {\r\n    pub fn from_u8(value: u8) -\u003e Option\u003cSelf\u003e {\r\n        match value {\r\n            0 =\u003e Some(ContentState::Active),\r\n            1 =\u003e Some(ContentState::Edited),\r\n            2 =\u003e Some(ContentState::Deleted),\r\n            3 =\u003e Some(ContentState::Archived),\r\n            _ =\u003e None,\r\n        }\r\n    }\r\n}\r\n","traces":[{"line":14,"address":[],"length":0,"stats":{"Line":0}},{"line":15,"address":[],"length":0,"stats":{"Line":0}},{"line":16,"address":[],"length":0,"stats":{"Line":0}},{"line":17,"address":[],"length":0,"stats":{"Line":0}},{"line":18,"address":[],"length":0,"stats":{"Line":0}},{"line":19,"address":[],"length":0,"stats":{"Line":0}},{"line":20,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":7},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","content-registry","src","state","content_type.rs"],"content":"use anchor_lang::prelude::*;\r\nuse crate::constants::*;\r\n\r\n/// Content type enum\r\n#[derive(AnchorSerialize, AnchorDeserialize, Clone, Copy, PartialEq, Eq, Default)]\r\npub enum ContentType {\r\n    #[default]\r\n    Post = 0,\r\n    Article = 1,\r\n    Media = 2,\r\n    NFT = 3,\r\n    Thread = 4,\r\n}\r\n\r\nimpl ContentType {\r\n    pub fn from_u8(value: u8) -\u003e Option\u003cSelf\u003e {\r\n        match value {\r\n            0 =\u003e Some(ContentType::Post),\r\n            1 =\u003e Some(ContentType::Article),\r\n            2 =\u003e Some(ContentType::Media),\r\n            3 =\u003e Some(ContentType::NFT),\r\n            4 =\u003e Some(ContentType::Thread),\r\n            _ =\u003e None,\r\n        }\r\n    }\r\n    \r\n    pub fn energy_cost(\u0026self) -\u003e u16 {\r\n        match self {\r\n            ContentType::Post =\u003e ENERGY_COST_TEXT_POST,\r\n            ContentType::Article =\u003e ENERGY_COST_IMAGE_POST, // Same as image\r\n            ContentType::Media =\u003e ENERGY_COST_VIDEO_POST,\r\n            ContentType::NFT =\u003e ENERGY_COST_IMAGE_POST,\r\n            ContentType::Thread =\u003e ENERGY_COST_THREAD,\r\n        }\r\n    }\r\n}\r\n","traces":[{"line":16,"address":[],"length":0,"stats":{"Line":0}},{"line":17,"address":[],"length":0,"stats":{"Line":0}},{"line":18,"address":[],"length":0,"stats":{"Line":0}},{"line":19,"address":[],"length":0,"stats":{"Line":0}},{"line":20,"address":[],"length":0,"stats":{"Line":0}},{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":15},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","content-registry","src","state","energy_config.rs"],"content":"use anchor_lang::prelude::*;\r\n\r\n/// Energy system configuration\r\n#[account]\r\n#[derive(Default)]\r\npub struct EnergyConfig {\r\n    /// Admin authority\r\n    pub authority: Pubkey,\r\n    /// Base regen rate per hour\r\n    pub base_regen_rate: u16,\r\n    /// Engagement check delay (seconds)\r\n    pub engagement_check_delay: i64,\r\n    /// Viral threshold (likes)\r\n    pub viral_threshold: u32,\r\n    /// Whether energy system is paused\r\n    pub paused: bool,\r\n    /// PDA bump\r\n    pub bump: u8,\r\n}\r\n\r\nimpl EnergyConfig {\r\n    pub const LEN: usize = 8 + // discriminator\r\n        32 + // authority\r\n        2 +  // base_regen_rate\r\n        8 +  // engagement_check_delay\r\n        4 +  // viral_threshold\r\n        1 +  // paused\r\n        1;   // bump\r\n}\r\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","content-registry","src","state","mod.rs"],"content":"pub mod content_type;\r\npub mod content_state;\r\npub mod registry_config;\r\npub mod energy_config;\r\npub mod content_record;\r\npub mod user_energy;\r\npub mod user_rate_limit;\r\n\r\npub use content_type::*;\r\npub use content_state::*;\r\npub use registry_config::*;\r\npub use energy_config::*;\r\npub use content_record::*;\r\npub use user_energy::*;\r\npub use user_rate_limit::*;\r\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","content-registry","src","state","registry_config.rs"],"content":"use anchor_lang::prelude::*;\r\n\r\n/// Global registry configuration\r\n#[account]\r\n#[derive(Default)]\r\npub struct RegistryConfig {\r\n    /// Admin authority\r\n    pub authority: Pubkey,\r\n    /// Identity protocol for verification\r\n    pub identity_program: Pubkey,\r\n    /// Staking program for tier lookup\r\n    pub staking_program: Pubkey,\r\n    /// Total content count\r\n    pub total_content_count: u64,\r\n    /// Total active content\r\n    pub active_content_count: u64,\r\n    /// Whether registry is paused\r\n    pub paused: bool,\r\n    /// PDA bump\r\n    pub bump: u8,\r\n}\r\n\r\nimpl RegistryConfig {\r\n    pub const LEN: usize = 8 + // discriminator\r\n        32 + // authority\r\n        32 + // identity_program\r\n        32 + // staking_program\r\n        8 +  // total_content_count\r\n        8 +  // active_content_count\r\n        1 +  // paused\r\n        1;   // bump\r\n}\r\n\r\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","content-registry","src","state","user_energy.rs"],"content":"use anchor_lang::prelude::*;\r\nuse crate::constants::*;\r\n\r\n/// User energy account\r\n#[account]\r\n#[derive(Default)]\r\npub struct UserEnergy {\r\n    /// User wallet\r\n    pub user: Pubkey,\r\n    /// Current energy (scales with tier)\r\n    pub current_energy: u16,\r\n    /// Max energy (tier-based)\r\n    pub max_energy: u16,\r\n    /// Last regeneration time\r\n    pub last_regen_time: i64,\r\n    /// Regen rate per hour\r\n    pub regen_rate: u16,\r\n    /// Energy spent today\r\n    pub energy_spent_today: u32,\r\n    /// Energy refunded today\r\n    pub energy_refunded_today: u32,\r\n    /// Last daily reset\r\n    pub last_reset: i64,\r\n    /// User's staking tier (0-4)\r\n    pub tier: u8,\r\n    /// PDA bump\r\n    pub bump: u8,\r\n}\r\n\r\nimpl UserEnergy {\r\n    pub const LEN: usize = 8 + // discriminator\r\n        32 + // user\r\n        2 +  // current_energy\r\n        2 +  // max_energy\r\n        8 +  // last_regen_time\r\n        2 +  // regen_rate\r\n        4 +  // energy_spent_today\r\n        4 +  // energy_refunded_today\r\n        8 +  // last_reset\r\n        1 +  // tier\r\n        1;   // bump\r\n    \r\n    pub fn max_energy_for_tier(tier: u8) -\u003e u16 {\r\n        match tier {\r\n            0 =\u003e MAX_ENERGY_NONE,\r\n            1 =\u003e MAX_ENERGY_BRONZE,\r\n            2 =\u003e MAX_ENERGY_SILVER,\r\n            3 =\u003e MAX_ENERGY_GOLD,\r\n            4 =\u003e MAX_ENERGY_PLATINUM,\r\n            _ =\u003e MAX_ENERGY_NONE,\r\n        }\r\n    }\r\n    \r\n    pub fn regen_rate_for_tier(tier: u8) -\u003e u16 {\r\n        match tier {\r\n            0 =\u003e REGEN_RATE_NONE,\r\n            1 =\u003e REGEN_RATE_BRONZE,\r\n            2 =\u003e REGEN_RATE_SILVER,\r\n            3 =\u003e REGEN_RATE_GOLD,\r\n            4 =\u003e REGEN_RATE_PLATINUM,\r\n            _ =\u003e REGEN_RATE_NONE,\r\n        }\r\n    }\r\n}\r\n","traces":[{"line":43,"address":[],"length":0,"stats":{"Line":1080863910568919040}},{"line":44,"address":[],"length":0,"stats":{"Line":1080863910568919040}},{"line":45,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":46,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":47,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":48,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":49,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":50,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":54,"address":[],"length":0,"stats":{"Line":1008806316530991104}},{"line":55,"address":[],"length":0,"stats":{"Line":1008806316530991104}},{"line":56,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":57,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":58,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":59,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":60,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":61,"address":[],"length":0,"stats":{"Line":72057594037927936}}],"covered":16,"coverable":16},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","content-registry","src","state","user_rate_limit.rs"],"content":"use anchor_lang::prelude::*;\r\n\r\n/// Rate limit account per user\r\n#[account]\r\n#[derive(Default)]\r\npub struct UserRateLimit {\r\n    /// User wallet\r\n    pub user: Pubkey,\r\n    /// Posts today\r\n    pub posts_today: u16,\r\n    /// Edits this hour\r\n    pub edits_this_hour: u8,\r\n    /// Last post time\r\n    pub last_post_time: i64,\r\n    /// Day reset time\r\n    pub day_reset_time: i64,\r\n    /// Hour reset time\r\n    pub hour_reset_time: i64,\r\n    /// PDA bump\r\n    pub bump: u8,\r\n}\r\n\r\nimpl UserRateLimit {\r\n    pub const LEN: usize = 8 + // discriminator\r\n        32 + // user\r\n        2 +  // posts_today\r\n        1 +  // edits_this_hour\r\n        8 +  // last_post_time\r\n        8 +  // day_reset_time\r\n        8 +  // hour_reset_time\r\n        1;   // bump\r\n    \r\n    /// Get daily cap based on tier\r\n    pub fn daily_cap_for_tier(tier: u8) -\u003e u16 {\r\n        match tier {\r\n            0 =\u003e 50,\r\n            1 =\u003e 100,\r\n            2 =\u003e 200,\r\n            3 =\u003e 400,\r\n            4 =\u003e 1000,\r\n            _ =\u003e 50,\r\n        }\r\n    }\r\n}\r\n","traces":[{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":8},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","content-registry","src","tests.rs"],"content":"//! Unit tests for Content Registry\r\n//!\r\n//! These tests run against the ACTUAL program code.\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n    use crate::constants::*;\r\n    use crate::state::{ContentRecord, UserEnergy};\r\n    use anchor_lang::prelude::Pubkey;\r\n\r\n    // ========================================================================\r\n    // Constants Tests\r\n    // ========================================================================\r\n\r\n    #[test]\r\n    fn test_pda_seeds() {\r\n        assert_eq!(REGISTRY_CONFIG_SEED, b\"registry-config\");\r\n        assert_eq!(CONTENT_RECORD_SEED, b\"content-record\");\r\n        assert_eq!(USER_ENERGY_SEED, b\"user-energy\");\r\n        assert_eq!(RATE_LIMIT_SEED, b\"rate-limit\");\r\n        assert_eq!(ENERGY_CONFIG_SEED, b\"energy-config\");\r\n    }\r\n\r\n    #[test]\r\n    fn test_energy_costs() {\r\n        assert_eq!(ENERGY_COST_TEXT_POST, 10);\r\n        assert_eq!(ENERGY_COST_IMAGE_POST, 20);\r\n        assert_eq!(ENERGY_COST_VIDEO_POST, 50);\r\n        assert_eq!(ENERGY_COST_THREAD, 40);\r\n        assert_eq!(ENERGY_COST_REPLY, 5);\r\n        assert_eq!(ENERGY_COST_REPOST, 8);\r\n        assert_eq!(ENERGY_COST_EDIT_AFTER_1H, 5);\r\n    }\r\n\r\n    #[test]\r\n    fn test_regen_rates() {\r\n        assert_eq!(REGEN_RATE_NONE, 20);\r\n        assert_eq!(REGEN_RATE_BRONZE, 50);\r\n        assert_eq!(REGEN_RATE_SILVER, 80);\r\n        assert_eq!(REGEN_RATE_GOLD, 120);\r\n        assert_eq!(REGEN_RATE_PLATINUM, 200);\r\n    }\r\n\r\n    #[test]\r\n    fn test_max_energy_by_tier() {\r\n        assert_eq!(MAX_ENERGY_NONE, 200);\r\n        assert_eq!(MAX_ENERGY_BRONZE, 500);\r\n        assert_eq!(MAX_ENERGY_SILVER, 800);\r\n        assert_eq!(MAX_ENERGY_GOLD, 1200);\r\n        assert_eq!(MAX_ENERGY_PLATINUM, 2000);\r\n    }\r\n\r\n    #[test]\r\n    fn test_refund_thresholds() {\r\n        assert_eq!(REFUND_THRESHOLD_10, 10);\r\n        assert_eq!(REFUND_THRESHOLD_50, 50);\r\n        assert_eq!(REFUND_THRESHOLD_100, 100);\r\n        assert_eq!(REFUND_THRESHOLD_1000, 1000);\r\n    }\r\n\r\n    #[test]\r\n    fn test_timing_constants() {\r\n        assert_eq!(ENGAGEMENT_CHECK_DELAY, 24 * 60 * 60, \"24 hours\");\r\n        assert_eq!(FREE_EDIT_WINDOW, 60 * 60, \"1 hour\");\r\n    }\r\n\r\n    // ========================================================================\r\n    // State Size Tests\r\n    // ========================================================================\r\n\r\n    #[test]\r\n    fn test_content_record_size() {\r\n        let expected = 8 + 32 + 32 + 32 + 128 + 1 + 1 + 1 + 2 + 8 + 8 + 32 + 2 + 1 + 4 + 1;\r\n        assert_eq!(ContentRecord::LEN, expected, \"ContentRecord size mismatch\");\r\n    }\r\n\r\n    #[test]\r\n    fn test_user_energy_size() {\r\n        let expected = 8 + 32 + 2 + 2 + 8 + 2 + 4 + 4 + 8 + 1 + 1;\r\n        assert_eq!(UserEnergy::LEN, expected, \"UserEnergy size mismatch\");\r\n    }\r\n\r\n    // ========================================================================\r\n    // UserEnergy Tier Tests\r\n    // ========================================================================\r\n\r\n    #[test]\r\n    fn test_max_energy_for_tier() {\r\n        assert_eq!(UserEnergy::max_energy_for_tier(0), MAX_ENERGY_NONE);\r\n        assert_eq!(UserEnergy::max_energy_for_tier(1), MAX_ENERGY_BRONZE);\r\n        assert_eq!(UserEnergy::max_energy_for_tier(2), MAX_ENERGY_SILVER);\r\n        assert_eq!(UserEnergy::max_energy_for_tier(3), MAX_ENERGY_GOLD);\r\n        assert_eq!(UserEnergy::max_energy_for_tier(4), MAX_ENERGY_PLATINUM);\r\n        assert_eq!(UserEnergy::max_energy_for_tier(5), MAX_ENERGY_NONE); // Invalid\r\n    }\r\n\r\n    #[test]\r\n    fn test_regen_rate_for_tier() {\r\n        assert_eq!(UserEnergy::regen_rate_for_tier(0), REGEN_RATE_NONE);\r\n        assert_eq!(UserEnergy::regen_rate_for_tier(1), REGEN_RATE_BRONZE);\r\n        assert_eq!(UserEnergy::regen_rate_for_tier(2), REGEN_RATE_SILVER);\r\n        assert_eq!(UserEnergy::regen_rate_for_tier(3), REGEN_RATE_GOLD);\r\n        assert_eq!(UserEnergy::regen_rate_for_tier(4), REGEN_RATE_PLATINUM);\r\n        assert_eq!(UserEnergy::regen_rate_for_tier(5), REGEN_RATE_NONE);\r\n    }\r\n\r\n    #[test]\r\n    fn test_tier_progression() {\r\n        // Higher tiers should have better stats\r\n        for tier in 0..4u8 {\r\n            let current_max = UserEnergy::max_energy_for_tier(tier);\r\n            let next_max = UserEnergy::max_energy_for_tier(tier + 1);\r\n            assert!(next_max \u003e current_max, \"Max energy should increase with tier\");\r\n            \r\n            let current_regen = UserEnergy::regen_rate_for_tier(tier);\r\n            let next_regen = UserEnergy::regen_rate_for_tier(tier + 1);\r\n            assert!(next_regen \u003e current_regen, \"Regen rate should increase with tier\");\r\n        }\r\n    }\r\n\r\n    // ========================================================================\r\n    // Energy Regeneration Tests\r\n    // ========================================================================\r\n\r\n    #[test]\r\n    fn test_energy_regen_calculation() {\r\n        let regen_rate = REGEN_RATE_BRONZE; // 50 per hour\r\n        let hours_passed = 2;\r\n        let regen_amount = (regen_rate as u32) * hours_passed;\r\n        \r\n        assert_eq!(regen_amount, 100, \"Should regen 100 energy in 2 hours\");\r\n    }\r\n\r\n    #[test]\r\n    fn test_energy_cap() {\r\n        let mut energy = UserEnergy::default();\r\n        energy.tier = 2; // Silver\r\n        energy.max_energy = UserEnergy::max_energy_for_tier(2);\r\n        energy.current_energy = 700;\r\n        \r\n        // Simulate regen that would exceed max\r\n        let regen_amount = 200u16;\r\n        let new_energy = energy.current_energy.saturating_add(regen_amount);\r\n        let capped_energy = new_energy.min(energy.max_energy);\r\n        \r\n        assert_eq!(capped_energy, MAX_ENERGY_SILVER, \"Energy should cap at max\");\r\n    }\r\n\r\n    // ========================================================================\r\n    // Energy Cost Tests\r\n    // ========================================================================\r\n\r\n    #[test]\r\n    fn test_can_post_with_energy() {\r\n        let energy = UserEnergy {\r\n            current_energy: 100,\r\n            ..Default::default()\r\n        };\r\n        \r\n        assert!(energy.current_energy \u003e= ENERGY_COST_TEXT_POST);\r\n        assert!(energy.current_energy \u003e= ENERGY_COST_IMAGE_POST);\r\n        assert!(energy.current_energy \u003e= ENERGY_COST_VIDEO_POST);\r\n    }\r\n\r\n    #[test]\r\n    fn test_insufficient_energy() {\r\n        let energy = UserEnergy {\r\n            current_energy: 5,\r\n            ..Default::default()\r\n        };\r\n        \r\n        // Can only post replies with this energy\r\n        assert!(energy.current_energy \u003e= ENERGY_COST_REPLY);\r\n        assert!(energy.current_energy \u003c ENERGY_COST_TEXT_POST);\r\n    }\r\n\r\n    // ========================================================================\r\n    // Content Record Tests\r\n    // ========================================================================\r\n\r\n    #[test]\r\n    fn test_content_record_default() {\r\n        let record = ContentRecord::default();\r\n        \r\n        assert_eq!(record.version, 0);\r\n        assert_eq!(record.state, 0);\r\n        assert!(!record.refund_claimed);\r\n        assert_eq!(record.engagement_count, 0);\r\n    }\r\n\r\n    #[test]\r\n    fn test_content_edit_increments_version() {\r\n        let mut record = ContentRecord::default();\r\n        \r\n        record.version = record.version.saturating_add(1);\r\n        assert_eq!(record.version, 1);\r\n        \r\n        record.version = record.version.saturating_add(1);\r\n        assert_eq!(record.version, 2);\r\n    }\r\n\r\n    // ========================================================================\r\n    // Refund Calculation Tests\r\n    // ========================================================================\r\n\r\n    #[test]\r\n    fn test_refund_tier_10_likes() {\r\n        let engagement = 15u32;\r\n        let energy_spent = 20u16;\r\n        \r\n        // 10-49 likes = 25% refund\r\n        assert!(engagement \u003e= REFUND_THRESHOLD_10);\r\n        assert!(engagement \u003c REFUND_THRESHOLD_50);\r\n        \r\n        let refund = (energy_spent as u32 * 25) / 100;\r\n        assert_eq!(refund, 5);\r\n    }\r\n\r\n    #[test]\r\n    fn test_refund_tier_50_likes() {\r\n        let engagement = 75u32;\r\n        let energy_spent = 20u16;\r\n        \r\n        // 50-99 likes = 50% refund\r\n        assert!(engagement \u003e= REFUND_THRESHOLD_50);\r\n        assert!(engagement \u003c REFUND_THRESHOLD_100);\r\n        \r\n        let refund = (energy_spent as u32 * 50) / 100;\r\n        assert_eq!(refund, 10);\r\n    }\r\n\r\n    #[test]\r\n    fn test_refund_tier_viral() {\r\n        let engagement = 2000u32;\r\n        let energy_spent = 20u16;\r\n        \r\n        // 1000+ likes = 150% refund\r\n        assert!(engagement \u003e= REFUND_THRESHOLD_1000);\r\n        \r\n        let refund = (energy_spent as u32 * 150) / 100;\r\n        assert_eq!(refund, 30);\r\n    }\r\n\r\n    // ========================================================================\r\n    // PDA Derivation Tests\r\n    // ========================================================================\r\n\r\n    #[test]\r\n    fn test_content_pda_unique() {\r\n        let program_id = Pubkey::new_unique();\r\n        let tracking_id_1 = [1u8; 32];\r\n        let tracking_id_2 = [2u8; 32];\r\n        \r\n        let (pda1, _) = Pubkey::find_program_address(\r\n            \u0026[CONTENT_RECORD_SEED, \u0026tracking_id_1],\r\n            \u0026program_id\r\n        );\r\n        \r\n        let (pda2, _) = Pubkey::find_program_address(\r\n            \u0026[CONTENT_RECORD_SEED, \u0026tracking_id_2],\r\n            \u0026program_id\r\n        );\r\n        \r\n        assert_ne!(pda1, pda2, \"Different tracking IDs should have different PDAs\");\r\n    }\r\n\r\n    #[test]\r\n    fn test_user_energy_pda_unique() {\r\n        let program_id = Pubkey::new_unique();\r\n        let user1 = Pubkey::new_unique();\r\n        let user2 = Pubkey::new_unique();\r\n        \r\n        let (pda1, _) = Pubkey::find_program_address(\r\n            \u0026[USER_ENERGY_SEED, user1.as_ref()],\r\n            \u0026program_id\r\n        );\r\n        \r\n        let (pda2, _) = Pubkey::find_program_address(\r\n            \u0026[USER_ENERGY_SEED, user2.as_ref()],\r\n            \u0026program_id\r\n        );\r\n        \r\n        assert_ne!(pda1, pda2);\r\n    }\r\n\r\n    // ========================================================================\r\n    // Invariant Tests\r\n    // ========================================================================\r\n\r\n    #[test]\r\n    fn test_invariant_energy_bounded() {\r\n        let mut energy = UserEnergy::default();\r\n        energy.tier = 4; // Platinum\r\n        energy.max_energy = MAX_ENERGY_PLATINUM;\r\n        energy.current_energy = MAX_ENERGY_PLATINUM;\r\n        \r\n        // Energy should never exceed max\r\n        assert!(energy.current_energy \u003c= energy.max_energy);\r\n    }\r\n\r\n    #[test]\r\n    fn test_invariant_version_monotonic() {\r\n        let mut record = ContentRecord::default();\r\n        \r\n        for expected in 1..=10u16 {\r\n            record.version = record.version.saturating_add(1);\r\n            assert_eq!(record.version, expected);\r\n        }\r\n    }\r\n}\r\n\r\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","content-registry","src","utils.rs"],"content":"use anchor_lang::prelude::*;\r\nuse crate::errors::ContentError;\r\nuse crate::state::{UserEnergy, UserRateLimit};\r\n\r\n/// Regenerate user energy based on elapsed time\r\npub fn regenerate_energy(energy: \u0026mut UserEnergy, current_time: i64) -\u003e Result\u003c()\u003e {\r\n    let elapsed_seconds = current_time - energy.last_regen_time;\r\n    if elapsed_seconds \u003e 0 {\r\n        let hours_elapsed = elapsed_seconds as f64 / 3600.0;\r\n        let regen_amount = (hours_elapsed * energy.regen_rate as f64) as u16;\r\n        \r\n        energy.current_energy = energy.current_energy\r\n            .saturating_add(regen_amount)\r\n            .min(energy.max_energy);\r\n        energy.last_regen_time = current_time;\r\n    }\r\n    \r\n    // Reset daily counters if new day\r\n    if current_time \u003e= energy.last_reset + 86400 {\r\n        energy.energy_spent_today = 0;\r\n        energy.energy_refunded_today = 0;\r\n        energy.last_reset = current_time;\r\n    }\r\n    \r\n    Ok(())\r\n}\r\n\r\n/// Check and update rate limit for user\r\npub fn check_and_update_rate_limit(\r\n    rate_limit: \u0026mut UserRateLimit,\r\n    tier: u8,\r\n    current_time: i64,\r\n) -\u003e Result\u003c()\u003e {\r\n    // Reset daily counter if new day\r\n    if current_time \u003e= rate_limit.day_reset_time + 86400 {\r\n        rate_limit.posts_today = 0;\r\n        rate_limit.day_reset_time = current_time;\r\n    }\r\n    \r\n    // Reset hourly counter if new hour\r\n    if current_time \u003e= rate_limit.hour_reset_time + 3600 {\r\n        rate_limit.edits_this_hour = 0;\r\n        rate_limit.hour_reset_time = current_time;\r\n    }\r\n    \r\n    // Check daily cap\r\n    let daily_cap = UserRateLimit::daily_cap_for_tier(tier);\r\n    require!(\r\n        rate_limit.posts_today \u003c daily_cap,\r\n        ContentError::DailyCapExceeded\r\n    );\r\n    \r\n    rate_limit.posts_today += 1;\r\n    rate_limit.last_post_time = current_time;\r\n    \r\n    Ok(())\r\n}\r\n\r\n","traces":[{"line":6,"address":[],"length":0,"stats":{"Line":0}},{"line":7,"address":[],"length":0,"stats":{"Line":0}},{"line":8,"address":[],"length":0,"stats":{"Line":0}},{"line":9,"address":[],"length":0,"stats":{"Line":0}},{"line":10,"address":[],"length":0,"stats":{"Line":0}},{"line":12,"address":[],"length":0,"stats":{"Line":0}},{"line":13,"address":[],"length":0,"stats":{"Line":0}},{"line":14,"address":[],"length":0,"stats":{"Line":0}},{"line":15,"address":[],"length":0,"stats":{"Line":0}},{"line":19,"address":[],"length":0,"stats":{"Line":0}},{"line":20,"address":[],"length":0,"stats":{"Line":0}},{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":28},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","content-registry","tests","admin.rs"],"content":"//! Integration tests for content-registry admin instructions\r\n\r\nmod common;\r\n\r\nuse common::*;\r\nuse solana_sdk::signature::{Keypair, Signer};\r\n\r\n#[tokio::test]\r\nasync fn test_set_paused_true() {\r\n    let mut ctx = TestContext::new().await;\r\n    \r\n    let (config_pda, _bump) = ctx.get_config_pda();\r\n    let identity_program = Keypair::new();\r\n    let staking_program = Keypair::new();\r\n    \r\n    let init_ix = create_initialize_ix(\r\n        \u0026ctx.program_id,\r\n        \u0026ctx.payer.pubkey(),\r\n        \u0026config_pda,\r\n        \u0026identity_program.pubkey(),\r\n        \u0026staking_program.pubkey(),\r\n    );\r\n    \r\n    ctx.process_transaction(\u0026[init_ix], \u0026[]).await.unwrap();\r\n    \r\n    let pause_ix = create_set_paused_ix(\r\n        \u0026ctx.program_id,\r\n        \u0026ctx.payer.pubkey(),\r\n        \u0026config_pda,\r\n        true,\r\n    );\r\n    \r\n    let result = ctx.process_transaction(\u0026[pause_ix], \u0026[]).await;\r\n    assert!(result.is_ok());\r\n}\r\n\r\n#[tokio::test]\r\nasync fn test_set_paused_false() {\r\n    let mut ctx = TestContext::new().await;\r\n    \r\n    let (config_pda, _bump) = ctx.get_config_pda();\r\n    let identity_program = Keypair::new();\r\n    let staking_program = Keypair::new();\r\n    \r\n    let init_ix = create_initialize_ix(\r\n        \u0026ctx.program_id,\r\n        \u0026ctx.payer.pubkey(),\r\n        \u0026config_pda,\r\n        \u0026identity_program.pubkey(),\r\n        \u0026staking_program.pubkey(),\r\n    );\r\n    \r\n    ctx.process_transaction(\u0026[init_ix], \u0026[]).await.unwrap();\r\n    \r\n    let pause_ix = create_set_paused_ix(\u0026ctx.program_id, \u0026ctx.payer.pubkey(), \u0026config_pda, true);\r\n    ctx.process_transaction(\u0026[pause_ix], \u0026[]).await.unwrap();\r\n    \r\n    let unpause_ix = create_set_paused_ix(\u0026ctx.program_id, \u0026ctx.payer.pubkey(), \u0026config_pda, false);\r\n    let result = ctx.process_transaction(\u0026[unpause_ix], \u0026[]).await;\r\n    assert!(result.is_ok());\r\n}\r\n\r\n#[tokio::test]\r\nasync fn test_set_paused_unauthorized() {\r\n    let mut ctx = TestContext::new().await;\r\n    \r\n    let (config_pda, _bump) = ctx.get_config_pda();\r\n    let identity_program = Keypair::new();\r\n    let staking_program = Keypair::new();\r\n    \r\n    let init_ix = create_initialize_ix(\r\n        \u0026ctx.program_id,\r\n        \u0026ctx.payer.pubkey(),\r\n        \u0026config_pda,\r\n        \u0026identity_program.pubkey(),\r\n        \u0026staking_program.pubkey(),\r\n    );\r\n    \r\n    ctx.process_transaction(\u0026[init_ix], \u0026[]).await.unwrap();\r\n    \r\n    let unauthorized = Keypair::new();\r\n    let pause_ix = create_set_paused_ix(\r\n        \u0026ctx.program_id,\r\n        \u0026unauthorized.pubkey(),\r\n        \u0026config_pda,\r\n        true,\r\n    );\r\n    \r\n    assert_eq!(pause_ix.accounts[0].pubkey, unauthorized.pubkey());\r\n}\r\n\r\n#[tokio::test]\r\nasync fn test_set_paused_toggle() {\r\n    let mut ctx = TestContext::new().await;\r\n    \r\n    let (config_pda, _bump) = ctx.get_config_pda();\r\n    let identity_program = Keypair::new();\r\n    let staking_program = Keypair::new();\r\n    \r\n    let init_ix = create_initialize_ix(\r\n        \u0026ctx.program_id,\r\n        \u0026ctx.payer.pubkey(),\r\n        \u0026config_pda,\r\n        \u0026identity_program.pubkey(),\r\n        \u0026staking_program.pubkey(),\r\n    );\r\n    \r\n    ctx.process_transaction(\u0026[init_ix], \u0026[]).await.unwrap();\r\n    \r\n    for paused in [true, false, true, false] {\r\n        let ix = create_set_paused_ix(\u0026ctx.program_id, \u0026ctx.payer.pubkey(), \u0026config_pda, paused);\r\n        let result = ctx.process_transaction(\u0026[ix], \u0026[]).await;\r\n        assert!(result.is_ok());\r\n    }\r\n}\r\n\r\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","content-registry","tests","common","mod.rs"],"content":"//! Common test utilities for content-registry integration tests\r\n\r\nuse anchor_lang::prelude::*;\r\nuse solana_program_test::*;\r\nuse solana_sdk::{\r\n    account::Account,\r\n    hash::Hash,\r\n    instruction::{AccountMeta, Instruction},\r\n    pubkey::Pubkey,\r\n    signature::{Keypair, Signer},\r\n    transaction::Transaction,\r\n};\r\n\r\npub const REGISTRY_CONFIG_SEED: \u0026[u8] = b\"registry-config\";\r\npub const CONTENT_RECORD_SEED: \u0026[u8] = b\"content-record\";\r\npub const USER_ENERGY_SEED: \u0026[u8] = b\"user-energy\";\r\npub const ENERGY_CONFIG_SEED: \u0026[u8] = b\"energy-config\";\r\n\r\npub struct TestContext {\r\n    pub banks_client: BanksClient,\r\n    pub payer: Keypair,\r\n    pub recent_blockhash: Hash,\r\n    pub program_id: Pubkey,\r\n}\r\n\r\nimpl TestContext {\r\n    pub async fn new() -\u003e Self {\r\n        let program_id = content_registry::id();\r\n        let program_test = ProgramTest::new(\r\n            \"content_registry\",\r\n            program_id,\r\n            processor!(content_registry::entry),\r\n        );\r\n\r\n        let (banks_client, payer, recent_blockhash) = program_test.start().await;\r\n\r\n        Self {\r\n            banks_client,\r\n            payer,\r\n            recent_blockhash,\r\n            program_id,\r\n        }\r\n    }\r\n\r\n    pub async fn refresh_blockhash(\u0026mut self) {\r\n        self.recent_blockhash = self.banks_client.get_latest_blockhash().await.unwrap();\r\n    }\r\n\r\n    pub async fn get_account(\u0026mut self, pubkey: Pubkey) -\u003e Option\u003cAccount\u003e {\r\n        self.banks_client.get_account(pubkey).await.unwrap()\r\n    }\r\n\r\n    pub fn get_config_pda(\u0026self) -\u003e (Pubkey, u8) {\r\n        Pubkey::find_program_address(\u0026[REGISTRY_CONFIG_SEED], \u0026self.program_id)\r\n    }\r\n\r\n    pub fn get_content_pda(\u0026self, tracking_id: \u0026[u8; 32]) -\u003e (Pubkey, u8) {\r\n        Pubkey::find_program_address(\u0026[CONTENT_RECORD_SEED, tracking_id], \u0026self.program_id)\r\n    }\r\n\r\n    pub fn get_user_energy_pda(\u0026self, user: \u0026Pubkey) -\u003e (Pubkey, u8) {\r\n        Pubkey::find_program_address(\u0026[USER_ENERGY_SEED, user.as_ref()], \u0026self.program_id)\r\n    }\r\n\r\n    pub async fn process_transaction(\r\n        \u0026mut self,\r\n        instructions: \u0026[Instruction],\r\n        signers: \u0026[\u0026Keypair],\r\n    ) -\u003e Result\u003c(), BanksClientError\u003e {\r\n        let mut all_signers = vec![\u0026self.payer];\r\n        all_signers.extend(signers);\r\n        \r\n        let tx = Transaction::new_signed_with_payer(\r\n            instructions,\r\n            Some(\u0026self.payer.pubkey()),\r\n            \u0026all_signers,\r\n            self.recent_blockhash,\r\n        );\r\n        \r\n        let result = self.banks_client.process_transaction(tx).await;\r\n        self.refresh_blockhash().await;\r\n        result\r\n    }\r\n}\r\n\r\npub fn create_initialize_ix(\r\n    program_id: \u0026Pubkey,\r\n    authority: \u0026Pubkey,\r\n    config: \u0026Pubkey,\r\n    identity_program: \u0026Pubkey,\r\n    staking_program: \u0026Pubkey,\r\n) -\u003e Instruction {\r\n    let mut data = vec![0u8; 8 + 32 + 32];\r\n    let discriminator = anchor_lang::solana_program::hash::hash(b\"global:initialize\").to_bytes();\r\n    data[..8].copy_from_slice(\u0026discriminator[..8]);\r\n    data[8..40].copy_from_slice(identity_program.as_ref());\r\n    data[40..72].copy_from_slice(staking_program.as_ref());\r\n\r\n    Instruction {\r\n        program_id: *program_id,\r\n        accounts: vec![\r\n            AccountMeta::new(*authority, true),\r\n            AccountMeta::new(*config, false),\r\n            AccountMeta::new_readonly(solana_sdk::system_program::id(), false),\r\n        ],\r\n        data,\r\n    }\r\n}\r\n\r\npub fn create_content_ix(\r\n    program_id: \u0026Pubkey,\r\n    creator: \u0026Pubkey,\r\n    content: \u0026Pubkey,\r\n    config: \u0026Pubkey,\r\n    tracking_id: [u8; 32],\r\n    content_hash: [u8; 32],\r\n    content_uri: \u0026str,\r\n    content_type: u8,\r\n) -\u003e Instruction {\r\n    let uri_bytes = content_uri.as_bytes();\r\n    let mut data = vec![0u8; 8 + 32 + 32 + 4 + uri_bytes.len() + 1];\r\n    let discriminator = anchor_lang::solana_program::hash::hash(b\"global:create_content\").to_bytes();\r\n    data[..8].copy_from_slice(\u0026discriminator[..8]);\r\n    data[8..40].copy_from_slice(\u0026tracking_id);\r\n    data[40..72].copy_from_slice(\u0026content_hash);\r\n    data[72..76].copy_from_slice(\u0026(uri_bytes.len() as u32).to_le_bytes());\r\n    data[76..76 + uri_bytes.len()].copy_from_slice(uri_bytes);\r\n    data[76 + uri_bytes.len()] = content_type;\r\n\r\n    Instruction {\r\n        program_id: *program_id,\r\n        accounts: vec![\r\n            AccountMeta::new(*creator, true),\r\n            AccountMeta::new(*content, false),\r\n            AccountMeta::new_readonly(*config, false),\r\n            AccountMeta::new_readonly(solana_sdk::system_program::id(), false),\r\n        ],\r\n        data,\r\n    }\r\n}\r\n\r\npub fn create_delete_content_ix(\r\n    program_id: \u0026Pubkey,\r\n    creator: \u0026Pubkey,\r\n    content: \u0026Pubkey,\r\n    config: \u0026Pubkey,\r\n) -\u003e Instruction {\r\n    let mut data = vec![0u8; 8];\r\n    let discriminator = anchor_lang::solana_program::hash::hash(b\"global:delete_content\").to_bytes();\r\n    data[..8].copy_from_slice(\u0026discriminator[..8]);\r\n\r\n    Instruction {\r\n        program_id: *program_id,\r\n        accounts: vec![\r\n            AccountMeta::new(*creator, true),\r\n            AccountMeta::new(*content, false),\r\n            AccountMeta::new_readonly(*config, false),\r\n        ],\r\n        data,\r\n    }\r\n}\r\n\r\npub fn create_set_paused_ix(\r\n    program_id: \u0026Pubkey,\r\n    authority: \u0026Pubkey,\r\n    config: \u0026Pubkey,\r\n    paused: bool,\r\n) -\u003e Instruction {\r\n    let mut data = vec![0u8; 8 + 1];\r\n    let discriminator = anchor_lang::solana_program::hash::hash(b\"global:set_paused\").to_bytes();\r\n    data[..8].copy_from_slice(\u0026discriminator[..8]);\r\n    data[8] = if paused { 1 } else { 0 };\r\n\r\n    Instruction {\r\n        program_id: *program_id,\r\n        accounts: vec![\r\n            AccountMeta::new(*authority, true),\r\n            AccountMeta::new(*config, false),\r\n        ],\r\n        data,\r\n    }\r\n}\r\n\r\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","content-registry","tests","content.rs"],"content":"//! Integration tests for content-registry content instructions\r\n\r\nmod common;\r\n\r\nuse common::*;\r\nuse solana_sdk::signature::{Keypair, Signer};\r\n\r\n#[tokio::test]\r\nasync fn test_create_content_instruction_format() {\r\n    let ctx = TestContext::new().await;\r\n    \r\n    let (config_pda, _bump) = ctx.get_config_pda();\r\n    let creator = Keypair::new();\r\n    let tracking_id = [1u8; 32];\r\n    let (content_pda, _) = ctx.get_content_pda(\u0026tracking_id);\r\n    let content_hash = [2u8; 32];\r\n    \r\n    let ix = create_content_ix(\r\n        \u0026ctx.program_id,\r\n        \u0026creator.pubkey(),\r\n        \u0026content_pda,\r\n        \u0026config_pda,\r\n        tracking_id,\r\n        content_hash,\r\n        \"ipfs://Qm...\",\r\n        0, // post\r\n    );\r\n    \r\n    assert_eq!(ix.program_id, ctx.program_id);\r\n    assert_eq!(ix.accounts.len(), 4);\r\n    assert!(ix.accounts[0].is_signer);\r\n}\r\n\r\n#[tokio::test]\r\nasync fn test_create_content_different_types() {\r\n    let ctx = TestContext::new().await;\r\n    \r\n    let (config_pda, _bump) = ctx.get_config_pda();\r\n    let creator = Keypair::new();\r\n    \r\n    for content_type in 0..=4 {\r\n        let mut tracking_id = [0u8; 32];\r\n        tracking_id[0] = content_type;\r\n        let (content_pda, _) = ctx.get_content_pda(\u0026tracking_id);\r\n        let content_hash = [content_type; 32];\r\n        \r\n        let ix = create_content_ix(\r\n            \u0026ctx.program_id,\r\n            \u0026creator.pubkey(),\r\n            \u0026content_pda,\r\n            \u0026config_pda,\r\n            tracking_id,\r\n            content_hash,\r\n            \u0026format!(\"ipfs://content{}\", content_type),\r\n            content_type,\r\n        );\r\n        \r\n        let last_byte = ix.data.last().unwrap();\r\n        assert_eq!(*last_byte, content_type);\r\n    }\r\n}\r\n\r\n#[tokio::test]\r\nasync fn test_create_content_short_uri() {\r\n    let ctx = TestContext::new().await;\r\n    \r\n    let (config_pda, _bump) = ctx.get_config_pda();\r\n    let creator = Keypair::new();\r\n    let tracking_id = [3u8; 32];\r\n    let (content_pda, _) = ctx.get_content_pda(\u0026tracking_id);\r\n    let content_hash = [4u8; 32];\r\n    \r\n    let ix = create_content_ix(\r\n        \u0026ctx.program_id,\r\n        \u0026creator.pubkey(),\r\n        \u0026content_pda,\r\n        \u0026config_pda,\r\n        tracking_id,\r\n        content_hash,\r\n        \"a\",\r\n        0,\r\n    );\r\n    \r\n    assert!(ix.data.len() \u003e 8 + 64);\r\n}\r\n\r\n#[tokio::test]\r\nasync fn test_create_content_long_uri() {\r\n    let ctx = TestContext::new().await;\r\n    \r\n    let (config_pda, _bump) = ctx.get_config_pda();\r\n    let creator = Keypair::new();\r\n    let tracking_id = [5u8; 32];\r\n    let (content_pda, _) = ctx.get_content_pda(\u0026tracking_id);\r\n    let content_hash = [6u8; 32];\r\n    let long_uri = \"ipfs://QmVeryLongContentHashThatIsQuiteVeryLongIndeed\";\r\n    \r\n    let ix = create_content_ix(\r\n        \u0026ctx.program_id,\r\n        \u0026creator.pubkey(),\r\n        \u0026content_pda,\r\n        \u0026config_pda,\r\n        tracking_id,\r\n        content_hash,\r\n        long_uri,\r\n        0,\r\n    );\r\n    \r\n    assert!(ix.data.len() \u003e 8 + 64 + 4);\r\n}\r\n\r\n#[tokio::test]\r\nasync fn test_create_content_multiple_creators() {\r\n    let ctx = TestContext::new().await;\r\n    \r\n    let (config_pda, _bump) = ctx.get_config_pda();\r\n    \r\n    for i in 0..5 {\r\n        let creator = Keypair::new();\r\n        let mut tracking_id = [0u8; 32];\r\n        tracking_id[0] = i;\r\n        let (content_pda, _) = ctx.get_content_pda(\u0026tracking_id);\r\n        let content_hash = [i; 32];\r\n        \r\n        let ix = create_content_ix(\r\n            \u0026ctx.program_id,\r\n            \u0026creator.pubkey(),\r\n            \u0026content_pda,\r\n            \u0026config_pda,\r\n            tracking_id,\r\n            content_hash,\r\n            \u0026format!(\"ipfs://content{}\", i),\r\n            0,\r\n        );\r\n        \r\n        assert_eq!(ix.accounts[0].pubkey, creator.pubkey());\r\n    }\r\n}\r\n\r\n#[tokio::test]\r\nasync fn test_delete_content_instruction_format() {\r\n    let ctx = TestContext::new().await;\r\n    \r\n    let (config_pda, _bump) = ctx.get_config_pda();\r\n    let creator = Keypair::new();\r\n    let tracking_id = [7u8; 32];\r\n    let (content_pda, _) = ctx.get_content_pda(\u0026tracking_id);\r\n    \r\n    let ix = create_delete_content_ix(\r\n        \u0026ctx.program_id,\r\n        \u0026creator.pubkey(),\r\n        \u0026content_pda,\r\n        \u0026config_pda,\r\n    );\r\n    \r\n    assert_eq!(ix.program_id, ctx.program_id);\r\n    assert_eq!(ix.accounts.len(), 3);\r\n    assert!(ix.accounts[0].is_signer);\r\n    assert_eq!(ix.data.len(), 8);\r\n}\r\n\r\n#[tokio::test]\r\nasync fn test_delete_content_different_creators() {\r\n    let ctx = TestContext::new().await;\r\n    \r\n    let (config_pda, _bump) = ctx.get_config_pda();\r\n    \r\n    for i in 0..3 {\r\n        let creator = Keypair::new();\r\n        let mut tracking_id = [0u8; 32];\r\n        tracking_id[0] = i;\r\n        let (content_pda, _) = ctx.get_content_pda(\u0026tracking_id);\r\n        \r\n        let ix = create_delete_content_ix(\r\n            \u0026ctx.program_id,\r\n            \u0026creator.pubkey(),\r\n            \u0026content_pda,\r\n            \u0026config_pda,\r\n        );\r\n        \r\n        assert_eq!(ix.accounts[0].pubkey, creator.pubkey());\r\n    }\r\n}\r\n\r\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","content-registry","tests","initialize.rs"],"content":"//! Integration tests for content-registry initialize instruction\r\n\r\nmod common;\r\n\r\nuse common::*;\r\nuse solana_sdk::signature::{Keypair, Signer};\r\n\r\n#[tokio::test]\r\nasync fn test_initialize_success() {\r\n    let mut ctx = TestContext::new().await;\r\n    \r\n    let (config_pda, _bump) = ctx.get_config_pda();\r\n    let identity_program = Keypair::new();\r\n    let staking_program = Keypair::new();\r\n    \r\n    let ix = create_initialize_ix(\r\n        \u0026ctx.program_id,\r\n        \u0026ctx.payer.pubkey(),\r\n        \u0026config_pda,\r\n        \u0026identity_program.pubkey(),\r\n        \u0026staking_program.pubkey(),\r\n    );\r\n    \r\n    let result = ctx.process_transaction(\u0026[ix], \u0026[]).await;\r\n    assert!(result.is_ok());\r\n    \r\n    let config = ctx.get_account(config_pda).await;\r\n    assert!(config.is_some());\r\n}\r\n\r\n#[tokio::test]\r\nasync fn test_initialize_already_initialized() {\r\n    let mut ctx = TestContext::new().await;\r\n    \r\n    let (config_pda, _bump) = ctx.get_config_pda();\r\n    let identity_program = Keypair::new();\r\n    let staking_program = Keypair::new();\r\n    \r\n    let ix = create_initialize_ix(\r\n        \u0026ctx.program_id,\r\n        \u0026ctx.payer.pubkey(),\r\n        \u0026config_pda,\r\n        \u0026identity_program.pubkey(),\r\n        \u0026staking_program.pubkey(),\r\n    );\r\n    \r\n    ctx.process_transaction(\u0026[ix.clone()], \u0026[]).await.unwrap();\r\n    \r\n    let result = ctx.process_transaction(\u0026[ix], \u0026[]).await;\r\n    assert!(result.is_err());\r\n}\r\n\r\n#[tokio::test]\r\nasync fn test_initialize_with_programs() {\r\n    let mut ctx = TestContext::new().await;\r\n    \r\n    let (config_pda, _bump) = ctx.get_config_pda();\r\n    let identity_program = Keypair::new();\r\n    let staking_program = Keypair::new();\r\n    \r\n    let ix = create_initialize_ix(\r\n        \u0026ctx.program_id,\r\n        \u0026ctx.payer.pubkey(),\r\n        \u0026config_pda,\r\n        \u0026identity_program.pubkey(),\r\n        \u0026staking_program.pubkey(),\r\n    );\r\n    \r\n    let result = ctx.process_transaction(\u0026[ix], \u0026[]).await;\r\n    assert!(result.is_ok());\r\n}\r\n\r\n#[tokio::test]\r\nasync fn test_initialize_config_owned_by_program() {\r\n    let mut ctx = TestContext::new().await;\r\n    \r\n    let (config_pda, _bump) = ctx.get_config_pda();\r\n    let identity_program = Keypair::new();\r\n    let staking_program = Keypair::new();\r\n    \r\n    let ix = create_initialize_ix(\r\n        \u0026ctx.program_id,\r\n        \u0026ctx.payer.pubkey(),\r\n        \u0026config_pda,\r\n        \u0026identity_program.pubkey(),\r\n        \u0026staking_program.pubkey(),\r\n    );\r\n    \r\n    ctx.process_transaction(\u0026[ix], \u0026[]).await.unwrap();\r\n    \r\n    let config = ctx.get_account(config_pda).await.unwrap();\r\n    assert_eq!(config.owner, ctx.program_id);\r\n}\r\n\r\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","five-a-protocol","src","constants.rs"],"content":"/// 5A Protocol Constants\r\n\r\n/// PDA Seeds\r\npub const FIVE_A_CONFIG_SEED: \u0026[u8] = b\"five-a-config\";\r\npub const USER_SCORE_SEED: \u0026[u8] = b\"user-score\";\r\npub const SCORE_SNAPSHOT_SEED: \u0026[u8] = b\"score-snapshot\";\r\npub const VOUCH_RECORD_SEED: \u0026[u8] = b\"vouch-record\";\r\npub const VOUCH_STATUS_SEED: \u0026[u8] = b\"vouch-status\";\r\npub const VOUCHER_STATS_SEED: \u0026[u8] = b\"voucher-stats\";\r\npub const ORACLE_SEED: \u0026[u8] = b\"oracle\";\r\n\r\n/// Score weights (out of 10000)\r\npub const AUTHENTICITY_WEIGHT: u16 = 2500;  // 25%\r\npub const ACCURACY_WEIGHT: u16 = 2000;      // 20%\r\npub const AGILITY_WEIGHT: u16 = 1500;       // 15%\r\npub const ACTIVITY_WEIGHT: u16 = 2500;      // 25%\r\npub const APPROVED_WEIGHT: u16 = 1500;      // 15%\r\n\r\n/// Vouch system\r\npub const MIN_VOUCHER_SCORE: u16 = 6000;    // 60% 5A score to vouch\r\npub const VOUCH_STAKE_AMOUNT: u64 = 5_000_000_000; // 5 VCoin\r\npub const VOUCHES_REQUIRED: u8 = 3;\r\npub const VOUCH_EVALUATION_PERIOD: i64 = 90 * 24 * 60 * 60; // 90 days\r\npub const VOUCH_REWARD: u64 = 10_000_000_000; // 10 VCoin bonus for successful vouch\r\n\r\n/// Score update intervals\r\npub const SNAPSHOT_INTERVAL: i64 = 24 * 60 * 60; // Daily snapshots\r\n\r\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","five-a-protocol","src","contexts","create_snapshot.rs"],"content":"use anchor_lang::prelude::*;\r\n\r\nuse crate::constants::{FIVE_A_CONFIG_SEED, SCORE_SNAPSHOT_SEED};\r\nuse crate::state::{FiveAConfig, ScoreSnapshot};\r\n\r\n#[derive(Accounts)]\r\npub struct CreateSnapshot\u003c'info\u003e {\r\n    #[account(\r\n        mut,\r\n        seeds = [FIVE_A_CONFIG_SEED],\r\n        bump = five_a_config.bump\r\n    )]\r\n    pub five_a_config: Account\u003c'info, FiveAConfig\u003e,\r\n    \r\n    #[account(\r\n        init,\r\n        payer = oracle,\r\n        space = ScoreSnapshot::LEN,\r\n        seeds = [SCORE_SNAPSHOT_SEED, (five_a_config.current_epoch + 1).to_le_bytes().as_ref()],\r\n        bump\r\n    )]\r\n    pub snapshot: Account\u003c'info, ScoreSnapshot\u003e,\r\n    \r\n    #[account(mut)]\r\n    pub oracle: Signer\u003c'info\u003e,\r\n    \r\n    pub system_program: Program\u003c'info, System\u003e,\r\n}\r\n\r\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","five-a-protocol","src","contexts","evaluate_vouch.rs"],"content":"use anchor_lang::prelude::*;\r\n\r\nuse crate::constants::{VOUCH_RECORD_SEED, USER_SCORE_SEED, VOUCHER_STATS_SEED};\r\nuse crate::state::{VouchRecord, UserScore, VoucherStats};\r\n\r\n#[derive(Accounts)]\r\npub struct EvaluateVouch\u003c'info\u003e {\r\n    #[account(\r\n        mut,\r\n        seeds = [VOUCH_RECORD_SEED, vouch_record.voucher.as_ref(), vouch_record.vouchee.as_ref()],\r\n        bump = vouch_record.bump\r\n    )]\r\n    pub vouch_record: Account\u003c'info, VouchRecord\u003e,\r\n    \r\n    #[account(\r\n        seeds = [USER_SCORE_SEED, vouch_record.vouchee.as_ref()],\r\n        bump = vouchee_score.bump\r\n    )]\r\n    pub vouchee_score: Account\u003c'info, UserScore\u003e,\r\n    \r\n    #[account(\r\n        mut,\r\n        seeds = [VOUCHER_STATS_SEED, vouch_record.voucher.as_ref()],\r\n        bump = voucher_stats.bump\r\n    )]\r\n    pub voucher_stats: Account\u003c'info, VoucherStats\u003e,\r\n    \r\n    pub evaluator: Signer\u003c'info\u003e,\r\n}\r\n\r\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","five-a-protocol","src","contexts","get_score.rs"],"content":"use anchor_lang::prelude::*;\r\n\r\nuse crate::constants::USER_SCORE_SEED;\r\nuse crate::state::UserScore;\r\n\r\n#[derive(Accounts)]\r\npub struct GetScore\u003c'info\u003e {\r\n    #[account(\r\n        seeds = [USER_SCORE_SEED, user_score.user.as_ref()],\r\n        bump = user_score.bump\r\n    )]\r\n    pub user_score: Account\u003c'info, UserScore\u003e,\r\n}\r\n\r\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","five-a-protocol","src","contexts","initialize.rs"],"content":"use anchor_lang::prelude::*;\r\n\r\nuse crate::constants::FIVE_A_CONFIG_SEED;\r\nuse crate::state::FiveAConfig;\r\n\r\n#[derive(Accounts)]\r\npub struct Initialize\u003c'info\u003e {\r\n    #[account(\r\n        init,\r\n        payer = authority,\r\n        space = FiveAConfig::LEN,\r\n        seeds = [FIVE_A_CONFIG_SEED],\r\n        bump\r\n    )]\r\n    pub five_a_config: Account\u003c'info, FiveAConfig\u003e,\r\n    \r\n    /// CHECK: Vouch stake vault\r\n    pub vouch_vault: UncheckedAccount\u003c'info\u003e,\r\n    \r\n    #[account(mut)]\r\n    pub authority: Signer\u003c'info\u003e,\r\n    \r\n    pub system_program: Program\u003c'info, System\u003e,\r\n}\r\n\r\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","five-a-protocol","src","contexts","mod.rs"],"content":"/// Contexts module - Account validation structures\r\nmod initialize;\r\nmod register_oracle;\r\nmod submit_score;\r\nmod create_snapshot;\r\nmod vouch_for_user;\r\nmod evaluate_vouch;\r\nmod update_user_score;\r\nmod update_config;\r\nmod update_authority;\r\nmod get_score;\r\n\r\npub use initialize::*;\r\npub use register_oracle::*;\r\npub use submit_score::*;\r\npub use create_snapshot::*;\r\npub use vouch_for_user::*;\r\npub use evaluate_vouch::*;\r\npub use update_user_score::*;\r\npub use update_config::*;\r\npub use update_authority::*;\r\npub use get_score::*;\r\n\r\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","five-a-protocol","src","contexts","register_oracle.rs"],"content":"use anchor_lang::prelude::*;\r\n\r\nuse crate::constants::{FIVE_A_CONFIG_SEED, ORACLE_SEED};\r\nuse crate::errors::FiveAError;\r\nuse crate::state::{FiveAConfig, Oracle};\r\n\r\n#[derive(Accounts)]\r\npub struct RegisterOracle\u003c'info\u003e {\r\n    #[account(\r\n        mut,\r\n        seeds = [FIVE_A_CONFIG_SEED],\r\n        bump = five_a_config.bump,\r\n        has_one = authority @ FiveAError::Unauthorized\r\n    )]\r\n    pub five_a_config: Account\u003c'info, FiveAConfig\u003e,\r\n    \r\n    #[account(\r\n        init,\r\n        payer = authority,\r\n        space = Oracle::LEN,\r\n        seeds = [ORACLE_SEED, oracle_wallet.key().as_ref()],\r\n        bump\r\n    )]\r\n    pub oracle: Account\u003c'info, Oracle\u003e,\r\n    \r\n    /// CHECK: Oracle wallet to register\r\n    pub oracle_wallet: UncheckedAccount\u003c'info\u003e,\r\n    \r\n    #[account(mut)]\r\n    pub authority: Signer\u003c'info\u003e,\r\n    \r\n    pub system_program: Program\u003c'info, System\u003e,\r\n}\r\n\r\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","five-a-protocol","src","contexts","submit_score.rs"],"content":"use anchor_lang::prelude::*;\r\n\r\nuse crate::constants::{FIVE_A_CONFIG_SEED, USER_SCORE_SEED, ORACLE_SEED};\r\nuse crate::state::{FiveAConfig, UserScore, Oracle};\r\n\r\n#[derive(Accounts)]\r\npub struct SubmitScore\u003c'info\u003e {\r\n    #[account(\r\n        mut,\r\n        seeds = [FIVE_A_CONFIG_SEED],\r\n        bump = five_a_config.bump\r\n    )]\r\n    pub five_a_config: Account\u003c'info, FiveAConfig\u003e,\r\n    \r\n    #[account(\r\n        init_if_needed,\r\n        payer = oracle,\r\n        space = UserScore::LEN,\r\n        seeds = [USER_SCORE_SEED, user.key().as_ref()],\r\n        bump\r\n    )]\r\n    pub user_score: Account\u003c'info, UserScore\u003e,\r\n    \r\n    #[account(\r\n        mut,\r\n        seeds = [ORACLE_SEED, oracle.key().as_ref()],\r\n        bump = oracle_account.bump\r\n    )]\r\n    pub oracle_account: Account\u003c'info, Oracle\u003e,\r\n    \r\n    /// CHECK: User whose score is being updated\r\n    pub user: UncheckedAccount\u003c'info\u003e,\r\n    \r\n    #[account(mut)]\r\n    pub oracle: Signer\u003c'info\u003e,\r\n    \r\n    pub system_program: Program\u003c'info, System\u003e,\r\n}\r\n\r\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","five-a-protocol","src","contexts","update_authority.rs"],"content":"use anchor_lang::prelude::*;\r\n\r\nuse crate::constants::FIVE_A_CONFIG_SEED;\r\nuse crate::errors::FiveAError;\r\nuse crate::state::FiveAConfig;\r\n\r\n#[derive(Accounts)]\r\npub struct UpdateAuthority\u003c'info\u003e {\r\n    #[account(\r\n        mut,\r\n        seeds = [FIVE_A_CONFIG_SEED],\r\n        bump = five_a_config.bump,\r\n        has_one = authority @ FiveAError::Unauthorized\r\n    )]\r\n    pub five_a_config: Account\u003c'info, FiveAConfig\u003e,\r\n    \r\n    pub authority: Signer\u003c'info\u003e,\r\n}\r\n\r\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","five-a-protocol","src","contexts","update_config.rs"],"content":"use anchor_lang::prelude::*;\r\n\r\nuse crate::constants::FIVE_A_CONFIG_SEED;\r\nuse crate::errors::FiveAError;\r\nuse crate::state::FiveAConfig;\r\n\r\n#[derive(Accounts)]\r\npub struct UpdateConfig\u003c'info\u003e {\r\n    #[account(\r\n        mut,\r\n        seeds = [FIVE_A_CONFIG_SEED],\r\n        bump = five_a_config.bump,\r\n        has_one = authority @ FiveAError::Unauthorized\r\n    )]\r\n    pub five_a_config: Account\u003c'info, FiveAConfig\u003e,\r\n    \r\n    pub authority: Signer\u003c'info\u003e,\r\n}\r\n\r\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","five-a-protocol","src","contexts","update_user_score.rs"],"content":"use anchor_lang::prelude::*;\r\n\r\nuse crate::constants::USER_SCORE_SEED;\r\nuse crate::state::UserScore;\r\n\r\n#[derive(Accounts)]\r\npub struct UpdateUserScore\u003c'info\u003e {\r\n    #[account(\r\n        mut,\r\n        seeds = [USER_SCORE_SEED, user.key().as_ref()],\r\n        bump = user_score.bump,\r\n        constraint = user_score.user == user.key()\r\n    )]\r\n    pub user_score: Account\u003c'info, UserScore\u003e,\r\n    \r\n    pub user: Signer\u003c'info\u003e,\r\n}\r\n\r\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","five-a-protocol","src","contexts","vouch_for_user.rs"],"content":"use anchor_lang::prelude::*;\r\n\r\nuse crate::constants::{FIVE_A_CONFIG_SEED, USER_SCORE_SEED, VOUCH_RECORD_SEED, VOUCH_STATUS_SEED, VOUCHER_STATS_SEED};\r\nuse crate::state::{FiveAConfig, UserScore, VouchRecord, UserVouchStatus, VoucherStats};\r\n\r\n#[derive(Accounts)]\r\npub struct VouchForUser\u003c'info\u003e {\r\n    #[account(\r\n        seeds = [FIVE_A_CONFIG_SEED],\r\n        bump = five_a_config.bump\r\n    )]\r\n    pub five_a_config: Account\u003c'info, FiveAConfig\u003e,\r\n    \r\n    #[account(\r\n        seeds = [USER_SCORE_SEED, voucher.key().as_ref()],\r\n        bump = voucher_score.bump\r\n    )]\r\n    pub voucher_score: Account\u003c'info, UserScore\u003e,\r\n    \r\n    #[account(\r\n        init,\r\n        payer = voucher,\r\n        space = VouchRecord::LEN,\r\n        seeds = [VOUCH_RECORD_SEED, voucher.key().as_ref(), vouchee.key().as_ref()],\r\n        bump\r\n    )]\r\n    pub vouch_record: Account\u003c'info, VouchRecord\u003e,\r\n    \r\n    #[account(\r\n        init_if_needed,\r\n        payer = voucher,\r\n        space = UserVouchStatus::LEN,\r\n        seeds = [VOUCH_STATUS_SEED, vouchee.key().as_ref()],\r\n        bump\r\n    )]\r\n    pub vouchee_status: Account\u003c'info, UserVouchStatus\u003e,\r\n    \r\n    #[account(\r\n        init_if_needed,\r\n        payer = voucher,\r\n        space = VoucherStats::LEN,\r\n        seeds = [VOUCHER_STATS_SEED, voucher.key().as_ref()],\r\n        bump\r\n    )]\r\n    pub voucher_stats: Account\u003c'info, VoucherStats\u003e,\r\n    \r\n    #[account(mut)]\r\n    pub voucher: Signer\u003c'info\u003e,\r\n    \r\n    /// CHECK: User receiving vouch\r\n    pub vouchee: UncheckedAccount\u003c'info\u003e,\r\n    \r\n    pub system_program: Program\u003c'info, System\u003e,\r\n}\r\n\r\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","five-a-protocol","src","errors.rs"],"content":"use anchor_lang::prelude::*;\r\n\r\n/// 5A Protocol Error Codes\r\n#[error_code]\r\npub enum FiveAError {\r\n    #[msg(\"Unauthorized: Only the authority can perform this action\")]\r\n    Unauthorized,\r\n    \r\n    #[msg(\"Protocol is paused\")]\r\n    ProtocolPaused,\r\n    \r\n    #[msg(\"Caller is not a registered oracle\")]\r\n    NotOracle,\r\n    \r\n    #[msg(\"Invalid score value (must be 0-10000)\")]\r\n    InvalidScore,\r\n    \r\n    #[msg(\"Voucher 5A score too low (need 60%+)\")]\r\n    VoucherScoreTooLow,\r\n    \r\n    #[msg(\"User already has 3 vouches\")]\r\n    AlreadyFullyVouched,\r\n    \r\n    #[msg(\"Cannot vouch for self\")]\r\n    CannotVouchSelf,\r\n    \r\n    #[msg(\"Already vouched for this user\")]\r\n    AlreadyVouched,\r\n    \r\n    #[msg(\"Max concurrent vouches reached\")]\r\n    MaxVouchesReached,\r\n    \r\n    #[msg(\"Vouch stake amount incorrect\")]\r\n    InvalidStakeAmount,\r\n    \r\n    #[msg(\"Vouch evaluation period not complete\")]\r\n    EvaluationNotComplete,\r\n    \r\n    #[msg(\"Vouch already evaluated\")]\r\n    AlreadyEvaluated,\r\n    \r\n    #[msg(\"User not found\")]\r\n    UserNotFound,\r\n    \r\n    #[msg(\"Oracle already registered\")]\r\n    OracleAlreadyRegistered,\r\n    \r\n    #[msg(\"Maximum oracles reached\")]\r\n    MaxOraclesReached,\r\n    \r\n    #[msg(\"Arithmetic overflow\")]\r\n    Overflow,\r\n}\r\n\r\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","five-a-protocol","src","events.rs"],"content":"use anchor_lang::prelude::*;\r\n\r\n#[event]\r\npub struct ScoreUpdated {\r\n    pub user: Pubkey,\r\n    pub authenticity: u16,\r\n    pub accuracy: u16,\r\n    pub agility: u16,\r\n    pub activity: u16,\r\n    pub approved: u16,\r\n    pub composite: u16,\r\n    pub timestamp: i64,\r\n}\r\n\r\n#[event]\r\npub struct SnapshotCreated {\r\n    pub epoch: u64,\r\n    pub merkle_root: [u8; 32],\r\n    pub user_count: u64,\r\n    pub timestamp: i64,\r\n}\r\n\r\n#[event]\r\npub struct VouchCreated {\r\n    pub voucher: Pubkey,\r\n    pub vouchee: Pubkey,\r\n    pub stake: u64,\r\n    pub timestamp: i64,\r\n}\r\n\r\n#[event]\r\npub struct VouchEvaluated {\r\n    pub voucher: Pubkey,\r\n    pub vouchee: Pubkey,\r\n    pub success: bool,\r\n    pub reward_or_slash: u64,\r\n}\r\n\r\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","five-a-protocol","src","instructions","admin","initialize.rs"],"content":"use anchor_lang::prelude::*;\r\n\r\nuse crate::contexts::Initialize;\r\n\r\n/// Initialize the 5A protocol\r\npub fn handler(ctx: Context\u003cInitialize\u003e, identity_program: Pubkey, vcoin_mint: Pubkey) -\u003e Result\u003c()\u003e {\r\n    let config = \u0026mut ctx.accounts.five_a_config;\r\n    \r\n    config.authority = ctx.accounts.authority.key();\r\n    config.identity_program = identity_program;\r\n    config.vcoin_mint = vcoin_mint;\r\n    config.vouch_vault = ctx.accounts.vouch_vault.key();\r\n    config.oracles = [Pubkey::default(); 10];\r\n    config.oracle_count = 0;\r\n    config.required_consensus = 1;\r\n    config.total_users = 0;\r\n    config.current_epoch = 0;\r\n    config.last_snapshot_time = 0;\r\n    config.paused = false;\r\n    config.bump = ctx.bumps.five_a_config;\r\n    \r\n    msg!(\"5A Protocol initialized\");\r\n    Ok(())\r\n}\r\n\r\n","traces":[{"line":6,"address":[],"length":0,"stats":{"Line":0}},{"line":7,"address":[],"length":0,"stats":{"Line":0}},{"line":9,"address":[],"length":0,"stats":{"Line":0}},{"line":10,"address":[],"length":0,"stats":{"Line":0}},{"line":11,"address":[],"length":0,"stats":{"Line":0}},{"line":12,"address":[],"length":0,"stats":{"Line":0}},{"line":13,"address":[],"length":0,"stats":{"Line":0}},{"line":14,"address":[],"length":0,"stats":{"Line":0}},{"line":15,"address":[],"length":0,"stats":{"Line":0}},{"line":16,"address":[],"length":0,"stats":{"Line":0}},{"line":17,"address":[],"length":0,"stats":{"Line":0}},{"line":18,"address":[],"length":0,"stats":{"Line":0}},{"line":19,"address":[],"length":0,"stats":{"Line":0}},{"line":20,"address":[],"length":0,"stats":{"Line":0}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":16},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","five-a-protocol","src","instructions","admin","mod.rs"],"content":"/// Admin instructions\r\npub mod initialize;\r\npub mod register_oracle;\r\npub mod set_paused;\r\npub mod update_authority;\r\n\r\npub use initialize::*;\r\npub use register_oracle::*;\r\npub use set_paused::*;\r\npub use update_authority::*;\r\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","five-a-protocol","src","instructions","admin","register_oracle.rs"],"content":"use anchor_lang::prelude::*;\r\n\r\nuse crate::contexts::RegisterOracle;\r\nuse crate::errors::FiveAError;\r\n\r\n/// Register an oracle\r\npub fn handler(ctx: Context\u003cRegisterOracle\u003e, name: String) -\u003e Result\u003c()\u003e {\r\n    let config = \u0026mut ctx.accounts.five_a_config;\r\n    \r\n    require!(config.oracle_count \u003c 10, FiveAError::MaxOraclesReached);\r\n    \r\n    // Check if already registered\r\n    let oracle_key = ctx.accounts.oracle_wallet.key();\r\n    for i in 0..config.oracle_count as usize {\r\n        require!(\r\n            config.oracles[i] != oracle_key,\r\n            FiveAError::OracleAlreadyRegistered\r\n        );\r\n    }\r\n    \r\n    // Add to config\r\n    let idx = config.oracle_count as usize;\r\n    config.oracles[idx] = oracle_key;\r\n    config.oracle_count += 1;\r\n    \r\n    // Initialize oracle account\r\n    let oracle = \u0026mut ctx.accounts.oracle;\r\n    oracle.wallet = oracle_key;\r\n    \r\n    let name_bytes = name.as_bytes();\r\n    let len = name_bytes.len().min(32);\r\n    oracle.name[..len].copy_from_slice(\u0026name_bytes[..len]);\r\n    \r\n    oracle.is_active = true;\r\n    oracle.total_submissions = 0;\r\n    oracle.accuracy_rate = 10000;\r\n    oracle.last_submission = 0;\r\n    oracle.bump = ctx.bumps.oracle;\r\n    \r\n    msg!(\"Oracle registered: {}\", oracle_key);\r\n    Ok(())\r\n}\r\n\r\n","traces":[{"line":7,"address":[],"length":0,"stats":{"Line":0}},{"line":8,"address":[],"length":0,"stats":{"Line":0}},{"line":10,"address":[],"length":0,"stats":{"Line":0}},{"line":13,"address":[],"length":0,"stats":{"Line":0}},{"line":14,"address":[],"length":0,"stats":{"Line":0}},{"line":15,"address":[],"length":0,"stats":{"Line":0}},{"line":16,"address":[],"length":0,"stats":{"Line":0}},{"line":17,"address":[],"length":0,"stats":{"Line":0}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":23},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","five-a-protocol","src","instructions","admin","set_paused.rs"],"content":"use anchor_lang::prelude::*;\r\n\r\nuse crate::contexts::UpdateConfig;\r\n\r\n/// Pause/unpause protocol\r\npub fn handler(ctx: Context\u003cUpdateConfig\u003e, paused: bool) -\u003e Result\u003c()\u003e {\r\n    ctx.accounts.five_a_config.paused = paused;\r\n    msg!(\"5A Protocol paused: {}\", paused);\r\n    Ok(())\r\n}\r\n\r\n","traces":[{"line":6,"address":[],"length":0,"stats":{"Line":0}},{"line":7,"address":[],"length":0,"stats":{"Line":0}},{"line":8,"address":[],"length":0,"stats":{"Line":0}},{"line":9,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":4},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","five-a-protocol","src","instructions","admin","update_authority.rs"],"content":"use anchor_lang::prelude::*;\r\n\r\nuse crate::contexts::UpdateAuthority;\r\n\r\n/// Update authority\r\npub fn handler(ctx: Context\u003cUpdateAuthority\u003e, new_authority: Pubkey) -\u003e Result\u003c()\u003e {\r\n    ctx.accounts.five_a_config.authority = new_authority;\r\n    msg!(\"Authority updated to: {}\", new_authority);\r\n    Ok(())\r\n}\r\n\r\n","traces":[{"line":6,"address":[],"length":0,"stats":{"Line":0}},{"line":7,"address":[],"length":0,"stats":{"Line":0}},{"line":8,"address":[],"length":0,"stats":{"Line":0}},{"line":9,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":4},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","five-a-protocol","src","instructions","mod.rs"],"content":"/// Instructions module - Instruction handlers\r\npub mod admin;\r\npub mod oracle;\r\npub mod vouch;\r\npub mod user;\r\npub mod query;\r\n\r\npub use admin::*;\r\npub use oracle::*;\r\npub use vouch::*;\r\npub use user::*;\r\npub use query::*;\r\n\r\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","five-a-protocol","src","instructions","oracle","create_snapshot.rs"],"content":"use anchor_lang::prelude::*;\r\n\r\nuse crate::contexts::CreateSnapshot;\r\nuse crate::errors::FiveAError;\r\nuse crate::events::SnapshotCreated;\r\n\r\n/// Create a score snapshot (oracle only)\r\npub fn handler(\r\n    ctx: Context\u003cCreateSnapshot\u003e,\r\n    merkle_root: [u8; 32],\r\n    user_count: u64,\r\n    avg_score: u16,\r\n) -\u003e Result\u003c()\u003e {\r\n    let config = \u0026mut ctx.accounts.five_a_config;\r\n    require!(!config.paused, FiveAError::ProtocolPaused);\r\n    \r\n    // Verify oracle\r\n    let oracle_key = ctx.accounts.oracle.key();\r\n    let is_oracle = config.oracles[..config.oracle_count as usize]\r\n        .contains(\u0026oracle_key);\r\n    require!(is_oracle, FiveAError::NotOracle);\r\n    \r\n    let clock = Clock::get()?;\r\n    \r\n    // Increment epoch\r\n    config.current_epoch = config.current_epoch.saturating_add(1);\r\n    config.last_snapshot_time = clock.unix_timestamp;\r\n    \r\n    // Create snapshot\r\n    let snapshot = \u0026mut ctx.accounts.snapshot;\r\n    snapshot.epoch = config.current_epoch;\r\n    snapshot.merkle_root = merkle_root;\r\n    snapshot.user_count = user_count;\r\n    snapshot.avg_score = avg_score;\r\n    snapshot.timestamp = clock.unix_timestamp;\r\n    snapshot.submitter = oracle_key;\r\n    snapshot.bump = ctx.bumps.snapshot;\r\n    \r\n    emit!(SnapshotCreated {\r\n        epoch: snapshot.epoch,\r\n        merkle_root,\r\n        user_count,\r\n        timestamp: clock.unix_timestamp,\r\n    });\r\n    \r\n    msg!(\"Snapshot created: epoch {}\", snapshot.epoch);\r\n    Ok(())\r\n}\r\n\r\n","traces":[{"line":8,"address":[],"length":0,"stats":{"Line":0}},{"line":14,"address":[],"length":0,"stats":{"Line":0}},{"line":15,"address":[],"length":0,"stats":{"Line":0}},{"line":18,"address":[],"length":0,"stats":{"Line":0}},{"line":19,"address":[],"length":0,"stats":{"Line":0}},{"line":20,"address":[],"length":0,"stats":{"Line":0}},{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":25},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","five-a-protocol","src","instructions","oracle","mod.rs"],"content":"/// Oracle instructions\r\npub mod submit_score;\r\npub mod create_snapshot;\r\n\r\npub use submit_score::*;\r\npub use create_snapshot::*;\r\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","five-a-protocol","src","instructions","oracle","submit_score.rs"],"content":"use anchor_lang::prelude::*;\r\n\r\nuse crate::contexts::SubmitScore;\r\nuse crate::errors::FiveAError;\r\nuse crate::events::ScoreUpdated;\r\n\r\n/// Submit score update (oracle only)\r\npub fn handler(\r\n    ctx: Context\u003cSubmitScore\u003e,\r\n    authenticity: u16,\r\n    accuracy: u16,\r\n    agility: u16,\r\n    activity: u16,\r\n    approved: u16,\r\n) -\u003e Result\u003c()\u003e {\r\n    let config = \u0026ctx.accounts.five_a_config;\r\n    require!(!config.paused, FiveAError::ProtocolPaused);\r\n    \r\n    // Validate scores\r\n    require!(authenticity \u003c= 10000, FiveAError::InvalidScore);\r\n    require!(accuracy \u003c= 10000, FiveAError::InvalidScore);\r\n    require!(agility \u003c= 10000, FiveAError::InvalidScore);\r\n    require!(activity \u003c= 10000, FiveAError::InvalidScore);\r\n    require!(approved \u003c= 10000, FiveAError::InvalidScore);\r\n    \r\n    // Verify oracle is registered\r\n    let oracle_key = ctx.accounts.oracle.key();\r\n    let is_oracle = config.oracles[..config.oracle_count as usize]\r\n        .contains(\u0026oracle_key);\r\n    require!(is_oracle, FiveAError::NotOracle);\r\n    \r\n    let clock = Clock::get()?;\r\n    let user_score = \u0026mut ctx.accounts.user_score;\r\n    \r\n    // Initialize if new\r\n    if user_score.user == Pubkey::default() {\r\n        user_score.user = ctx.accounts.user.key();\r\n        let config = \u0026mut ctx.accounts.five_a_config;\r\n        config.total_users = config.total_users.saturating_add(1);\r\n    }\r\n    \r\n    // Update scores\r\n    user_score.authenticity = authenticity;\r\n    user_score.accuracy = accuracy;\r\n    user_score.agility = agility;\r\n    user_score.activity = activity;\r\n    user_score.approved = approved;\r\n    user_score.composite_score = user_score.calculate_composite();\r\n    user_score.last_updated = clock.unix_timestamp;\r\n    user_score.update_count = user_score.update_count.saturating_add(1);\r\n    user_score.bump = ctx.bumps.user_score;\r\n    \r\n    // Update oracle stats\r\n    let oracle_account = \u0026mut ctx.accounts.oracle_account;\r\n    oracle_account.total_submissions = oracle_account.total_submissions.saturating_add(1);\r\n    oracle_account.last_submission = clock.unix_timestamp;\r\n    \r\n    emit!(ScoreUpdated {\r\n        user: user_score.user,\r\n        authenticity,\r\n        accuracy,\r\n        agility,\r\n        activity,\r\n        approved,\r\n        composite: user_score.composite_score,\r\n        timestamp: clock.unix_timestamp,\r\n    });\r\n    \r\n    msg!(\"Score updated for: {}, composite: {}\", user_score.user, user_score.composite_score);\r\n    Ok(())\r\n}\r\n\r\n","traces":[{"line":8,"address":[],"length":0,"stats":{"Line":0}},{"line":16,"address":[],"length":0,"stats":{"Line":0}},{"line":17,"address":[],"length":0,"stats":{"Line":0}},{"line":20,"address":[],"length":0,"stats":{"Line":0}},{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":41},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","five-a-protocol","src","instructions","query","get_score.rs"],"content":"use anchor_lang::prelude::*;\r\n\r\nuse crate::contexts::GetScore;\r\n\r\n/// Get user score\r\npub fn handler(ctx: Context\u003cGetScore\u003e) -\u003e Result\u003c()\u003e {\r\n    let score = \u0026ctx.accounts.user_score;\r\n    msg!(\"User: {}\", score.user);\r\n    msg!(\"Composite: {}\", score.composite_score);\r\n    msg!(\"A1 Authenticity: {}\", score.authenticity);\r\n    msg!(\"A2 Accuracy: {}\", score.accuracy);\r\n    msg!(\"A3 Agility: {}\", score.agility);\r\n    msg!(\"A4 Activity: {}\", score.activity);\r\n    msg!(\"A5 Approved: {}\", score.approved);\r\n    Ok(())\r\n}\r\n\r\n","traces":[{"line":6,"address":[],"length":0,"stats":{"Line":0}},{"line":7,"address":[],"length":0,"stats":{"Line":0}},{"line":8,"address":[],"length":0,"stats":{"Line":0}},{"line":9,"address":[],"length":0,"stats":{"Line":0}},{"line":10,"address":[],"length":0,"stats":{"Line":0}},{"line":11,"address":[],"length":0,"stats":{"Line":0}},{"line":12,"address":[],"length":0,"stats":{"Line":0}},{"line":13,"address":[],"length":0,"stats":{"Line":0}},{"line":14,"address":[],"length":0,"stats":{"Line":0}},{"line":15,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":10},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","five-a-protocol","src","instructions","query","mod.rs"],"content":"/// Query instructions\r\npub mod get_score;\r\n\r\npub use get_score::*;\r\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","five-a-protocol","src","instructions","user","disable_private_score.rs"],"content":"use anchor_lang::prelude::*;\r\n\r\nuse crate::contexts::UpdateUserScore;\r\n\r\n/// Disable private score mode\r\npub fn handler(ctx: Context\u003cUpdateUserScore\u003e) -\u003e Result\u003c()\u003e {\r\n    ctx.accounts.user_score.is_private = false;\r\n    msg!(\"Private score mode disabled\");\r\n    Ok(())\r\n}\r\n\r\n","traces":[{"line":6,"address":[],"length":0,"stats":{"Line":0}},{"line":7,"address":[],"length":0,"stats":{"Line":0}},{"line":8,"address":[],"length":0,"stats":{"Line":0}},{"line":9,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":4},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","five-a-protocol","src","instructions","user","enable_private_score.rs"],"content":"use anchor_lang::prelude::*;\r\n\r\nuse crate::contexts::UpdateUserScore;\r\n\r\n/// Enable private score mode\r\npub fn handler(ctx: Context\u003cUpdateUserScore\u003e) -\u003e Result\u003c()\u003e {\r\n    ctx.accounts.user_score.is_private = true;\r\n    msg!(\"Private score mode enabled\");\r\n    Ok(())\r\n}\r\n\r\n","traces":[{"line":6,"address":[],"length":0,"stats":{"Line":0}},{"line":7,"address":[],"length":0,"stats":{"Line":0}},{"line":8,"address":[],"length":0,"stats":{"Line":0}},{"line":9,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":4},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","five-a-protocol","src","instructions","user","mod.rs"],"content":"/// User instructions\r\npub mod enable_private_score;\r\npub mod disable_private_score;\r\n\r\npub use enable_private_score::*;\r\npub use disable_private_score::*;\r\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","five-a-protocol","src","instructions","vouch","evaluate_vouch.rs"],"content":"use anchor_lang::prelude::*;\r\n\r\nuse crate::constants::{VOUCH_EVALUATION_PERIOD, VOUCH_REWARD};\r\nuse crate::contexts::EvaluateVouch;\r\nuse crate::errors::FiveAError;\r\nuse crate::events::VouchEvaluated;\r\nuse crate::state::VouchStatus;\r\n\r\n/// Evaluate vouch outcome after 90 days\r\npub fn handler(ctx: Context\u003cEvaluateVouch\u003e) -\u003e Result\u003c()\u003e {\r\n    let vouch = \u0026mut ctx.accounts.vouch_record;\r\n    \r\n    require!(!vouch.outcome_evaluated, FiveAError::AlreadyEvaluated);\r\n    \r\n    let clock = Clock::get()?;\r\n    let elapsed = clock.unix_timestamp - vouch.vouched_at;\r\n    require!(elapsed \u003e= VOUCH_EVALUATION_PERIOD, FiveAError::EvaluationNotComplete);\r\n    \r\n    // Check vouchee's current score\r\n    let vouchee_score = \u0026ctx.accounts.vouchee_score;\r\n    let is_successful = vouchee_score.composite_score \u003e= 5000; // 50%+\r\n    \r\n    vouch.outcome_evaluated = true;\r\n    \r\n    let voucher_stats = \u0026mut ctx.accounts.voucher_stats;\r\n    voucher_stats.vouches_active = voucher_stats.vouches_active.saturating_sub(1);\r\n    \r\n    if is_successful {\r\n        vouch.status = VouchStatus::Rewarded as u8;\r\n        voucher_stats.successful_vouches = voucher_stats.successful_vouches.saturating_add(1);\r\n        voucher_stats.total_rewards_earned = voucher_stats.total_rewards_earned.saturating_add(VOUCH_REWARD);\r\n        \r\n        emit!(VouchEvaluated {\r\n            voucher: vouch.voucher,\r\n            vouchee: vouch.vouchee,\r\n            success: true,\r\n            reward_or_slash: VOUCH_REWARD,\r\n        });\r\n    } else {\r\n        vouch.status = VouchStatus::Slashed as u8;\r\n        voucher_stats.failed_vouches = voucher_stats.failed_vouches.saturating_add(1);\r\n        voucher_stats.total_stake_lost = voucher_stats.total_stake_lost.saturating_add(vouch.vouch_stake);\r\n        \r\n        emit!(VouchEvaluated {\r\n            voucher: vouch.voucher,\r\n            vouchee: vouch.vouchee,\r\n            success: false,\r\n            reward_or_slash: vouch.vouch_stake,\r\n        });\r\n    }\r\n    \r\n    // Update accuracy\r\n    let total = voucher_stats.successful_vouches + voucher_stats.failed_vouches;\r\n    if total \u003e 0 {\r\n        voucher_stats.vouch_accuracy = \r\n            ((voucher_stats.successful_vouches as u32 * 10000) / total as u32) as u16;\r\n    }\r\n    \r\n    msg!(\"Vouch evaluated: success={}\", is_successful);\r\n    Ok(())\r\n}\r\n\r\n","traces":[{"line":10,"address":[],"length":0,"stats":{"Line":0}},{"line":11,"address":[],"length":0,"stats":{"Line":0}},{"line":13,"address":[],"length":0,"stats":{"Line":0}},{"line":15,"address":[],"length":0,"stats":{"Line":0}},{"line":16,"address":[],"length":0,"stats":{"Line":0}},{"line":17,"address":[],"length":0,"stats":{"Line":0}},{"line":20,"address":[],"length":0,"stats":{"Line":0}},{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":34},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","five-a-protocol","src","instructions","vouch","mod.rs"],"content":"/// Vouch instructions\r\npub mod vouch_for_user;\r\npub mod evaluate_vouch;\r\n\r\npub use vouch_for_user::*;\r\npub use evaluate_vouch::*;\r\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","five-a-protocol","src","instructions","vouch","vouch_for_user.rs"],"content":"use anchor_lang::prelude::*;\r\n\r\nuse crate::constants::{MIN_VOUCHER_SCORE, VOUCH_STAKE_AMOUNT, VOUCHES_REQUIRED};\r\nuse crate::contexts::VouchForUser;\r\nuse crate::errors::FiveAError;\r\nuse crate::events::VouchCreated;\r\nuse crate::state::{VouchStatus, VoucherStats};\r\n\r\n/// Vouch for a new user\r\npub fn handler(ctx: Context\u003cVouchForUser\u003e) -\u003e Result\u003c()\u003e {\r\n    let config = \u0026ctx.accounts.five_a_config;\r\n    require!(!config.paused, FiveAError::ProtocolPaused);\r\n    \r\n    let voucher_key = ctx.accounts.voucher.key();\r\n    let vouchee_key = ctx.accounts.vouchee.key();\r\n    \r\n    // Cannot vouch for self\r\n    require!(voucher_key != vouchee_key, FiveAError::CannotVouchSelf);\r\n    \r\n    // Check voucher's 5A score\r\n    let voucher_score = \u0026ctx.accounts.voucher_score;\r\n    require!(\r\n        voucher_score.composite_score \u003e= MIN_VOUCHER_SCORE,\r\n        FiveAError::VoucherScoreTooLow\r\n    );\r\n    \r\n    // Check voucher stats\r\n    let voucher_stats = \u0026ctx.accounts.voucher_stats;\r\n    let max_vouches = VoucherStats::max_vouches_for_score(voucher_score.composite_score);\r\n    require!(\r\n        voucher_stats.vouches_active \u003c max_vouches,\r\n        FiveAError::MaxVouchesReached\r\n    );\r\n    \r\n    // Check vouchee status\r\n    let vouchee_status = \u0026ctx.accounts.vouchee_status;\r\n    require!(\r\n        vouchee_status.vouches_received \u003c VOUCHES_REQUIRED,\r\n        FiveAError::AlreadyFullyVouched\r\n    );\r\n    \r\n    // Check not already vouched by this voucher\r\n    for i in 0..vouchee_status.vouches_received as usize {\r\n        require!(\r\n            vouchee_status.vouchers[i] != voucher_key,\r\n            FiveAError::AlreadyVouched\r\n        );\r\n    }\r\n    \r\n    let clock = Clock::get()?;\r\n    \r\n    // Create vouch record\r\n    let vouch = \u0026mut ctx.accounts.vouch_record;\r\n    vouch.voucher = voucher_key;\r\n    vouch.vouchee = vouchee_key;\r\n    vouch.vouched_at = clock.unix_timestamp;\r\n    vouch.vouch_stake = VOUCH_STAKE_AMOUNT;\r\n    vouch.status = VouchStatus::Active as u8;\r\n    vouch.outcome_evaluated = false;\r\n    vouch.bump = ctx.bumps.vouch_record;\r\n    \r\n    // Update vouchee status\r\n    let vouchee_status = \u0026mut ctx.accounts.vouchee_status;\r\n    vouchee_status.user = vouchee_key;\r\n    let vouch_idx = vouchee_status.vouches_received as usize;\r\n    vouchee_status.vouchers[vouch_idx] = voucher_key;\r\n    vouchee_status.vouches_received += 1;\r\n    let multiplier = vouchee_status.get_multiplier();\r\n    vouchee_status.reward_multiplier = multiplier;\r\n    \r\n    if vouchee_status.vouches_received \u003e= VOUCHES_REQUIRED {\r\n        vouchee_status.is_fully_vouched = true;\r\n        vouchee_status.vouch_completed_at = clock.unix_timestamp;\r\n    }\r\n    vouchee_status.bump = ctx.bumps.vouchee_status;\r\n    \r\n    // Update voucher stats\r\n    let voucher_stats = \u0026mut ctx.accounts.voucher_stats;\r\n    voucher_stats.user = voucher_key;\r\n    voucher_stats.total_vouches_given = voucher_stats.total_vouches_given.saturating_add(1);\r\n    voucher_stats.vouches_active = voucher_stats.vouches_active.saturating_add(1);\r\n    voucher_stats.max_concurrent_vouches = max_vouches;\r\n    voucher_stats.bump = ctx.bumps.voucher_stats;\r\n    \r\n    emit!(VouchCreated {\r\n        voucher: voucher_key,\r\n        vouchee: vouchee_key,\r\n        stake: VOUCH_STAKE_AMOUNT,\r\n        timestamp: clock.unix_timestamp,\r\n    });\r\n    \r\n    msg!(\"Vouch created: {} -\u003e {}\", voucher_key, vouchee_key);\r\n    Ok(())\r\n}\r\n\r\n","traces":[{"line":10,"address":[],"length":0,"stats":{"Line":0}},{"line":11,"address":[],"length":0,"stats":{"Line":0}},{"line":12,"address":[],"length":0,"stats":{"Line":0}},{"line":14,"address":[],"length":0,"stats":{"Line":0}},{"line":15,"address":[],"length":0,"stats":{"Line":0}},{"line":18,"address":[],"length":0,"stats":{"Line":0}},{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":56},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","five-a-protocol","src","lib.rs"],"content":"use anchor_lang::prelude::*;\r\n\r\npub mod constants;\r\npub mod contexts;\r\npub mod errors;\r\npub mod events;\r\npub mod instructions;\r\npub mod state;\r\n\r\n#[cfg(test)]\r\nmod tests;\r\n\r\nuse contexts::*;\r\n\r\ndeclare_id!(\"783PbtJw5cc7yatnr9fsvTGSnkKaV6iJe6E8VUPTYrT8\");\r\n\r\n/// 5A Reputation Protocol\r\n/// \r\n/// Anti-bot reputation scoring with oracle model and periodic snapshots.\r\n/// \r\n/// The 5 Stars (Open Source - MIT Licensed - Public Good):\r\n/// - A1: Authenticity (25%) - \"Are you a real person?\"\r\n/// - A2: Accuracy (20%) - \"Is your content quality?\"\r\n/// - A3: Agility (15%) - \"Are you fast?\"\r\n/// - A4: Activity (25%) - \"Do you show up daily?\"\r\n/// - A5: Approved (15%) - \"Does the community like you?\"\r\n/// \r\n/// Score Range: 0-100 (stored as 0-10000 for precision)\r\n\r\n#[program]\r\npub mod five_a_protocol {\r\n    use super::*;\r\n\r\n    /// Initialize the 5A protocol\r\n    pub fn initialize(ctx: Context\u003cInitialize\u003e, identity_program: Pubkey, vcoin_mint: Pubkey) -\u003e Result\u003c()\u003e {\r\n        instructions::admin::initialize::handler(ctx, identity_program, vcoin_mint)\r\n    }\r\n    \r\n    /// Register an oracle\r\n    pub fn register_oracle(ctx: Context\u003cRegisterOracle\u003e, name: String) -\u003e Result\u003c()\u003e {\r\n        instructions::admin::register_oracle::handler(ctx, name)\r\n    }\r\n    \r\n    /// Submit score update (oracle only)\r\n    pub fn submit_score(\r\n        ctx: Context\u003cSubmitScore\u003e,\r\n        authenticity: u16,\r\n        accuracy: u16,\r\n        agility: u16,\r\n        activity: u16,\r\n        approved: u16,\r\n    ) -\u003e Result\u003c()\u003e {\r\n        instructions::oracle::submit_score::handler(ctx, authenticity, accuracy, agility, activity, approved)\r\n    }\r\n    \r\n    /// Create a score snapshot (oracle only)\r\n    pub fn create_snapshot(\r\n        ctx: Context\u003cCreateSnapshot\u003e,\r\n        merkle_root: [u8; 32],\r\n        user_count: u64,\r\n        avg_score: u16,\r\n    ) -\u003e Result\u003c()\u003e {\r\n        instructions::oracle::create_snapshot::handler(ctx, merkle_root, user_count, avg_score)\r\n    }\r\n    \r\n    /// Vouch for a new user\r\n    pub fn vouch_for_user(ctx: Context\u003cVouchForUser\u003e) -\u003e Result\u003c()\u003e {\r\n        instructions::vouch::vouch_for_user::handler(ctx)\r\n    }\r\n    \r\n    /// Evaluate vouch outcome after 90 days\r\n    pub fn evaluate_vouch(ctx: Context\u003cEvaluateVouch\u003e) -\u003e Result\u003c()\u003e {\r\n        instructions::vouch::evaluate_vouch::handler(ctx)\r\n    }\r\n    \r\n    /// Enable private score mode\r\n    pub fn enable_private_score(ctx: Context\u003cUpdateUserScore\u003e) -\u003e Result\u003c()\u003e {\r\n        instructions::user::enable_private_score::handler(ctx)\r\n    }\r\n    \r\n    /// Disable private score mode\r\n    pub fn disable_private_score(ctx: Context\u003cUpdateUserScore\u003e) -\u003e Result\u003c()\u003e {\r\n        instructions::user::disable_private_score::handler(ctx)\r\n    }\r\n    \r\n    /// Pause/unpause protocol\r\n    pub fn set_paused(ctx: Context\u003cUpdateConfig\u003e, paused: bool) -\u003e Result\u003c()\u003e {\r\n        instructions::admin::set_paused::handler(ctx, paused)\r\n    }\r\n    \r\n    /// Update authority\r\n    pub fn update_authority(ctx: Context\u003cUpdateAuthority\u003e, new_authority: Pubkey) -\u003e Result\u003c()\u003e {\r\n        instructions::admin::update_authority::handler(ctx, new_authority)\r\n    }\r\n    \r\n    /// Get user score\r\n    pub fn get_score(ctx: Context\u003cGetScore\u003e) -\u003e Result\u003c()\u003e {\r\n        instructions::query::get_score::handler(ctx)\r\n    }\r\n}\r\n","traces":[{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":0}},{"line":98,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":22},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","five-a-protocol","src","state","config.rs"],"content":"use anchor_lang::prelude::*;\r\n\r\n/// Global 5A protocol configuration\r\n#[account]\r\n#[derive(Default)]\r\npub struct FiveAConfig {\r\n    /// Admin authority\r\n    pub authority: Pubkey,\r\n    /// Identity protocol program\r\n    pub identity_program: Pubkey,\r\n    /// VCoin mint for vouch stakes\r\n    pub vcoin_mint: Pubkey,\r\n    /// Vouch stake vault\r\n    pub vouch_vault: Pubkey,\r\n    /// Registered oracles (max 10)\r\n    pub oracles: [Pubkey; 10],\r\n    /// Number of active oracles\r\n    pub oracle_count: u8,\r\n    /// Required consensus (e.g., 5 of 7)\r\n    pub required_consensus: u8,\r\n    /// Total users with scores\r\n    pub total_users: u64,\r\n    /// Current snapshot epoch\r\n    pub current_epoch: u64,\r\n    /// Last snapshot timestamp\r\n    pub last_snapshot_time: i64,\r\n    /// Whether protocol is paused\r\n    pub paused: bool,\r\n    /// PDA bump\r\n    pub bump: u8,\r\n}\r\n\r\nimpl FiveAConfig {\r\n    pub const LEN: usize = 8 + // discriminator\r\n        32 + // authority\r\n        32 + // identity_program\r\n        32 + // vcoin_mint\r\n        32 + // vouch_vault\r\n        (32 * 10) + // oracles\r\n        1 +  // oracle_count\r\n        1 +  // required_consensus\r\n        8 +  // total_users\r\n        8 +  // current_epoch\r\n        8 +  // last_snapshot_time\r\n        1 +  // paused\r\n        1;   // bump\r\n}\r\n\r\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","five-a-protocol","src","state","mod.rs"],"content":"/// State module - Account structures\r\nmod config;\r\nmod user_score;\r\nmod score_snapshot;\r\nmod vouch_record;\r\nmod vouch_status;\r\nmod user_vouch_status;\r\nmod voucher_stats;\r\nmod oracle;\r\n\r\npub use config::*;\r\npub use user_score::*;\r\npub use score_snapshot::*;\r\npub use vouch_record::*;\r\npub use vouch_status::*;\r\npub use user_vouch_status::*;\r\npub use voucher_stats::*;\r\npub use oracle::*;\r\n\r\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","five-a-protocol","src","state","oracle.rs"],"content":"use anchor_lang::prelude::*;\r\n\r\n/// Registered oracle\r\n#[account]\r\n#[derive(Default)]\r\npub struct Oracle {\r\n    /// Oracle wallet\r\n    pub wallet: Pubkey,\r\n    /// Oracle name (max 32 chars)\r\n    pub name: [u8; 32],\r\n    /// Whether oracle is active\r\n    pub is_active: bool,\r\n    /// Total score submissions\r\n    pub total_submissions: u64,\r\n    /// Accuracy rate (0-10000)\r\n    pub accuracy_rate: u16,\r\n    /// Last submission timestamp\r\n    pub last_submission: i64,\r\n    /// PDA bump\r\n    pub bump: u8,\r\n}\r\n\r\nimpl Oracle {\r\n    pub const LEN: usize = 8 + // discriminator\r\n        32 + // wallet\r\n        32 + // name\r\n        1 +  // is_active\r\n        8 +  // total_submissions\r\n        2 +  // accuracy_rate\r\n        8 +  // last_submission\r\n        1;   // bump\r\n}\r\n\r\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","five-a-protocol","src","state","score_snapshot.rs"],"content":"use anchor_lang::prelude::*;\r\n\r\n/// Periodic score snapshot for epoch\r\n#[account]\r\n#[derive(Default)]\r\npub struct ScoreSnapshot {\r\n    /// Epoch number\r\n    pub epoch: u64,\r\n    /// Merkle root of all scores in this epoch\r\n    pub merkle_root: [u8; 32],\r\n    /// Total users in snapshot\r\n    pub user_count: u64,\r\n    /// Average composite score\r\n    pub avg_score: u16,\r\n    /// Snapshot timestamp\r\n    pub timestamp: i64,\r\n    /// Oracle that submitted snapshot\r\n    pub submitter: Pubkey,\r\n    /// PDA bump\r\n    pub bump: u8,\r\n}\r\n\r\nimpl ScoreSnapshot {\r\n    pub const LEN: usize = 8 + // discriminator\r\n        8 +  // epoch\r\n        32 + // merkle_root\r\n        8 +  // user_count\r\n        2 +  // avg_score\r\n        8 +  // timestamp\r\n        32 + // submitter\r\n        1;   // bump\r\n}\r\n\r\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","five-a-protocol","src","state","user_score.rs"],"content":"use anchor_lang::prelude::*;\r\n\r\nuse crate::constants::*;\r\n\r\n/// Individual user's 5A score\r\n#[account]\r\n#[derive(Default)]\r\npub struct UserScore {\r\n    /// User wallet\r\n    pub user: Pubkey,\r\n    /// Authenticity score (0-10000)\r\n    pub authenticity: u16,\r\n    /// Accuracy score (0-10000)\r\n    pub accuracy: u16,\r\n    /// Agility score (0-10000)\r\n    pub agility: u16,\r\n    /// Activity score (0-10000)\r\n    pub activity: u16,\r\n    /// Approved score (0-10000)\r\n    pub approved: u16,\r\n    /// Weighted composite score (0-10000)\r\n    pub composite_score: u16,\r\n    /// Score last updated\r\n    pub last_updated: i64,\r\n    /// Last snapshot epoch this user was included in\r\n    pub last_snapshot_epoch: u64,\r\n    /// Number of score updates\r\n    pub update_count: u32,\r\n    /// Whether user has private score mode enabled\r\n    pub is_private: bool,\r\n    /// PDA bump\r\n    pub bump: u8,\r\n}\r\n\r\nimpl UserScore {\r\n    pub const LEN: usize = 8 + // discriminator\r\n        32 + // user\r\n        2 +  // authenticity\r\n        2 +  // accuracy\r\n        2 +  // agility\r\n        2 +  // activity\r\n        2 +  // approved\r\n        2 +  // composite_score\r\n        8 +  // last_updated\r\n        8 +  // last_snapshot_epoch\r\n        4 +  // update_count\r\n        1 +  // is_private\r\n        1;   // bump\r\n    \r\n    /// Calculate weighted composite score\r\n    pub fn calculate_composite(\u0026self) -\u003e u16 {\r\n        let weighted = \r\n            (self.authenticity as u32 * AUTHENTICITY_WEIGHT as u32 +\r\n             self.accuracy as u32 * ACCURACY_WEIGHT as u32 +\r\n             self.agility as u32 * AGILITY_WEIGHT as u32 +\r\n             self.activity as u32 * ACTIVITY_WEIGHT as u32 +\r\n             self.approved as u32 * APPROVED_WEIGHT as u32) / 10000;\r\n        \r\n        weighted as u16\r\n    }\r\n}\r\n\r\n","traces":[{"line":51,"address":[],"length":0,"stats":{"Line":1441151880758558720}},{"line":52,"address":[],"length":0,"stats":{"Line":1441151880758558720}},{"line":53,"address":[],"length":0,"stats":{"Line":7205759403792793600}},{"line":54,"address":[],"length":0,"stats":{"Line":5764607523034234880}},{"line":55,"address":[],"length":0,"stats":{"Line":4323455642275676160}},{"line":56,"address":[],"length":0,"stats":{"Line":2882303761517117440}},{"line":57,"address":[],"length":0,"stats":{"Line":1441151880758558720}},{"line":59,"address":[],"length":0,"stats":{"Line":1441151880758558720}}],"covered":8,"coverable":8},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","five-a-protocol","src","state","user_vouch_status.rs"],"content":"use anchor_lang::prelude::*;\r\n\r\n/// User's vouch status (how many vouches received)\r\n#[account]\r\n#[derive(Default)]\r\npub struct UserVouchStatus {\r\n    /// User wallet\r\n    pub user: Pubkey,\r\n    /// Number of vouches received (0-3)\r\n    pub vouches_received: u8,\r\n    /// Who vouched (max 3)\r\n    pub vouchers: [Pubkey; 3],\r\n    /// Timestamp when 3 vouches received\r\n    pub vouch_completed_at: i64,\r\n    /// Reward multiplier (0-10000 = 0-100%)\r\n    pub reward_multiplier: u16,\r\n    /// Whether fully vouched\r\n    pub is_fully_vouched: bool,\r\n    /// PDA bump\r\n    pub bump: u8,\r\n}\r\n\r\nimpl UserVouchStatus {\r\n    pub const LEN: usize = 8 + // discriminator\r\n        32 + // user\r\n        1 +  // vouches_received\r\n        (32 * 3) + // vouchers\r\n        8 +  // vouch_completed_at\r\n        2 +  // reward_multiplier\r\n        1 +  // is_fully_vouched\r\n        1;   // bump\r\n    \r\n    /// Get reward multiplier based on vouch count\r\n    pub fn get_multiplier(\u0026self) -\u003e u16 {\r\n        match self.vouches_received {\r\n            0 =\u003e 1000,  // 10%\r\n            1 =\u003e 4000,  // 40%\r\n            2 =\u003e 7000,  // 70%\r\n            _ =\u003e 10000, // 100%\r\n        }\r\n    }\r\n}\r\n\r\n","traces":[{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":6},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","five-a-protocol","src","state","vouch_record.rs"],"content":"use anchor_lang::prelude::*;\r\n\r\n/// Vouch record (PDA per vouch)\r\n#[account]\r\n#[derive(Default)]\r\npub struct VouchRecord {\r\n    /// Voucher (must have 60%+ 5A)\r\n    pub voucher: Pubkey,\r\n    /// Vouchee (new user)\r\n    pub vouchee: Pubkey,\r\n    /// Timestamp of vouch\r\n    pub vouched_at: i64,\r\n    /// VCoin staked (5 VCoin)\r\n    pub vouch_stake: u64,\r\n    /// Status: 0=Active, 1=Revoked, 2=Slashed, 3=Rewarded\r\n    pub status: u8,\r\n    /// Whether outcome has been evaluated\r\n    pub outcome_evaluated: bool,\r\n    /// PDA bump\r\n    pub bump: u8,\r\n}\r\n\r\nimpl VouchRecord {\r\n    pub const LEN: usize = 8 + // discriminator\r\n        32 + // voucher\r\n        32 + // vouchee\r\n        8 +  // vouched_at\r\n        8 +  // vouch_stake\r\n        1 +  // status\r\n        1 +  // outcome_evaluated\r\n        1;   // bump\r\n}\r\n\r\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","five-a-protocol","src","state","vouch_status.rs"],"content":"use anchor_lang::prelude::*;\r\n\r\n/// Vouch status enum\r\n#[derive(AnchorSerialize, AnchorDeserialize, Clone, Copy, PartialEq, Eq, Default)]\r\npub enum VouchStatus {\r\n    #[default]\r\n    Active = 0,\r\n    Revoked = 1,\r\n    Slashed = 2,\r\n    Rewarded = 3,\r\n}\r\n\r\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","five-a-protocol","src","state","voucher_stats.rs"],"content":"use anchor_lang::prelude::*;\r\n\r\n/// Voucher statistics\r\n#[account]\r\n#[derive(Default)]\r\npub struct VoucherStats {\r\n    /// Voucher wallet\r\n    pub user: Pubkey,\r\n    /// Total vouches given\r\n    pub total_vouches_given: u32,\r\n    /// Successful vouches (vouchee reached 50%+)\r\n    pub successful_vouches: u32,\r\n    /// Failed vouches (vouchee banned/inactive)\r\n    pub failed_vouches: u32,\r\n    /// Vouch accuracy (0-10000)\r\n    pub vouch_accuracy: u16,\r\n    /// Current active vouches\r\n    pub vouches_active: u8,\r\n    /// Max concurrent vouches (based on 5A score)\r\n    pub max_concurrent_vouches: u8,\r\n    /// Total rewards earned\r\n    pub total_rewards_earned: u64,\r\n    /// Total stake lost\r\n    pub total_stake_lost: u64,\r\n    /// PDA bump\r\n    pub bump: u8,\r\n}\r\n\r\nimpl VoucherStats {\r\n    pub const LEN: usize = 8 + // discriminator\r\n        32 + // user\r\n        4 +  // total_vouches_given\r\n        4 +  // successful_vouches\r\n        4 +  // failed_vouches\r\n        2 +  // vouch_accuracy\r\n        1 +  // vouches_active\r\n        1 +  // max_concurrent_vouches\r\n        8 +  // total_rewards_earned\r\n        8 +  // total_stake_lost\r\n        1;   // bump\r\n    \r\n    /// Calculate max vouches based on 5A score\r\n    pub fn max_vouches_for_score(score: u16) -\u003e u8 {\r\n        if score \u003e= 9000 { 10 }\r\n        else if score \u003e= 8000 { 8 }\r\n        else if score \u003e= 7000 { 5 }\r\n        else if score \u003e= 6000 { 3 }\r\n        else { 0 }\r\n    }\r\n}\r\n\r\n","traces":[{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":6},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","five-a-protocol","src","tests.rs"],"content":"//! Unit tests for 5A Protocol\r\n//! \r\n//! These tests run against the ACTUAL program code.\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n    use crate::constants::*;\r\n    use crate::state::UserScore;\r\n    use anchor_lang::prelude::Pubkey;\r\n\r\n    // ========================================================================\r\n    // Weight Constants Tests\r\n    // ========================================================================\r\n\r\n    #[test]\r\n    fn test_weights_sum_to_100_percent() {\r\n        let total = AUTHENTICITY_WEIGHT + ACCURACY_WEIGHT + AGILITY_WEIGHT + \r\n                   ACTIVITY_WEIGHT + APPROVED_WEIGHT;\r\n        assert_eq!(total, 10000, \"Weights should sum to 10000 (100%)\");\r\n    }\r\n\r\n    #[test]\r\n    fn test_individual_weights() {\r\n        assert_eq!(AUTHENTICITY_WEIGHT, 2500);  // 25%\r\n        assert_eq!(ACCURACY_WEIGHT, 2000);      // 20%\r\n        assert_eq!(AGILITY_WEIGHT, 1500);       // 15%\r\n        assert_eq!(ACTIVITY_WEIGHT, 2500);      // 25%\r\n        assert_eq!(APPROVED_WEIGHT, 1500);      // 15%\r\n    }\r\n\r\n    // ========================================================================\r\n    // Vouch System Constants Tests\r\n    // ========================================================================\r\n\r\n    #[test]\r\n    fn test_vouch_constants() {\r\n        assert_eq!(MIN_VOUCHER_SCORE, 6000, \"Min voucher score should be 60%\");\r\n        assert_eq!(VOUCH_STAKE_AMOUNT, 5_000_000_000, \"Vouch stake should be 5 VCoin\");\r\n        assert_eq!(VOUCHES_REQUIRED, 3, \"Should require 3 vouches\");\r\n        assert_eq!(VOUCH_EVALUATION_PERIOD, 90 * 24 * 60 * 60, \"90 days in seconds\");\r\n        assert_eq!(VOUCH_REWARD, 10_000_000_000, \"Vouch reward should be 10 VCoin\");\r\n    }\r\n\r\n    #[test]\r\n    fn test_snapshot_interval() {\r\n        assert_eq!(SNAPSHOT_INTERVAL, 24 * 60 * 60, \"Daily snapshot = 86400 seconds\");\r\n    }\r\n\r\n    // ========================================================================\r\n    // UserScore Tests\r\n    // ========================================================================\r\n\r\n    fn create_test_score(a: u16, b: u16, c: u16, d: u16, e: u16) -\u003e UserScore {\r\n        UserScore {\r\n            user: Pubkey::new_unique(),\r\n            authenticity: a,\r\n            accuracy: b,\r\n            agility: c,\r\n            activity: d,\r\n            approved: e,\r\n            composite_score: 0,\r\n            last_updated: 0,\r\n            last_snapshot_epoch: 0,\r\n            update_count: 0,\r\n            is_private: false,\r\n            bump: 0,\r\n        }\r\n    }\r\n\r\n    #[test]\r\n    fn test_composite_perfect_score() {\r\n        let score = create_test_score(10000, 10000, 10000, 10000, 10000);\r\n        assert_eq!(score.calculate_composite(), 10000);\r\n    }\r\n\r\n    #[test]\r\n    fn test_composite_zero_score() {\r\n        let score = create_test_score(0, 0, 0, 0, 0);\r\n        assert_eq!(score.calculate_composite(), 0);\r\n    }\r\n\r\n    #[test]\r\n    fn test_composite_average_score() {\r\n        let score = create_test_score(5000, 5000, 5000, 5000, 5000);\r\n        assert_eq!(score.calculate_composite(), 5000);\r\n    }\r\n\r\n    #[test]\r\n    fn test_composite_mixed_scores() {\r\n        // Auth=8000, Acc=6000, Agi=4000, Act=10000, App=2000\r\n        // Weighted = (8000*2500 + 6000*2000 + 4000*1500 + 10000*2500 + 2000*1500) / 10000\r\n        //          = (20000000 + 12000000 + 6000000 + 25000000 + 3000000) / 10000\r\n        //          = 66000000 / 10000 = 6600\r\n        let score = create_test_score(8000, 6000, 4000, 10000, 2000);\r\n        assert_eq!(score.calculate_composite(), 6600);\r\n    }\r\n\r\n    #[test]\r\n    fn test_composite_weighted_properly() {\r\n        // Test that higher weighted dimensions have more impact\r\n        \r\n        // High authenticity (25% weight) vs low approved (15% weight)\r\n        let high_auth = create_test_score(10000, 0, 0, 0, 0);\r\n        let high_app = create_test_score(0, 0, 0, 0, 10000);\r\n        \r\n        assert_eq!(high_auth.calculate_composite(), 2500); // 10000 * 0.25\r\n        assert_eq!(high_app.calculate_composite(), 1500);  // 10000 * 0.15\r\n        \r\n        // Auth should contribute more than Approved\r\n        assert!(high_auth.calculate_composite() \u003e high_app.calculate_composite());\r\n    }\r\n\r\n    #[test]\r\n    fn test_composite_activity_and_authenticity_equal_weight() {\r\n        // Both are 25%\r\n        let high_auth = create_test_score(10000, 0, 0, 0, 0);\r\n        let high_act = create_test_score(0, 0, 0, 10000, 0);\r\n        \r\n        assert_eq!(high_auth.calculate_composite(), high_act.calculate_composite());\r\n    }\r\n\r\n    #[test]\r\n    fn test_composite_agility_and_approved_equal_weight() {\r\n        // Both are 15%\r\n        let high_agi = create_test_score(0, 0, 10000, 0, 0);\r\n        let high_app = create_test_score(0, 0, 0, 0, 10000);\r\n        \r\n        assert_eq!(high_agi.calculate_composite(), high_app.calculate_composite());\r\n    }\r\n\r\n    // ========================================================================\r\n    // Boundary Tests\r\n    // ========================================================================\r\n\r\n    #[test]\r\n    fn test_composite_no_overflow() {\r\n        // Max values shouldn't overflow u32 multiplication\r\n        let max_score = create_test_score(10000, 10000, 10000, 10000, 10000);\r\n        \r\n        // Max calculation: 10000 * 10000 = 100_000_000 per dimension\r\n        // Total: 5 * 100_000_000 = 500_000_000\r\n        // Fits easily in u32\r\n        let composite = max_score.calculate_composite();\r\n        assert!(composite \u003c= 10000);\r\n    }\r\n\r\n    #[test]\r\n    fn test_score_bounds() {\r\n        // Scores should be 0-10000\r\n        for i in [0u16, 1, 5000, 9999, 10000] {\r\n            let score = create_test_score(i, i, i, i, i);\r\n            let composite = score.calculate_composite();\r\n            assert!(composite \u003c= 10000, \"Composite should not exceed 10000\");\r\n            assert_eq!(composite, i, \"With all same scores, composite equals individual\");\r\n        }\r\n    }\r\n\r\n    // ========================================================================\r\n    // Vouch Eligibility Tests\r\n    // ========================================================================\r\n\r\n    #[test]\r\n    fn test_vouch_eligibility_threshold() {\r\n        // User needs 60% (6000) to vouch\r\n        let eligible_score = create_test_score(6000, 6000, 6000, 6000, 6000);\r\n        let ineligible_score = create_test_score(5999, 5999, 5999, 5999, 5999);\r\n        \r\n        assert!(eligible_score.calculate_composite() \u003e= MIN_VOUCHER_SCORE);\r\n        assert!(ineligible_score.calculate_composite() \u003c MIN_VOUCHER_SCORE);\r\n    }\r\n\r\n    // ========================================================================\r\n    // Account Size Tests\r\n    // ========================================================================\r\n\r\n    #[test]\r\n    fn test_user_score_size() {\r\n        // Verify the account size calculation is correct\r\n        let expected_size = 8 + 32 + 2 + 2 + 2 + 2 + 2 + 2 + 8 + 8 + 4 + 1 + 1;\r\n        assert_eq!(UserScore::LEN, expected_size);\r\n    }\r\n}\r\n\r\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","five-a-protocol","tests","admin.rs"],"content":"//! Integration tests for five-a-protocol admin instructions\r\n\r\nmod common;\r\n\r\nuse common::*;\r\nuse solana_sdk::signature::{Keypair, Signer};\r\n\r\n#[tokio::test]\r\nasync fn test_set_paused_true() {\r\n    let mut ctx = TestContext::new().await;\r\n    \r\n    let (config_pda, _bump) = ctx.get_config_pda();\r\n    let identity_program = Keypair::new();\r\n    let vcoin_mint = Keypair::new();\r\n    \r\n    let init_ix = create_initialize_ix(\r\n        \u0026ctx.program_id,\r\n        \u0026ctx.payer.pubkey(),\r\n        \u0026config_pda,\r\n        \u0026identity_program.pubkey(),\r\n        \u0026vcoin_mint.pubkey(),\r\n    );\r\n    \r\n    ctx.process_transaction(\u0026[init_ix], \u0026[]).await.unwrap();\r\n    \r\n    let pause_ix = create_set_paused_ix(\r\n        \u0026ctx.program_id,\r\n        \u0026ctx.payer.pubkey(),\r\n        \u0026config_pda,\r\n        true,\r\n    );\r\n    \r\n    let result = ctx.process_transaction(\u0026[pause_ix], \u0026[]).await;\r\n    assert!(result.is_ok());\r\n}\r\n\r\n#[tokio::test]\r\nasync fn test_set_paused_false() {\r\n    let mut ctx = TestContext::new().await;\r\n    \r\n    let (config_pda, _bump) = ctx.get_config_pda();\r\n    let identity_program = Keypair::new();\r\n    let vcoin_mint = Keypair::new();\r\n    \r\n    let init_ix = create_initialize_ix(\r\n        \u0026ctx.program_id,\r\n        \u0026ctx.payer.pubkey(),\r\n        \u0026config_pda,\r\n        \u0026identity_program.pubkey(),\r\n        \u0026vcoin_mint.pubkey(),\r\n    );\r\n    \r\n    ctx.process_transaction(\u0026[init_ix], \u0026[]).await.unwrap();\r\n    \r\n    let pause_ix = create_set_paused_ix(\u0026ctx.program_id, \u0026ctx.payer.pubkey(), \u0026config_pda, true);\r\n    ctx.process_transaction(\u0026[pause_ix], \u0026[]).await.unwrap();\r\n    \r\n    let unpause_ix = create_set_paused_ix(\u0026ctx.program_id, \u0026ctx.payer.pubkey(), \u0026config_pda, false);\r\n    let result = ctx.process_transaction(\u0026[unpause_ix], \u0026[]).await;\r\n    assert!(result.is_ok());\r\n}\r\n\r\n#[tokio::test]\r\nasync fn test_set_paused_unauthorized() {\r\n    let mut ctx = TestContext::new().await;\r\n    \r\n    let (config_pda, _bump) = ctx.get_config_pda();\r\n    let identity_program = Keypair::new();\r\n    let vcoin_mint = Keypair::new();\r\n    \r\n    let init_ix = create_initialize_ix(\r\n        \u0026ctx.program_id,\r\n        \u0026ctx.payer.pubkey(),\r\n        \u0026config_pda,\r\n        \u0026identity_program.pubkey(),\r\n        \u0026vcoin_mint.pubkey(),\r\n    );\r\n    \r\n    ctx.process_transaction(\u0026[init_ix], \u0026[]).await.unwrap();\r\n    \r\n    let unauthorized = Keypair::new();\r\n    let pause_ix = create_set_paused_ix(\r\n        \u0026ctx.program_id,\r\n        \u0026unauthorized.pubkey(),\r\n        \u0026config_pda,\r\n        true,\r\n    );\r\n    \r\n    assert_eq!(pause_ix.accounts[0].pubkey, unauthorized.pubkey());\r\n}\r\n\r\n#[tokio::test]\r\nasync fn test_set_paused_toggle_multiple() {\r\n    let mut ctx = TestContext::new().await;\r\n    \r\n    let (config_pda, _bump) = ctx.get_config_pda();\r\n    let identity_program = Keypair::new();\r\n    let vcoin_mint = Keypair::new();\r\n    \r\n    let init_ix = create_initialize_ix(\r\n        \u0026ctx.program_id,\r\n        \u0026ctx.payer.pubkey(),\r\n        \u0026config_pda,\r\n        \u0026identity_program.pubkey(),\r\n        \u0026vcoin_mint.pubkey(),\r\n    );\r\n    \r\n    ctx.process_transaction(\u0026[init_ix], \u0026[]).await.unwrap();\r\n    \r\n    for paused in [true, false, true, false] {\r\n        let ix = create_set_paused_ix(\u0026ctx.program_id, \u0026ctx.payer.pubkey(), \u0026config_pda, paused);\r\n        let result = ctx.process_transaction(\u0026[ix], \u0026[]).await;\r\n        assert!(result.is_ok());\r\n    }\r\n}\r\n\r\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","five-a-protocol","tests","common","mod.rs"],"content":"//! Common test utilities for five-a-protocol integration tests\r\n\r\nuse anchor_lang::prelude::*;\r\nuse solana_program_test::*;\r\nuse solana_sdk::{\r\n    account::Account,\r\n    hash::Hash,\r\n    instruction::{AccountMeta, Instruction},\r\n    pubkey::Pubkey,\r\n    signature::{Keypair, Signer},\r\n    system_instruction,\r\n    transaction::Transaction,\r\n};\r\n\r\npub const FIVE_A_CONFIG_SEED: \u0026[u8] = b\"five-a-config\";\r\npub const USER_SCORE_SEED: \u0026[u8] = b\"user-score\";\r\npub const ORACLE_SEED: \u0026[u8] = b\"oracle\";\r\npub const VOUCH_RECORD_SEED: \u0026[u8] = b\"vouch-record\";\r\n\r\npub struct TestContext {\r\n    pub banks_client: BanksClient,\r\n    pub payer: Keypair,\r\n    pub recent_blockhash: Hash,\r\n    pub program_id: Pubkey,\r\n}\r\n\r\nimpl TestContext {\r\n    pub async fn new() -\u003e Self {\r\n        let program_id = five_a_protocol::id();\r\n        let program_test = ProgramTest::new(\r\n            \"five_a_protocol\",\r\n            program_id,\r\n            processor!(five_a_protocol::entry),\r\n        );\r\n\r\n        let (banks_client, payer, recent_blockhash) = program_test.start().await;\r\n\r\n        Self {\r\n            banks_client,\r\n            payer,\r\n            recent_blockhash,\r\n            program_id,\r\n        }\r\n    }\r\n\r\n    pub async fn refresh_blockhash(\u0026mut self) {\r\n        self.recent_blockhash = self.banks_client.get_latest_blockhash().await.unwrap();\r\n    }\r\n\r\n    pub async fn get_account(\u0026mut self, pubkey: Pubkey) -\u003e Option\u003cAccount\u003e {\r\n        self.banks_client.get_account(pubkey).await.unwrap()\r\n    }\r\n\r\n    pub fn get_config_pda(\u0026self) -\u003e (Pubkey, u8) {\r\n        Pubkey::find_program_address(\u0026[FIVE_A_CONFIG_SEED], \u0026self.program_id)\r\n    }\r\n\r\n    pub fn get_user_score_pda(\u0026self, user: \u0026Pubkey) -\u003e (Pubkey, u8) {\r\n        Pubkey::find_program_address(\u0026[USER_SCORE_SEED, user.as_ref()], \u0026self.program_id)\r\n    }\r\n\r\n    pub fn get_oracle_pda(\u0026self, oracle: \u0026Pubkey) -\u003e (Pubkey, u8) {\r\n        Pubkey::find_program_address(\u0026[ORACLE_SEED, oracle.as_ref()], \u0026self.program_id)\r\n    }\r\n\r\n    pub async fn process_transaction(\r\n        \u0026mut self,\r\n        instructions: \u0026[Instruction],\r\n        signers: \u0026[\u0026Keypair],\r\n    ) -\u003e Result\u003c(), BanksClientError\u003e {\r\n        let mut all_signers = vec![\u0026self.payer];\r\n        all_signers.extend(signers);\r\n        \r\n        let tx = Transaction::new_signed_with_payer(\r\n            instructions,\r\n            Some(\u0026self.payer.pubkey()),\r\n            \u0026all_signers,\r\n            self.recent_blockhash,\r\n        );\r\n        \r\n        let result = self.banks_client.process_transaction(tx).await;\r\n        self.refresh_blockhash().await;\r\n        result\r\n    }\r\n}\r\n\r\npub fn create_initialize_ix(\r\n    program_id: \u0026Pubkey,\r\n    authority: \u0026Pubkey,\r\n    config: \u0026Pubkey,\r\n    identity_program: \u0026Pubkey,\r\n    vcoin_mint: \u0026Pubkey,\r\n) -\u003e Instruction {\r\n    let mut data = vec![0u8; 8 + 32 + 32];\r\n    let discriminator = anchor_lang::solana_program::hash::hash(b\"global:initialize\").to_bytes();\r\n    data[..8].copy_from_slice(\u0026discriminator[..8]);\r\n    data[8..40].copy_from_slice(identity_program.as_ref());\r\n    data[40..72].copy_from_slice(vcoin_mint.as_ref());\r\n\r\n    Instruction {\r\n        program_id: *program_id,\r\n        accounts: vec![\r\n            AccountMeta::new(*authority, true),\r\n            AccountMeta::new(*config, false),\r\n            AccountMeta::new_readonly(solana_sdk::system_program::id(), false),\r\n        ],\r\n        data,\r\n    }\r\n}\r\n\r\npub fn create_register_oracle_ix(\r\n    program_id: \u0026Pubkey,\r\n    authority: \u0026Pubkey,\r\n    config: \u0026Pubkey,\r\n    oracle_account: \u0026Pubkey,\r\n    oracle_pda: \u0026Pubkey,\r\n    name: \u0026str,\r\n) -\u003e Instruction {\r\n    let name_bytes = name.as_bytes();\r\n    let mut data = vec![0u8; 8 + 4 + name_bytes.len()];\r\n    let discriminator = anchor_lang::solana_program::hash::hash(b\"global:register_oracle\").to_bytes();\r\n    data[..8].copy_from_slice(\u0026discriminator[..8]);\r\n    data[8..12].copy_from_slice(\u0026(name_bytes.len() as u32).to_le_bytes());\r\n    data[12..].copy_from_slice(name_bytes);\r\n\r\n    Instruction {\r\n        program_id: *program_id,\r\n        accounts: vec![\r\n            AccountMeta::new(*authority, true),\r\n            AccountMeta::new_readonly(*config, false),\r\n            AccountMeta::new_readonly(*oracle_account, false),\r\n            AccountMeta::new(*oracle_pda, false),\r\n            AccountMeta::new_readonly(solana_sdk::system_program::id(), false),\r\n        ],\r\n        data,\r\n    }\r\n}\r\n\r\npub fn create_submit_score_ix(\r\n    program_id: \u0026Pubkey,\r\n    oracle: \u0026Pubkey,\r\n    config: \u0026Pubkey,\r\n    user_score: \u0026Pubkey,\r\n    authenticity: u16,\r\n    accuracy: u16,\r\n    agility: u16,\r\n    activity: u16,\r\n    approved: u16,\r\n) -\u003e Instruction {\r\n    let mut data = vec![0u8; 8 + 5 * 2];\r\n    let discriminator = anchor_lang::solana_program::hash::hash(b\"global:submit_score\").to_bytes();\r\n    data[..8].copy_from_slice(\u0026discriminator[..8]);\r\n    data[8..10].copy_from_slice(\u0026authenticity.to_le_bytes());\r\n    data[10..12].copy_from_slice(\u0026accuracy.to_le_bytes());\r\n    data[12..14].copy_from_slice(\u0026agility.to_le_bytes());\r\n    data[14..16].copy_from_slice(\u0026activity.to_le_bytes());\r\n    data[16..18].copy_from_slice(\u0026approved.to_le_bytes());\r\n\r\n    Instruction {\r\n        program_id: *program_id,\r\n        accounts: vec![\r\n            AccountMeta::new(*oracle, true),\r\n            AccountMeta::new_readonly(*config, false),\r\n            AccountMeta::new(*user_score, false),\r\n        ],\r\n        data,\r\n    }\r\n}\r\n\r\npub fn create_vouch_for_user_ix(\r\n    program_id: \u0026Pubkey,\r\n    voucher: \u0026Pubkey,\r\n    vouchee: \u0026Pubkey,\r\n    config: \u0026Pubkey,\r\n) -\u003e Instruction {\r\n    let mut data = vec![0u8; 8];\r\n    let discriminator = anchor_lang::solana_program::hash::hash(b\"global:vouch_for_user\").to_bytes();\r\n    data[..8].copy_from_slice(\u0026discriminator[..8]);\r\n\r\n    Instruction {\r\n        program_id: *program_id,\r\n        accounts: vec![\r\n            AccountMeta::new(*voucher, true),\r\n            AccountMeta::new_readonly(*vouchee, false),\r\n            AccountMeta::new_readonly(*config, false),\r\n            AccountMeta::new_readonly(solana_sdk::system_program::id(), false),\r\n        ],\r\n        data,\r\n    }\r\n}\r\n\r\npub fn create_set_paused_ix(\r\n    program_id: \u0026Pubkey,\r\n    authority: \u0026Pubkey,\r\n    config: \u0026Pubkey,\r\n    paused: bool,\r\n) -\u003e Instruction {\r\n    let mut data = vec![0u8; 8 + 1];\r\n    let discriminator = anchor_lang::solana_program::hash::hash(b\"global:set_paused\").to_bytes();\r\n    data[..8].copy_from_slice(\u0026discriminator[..8]);\r\n    data[8] = if paused { 1 } else { 0 };\r\n\r\n    Instruction {\r\n        program_id: *program_id,\r\n        accounts: vec![\r\n            AccountMeta::new(*authority, true),\r\n            AccountMeta::new(*config, false),\r\n        ],\r\n        data,\r\n    }\r\n}\r\n\r\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","five-a-protocol","tests","initialize.rs"],"content":"//! Integration tests for five-a-protocol initialize instruction\r\n\r\nmod common;\r\n\r\nuse common::*;\r\nuse solana_sdk::signature::{Keypair, Signer};\r\n\r\n#[tokio::test]\r\nasync fn test_initialize_success() {\r\n    let mut ctx = TestContext::new().await;\r\n    \r\n    let (config_pda, _bump) = ctx.get_config_pda();\r\n    let identity_program = Keypair::new();\r\n    let vcoin_mint = Keypair::new();\r\n    \r\n    let ix = create_initialize_ix(\r\n        \u0026ctx.program_id,\r\n        \u0026ctx.payer.pubkey(),\r\n        \u0026config_pda,\r\n        \u0026identity_program.pubkey(),\r\n        \u0026vcoin_mint.pubkey(),\r\n    );\r\n    \r\n    let result = ctx.process_transaction(\u0026[ix], \u0026[]).await;\r\n    assert!(result.is_ok());\r\n    \r\n    let config = ctx.get_account(config_pda).await;\r\n    assert!(config.is_some());\r\n}\r\n\r\n#[tokio::test]\r\nasync fn test_initialize_already_initialized() {\r\n    let mut ctx = TestContext::new().await;\r\n    \r\n    let (config_pda, _bump) = ctx.get_config_pda();\r\n    let identity_program = Keypair::new();\r\n    let vcoin_mint = Keypair::new();\r\n    \r\n    let ix = create_initialize_ix(\r\n        \u0026ctx.program_id,\r\n        \u0026ctx.payer.pubkey(),\r\n        \u0026config_pda,\r\n        \u0026identity_program.pubkey(),\r\n        \u0026vcoin_mint.pubkey(),\r\n    );\r\n    \r\n    ctx.process_transaction(\u0026[ix.clone()], \u0026[]).await.unwrap();\r\n    \r\n    let result = ctx.process_transaction(\u0026[ix], \u0026[]).await;\r\n    assert!(result.is_err());\r\n}\r\n\r\n#[tokio::test]\r\nasync fn test_initialize_with_programs() {\r\n    let mut ctx = TestContext::new().await;\r\n    \r\n    let (config_pda, _bump) = ctx.get_config_pda();\r\n    let identity_program = Keypair::new();\r\n    let vcoin_mint = Keypair::new();\r\n    \r\n    let ix = create_initialize_ix(\r\n        \u0026ctx.program_id,\r\n        \u0026ctx.payer.pubkey(),\r\n        \u0026config_pda,\r\n        \u0026identity_program.pubkey(),\r\n        \u0026vcoin_mint.pubkey(),\r\n    );\r\n    \r\n    let result = ctx.process_transaction(\u0026[ix], \u0026[]).await;\r\n    assert!(result.is_ok());\r\n}\r\n\r\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","five-a-protocol","tests","oracle.rs"],"content":"//! Integration tests for five-a-protocol oracle instructions\r\n\r\nmod common;\r\n\r\nuse common::*;\r\nuse solana_sdk::signature::{Keypair, Signer};\r\n\r\n#[tokio::test]\r\nasync fn test_register_oracle_instruction_format() {\r\n    let ctx = TestContext::new().await;\r\n    \r\n    let (config_pda, _bump) = ctx.get_config_pda();\r\n    let oracle = Keypair::new();\r\n    let (oracle_pda, _) = ctx.get_oracle_pda(\u0026oracle.pubkey());\r\n    \r\n    let ix = create_register_oracle_ix(\r\n        \u0026ctx.program_id,\r\n        \u0026ctx.payer.pubkey(),\r\n        \u0026config_pda,\r\n        \u0026oracle.pubkey(),\r\n        \u0026oracle_pda,\r\n        \"TestOracle\",\r\n    );\r\n    \r\n    assert_eq!(ix.program_id, ctx.program_id);\r\n    assert_eq!(ix.accounts.len(), 5);\r\n}\r\n\r\n#[tokio::test]\r\nasync fn test_register_oracle_short_name() {\r\n    let ctx = TestContext::new().await;\r\n    \r\n    let (config_pda, _bump) = ctx.get_config_pda();\r\n    let oracle = Keypair::new();\r\n    let (oracle_pda, _) = ctx.get_oracle_pda(\u0026oracle.pubkey());\r\n    \r\n    let ix = create_register_oracle_ix(\r\n        \u0026ctx.program_id,\r\n        \u0026ctx.payer.pubkey(),\r\n        \u0026config_pda,\r\n        \u0026oracle.pubkey(),\r\n        \u0026oracle_pda,\r\n        \"A\",\r\n    );\r\n    \r\n    assert!(ix.data.len() \u003e 8);\r\n}\r\n\r\n#[tokio::test]\r\nasync fn test_register_oracle_long_name() {\r\n    let ctx = TestContext::new().await;\r\n    \r\n    let (config_pda, _bump) = ctx.get_config_pda();\r\n    let oracle = Keypair::new();\r\n    let (oracle_pda, _) = ctx.get_oracle_pda(\u0026oracle.pubkey());\r\n    \r\n    let long_name = \"VeryLongOracleNameThatIsQuiteLong\";\r\n    let ix = create_register_oracle_ix(\r\n        \u0026ctx.program_id,\r\n        \u0026ctx.payer.pubkey(),\r\n        \u0026config_pda,\r\n        \u0026oracle.pubkey(),\r\n        \u0026oracle_pda,\r\n        long_name,\r\n    );\r\n    \r\n    assert!(ix.data.len() \u003e 8 + 4);\r\n}\r\n\r\n#[tokio::test]\r\nasync fn test_submit_score_instruction_format() {\r\n    let ctx = TestContext::new().await;\r\n    \r\n    let (config_pda, _bump) = ctx.get_config_pda();\r\n    let oracle = Keypair::new();\r\n    let user = Keypair::new();\r\n    let (user_score_pda, _) = ctx.get_user_score_pda(\u0026user.pubkey());\r\n    \r\n    let ix = create_submit_score_ix(\r\n        \u0026ctx.program_id,\r\n        \u0026oracle.pubkey(),\r\n        \u0026config_pda,\r\n        \u0026user_score_pda,\r\n        8000, // authenticity\r\n        7500, // accuracy\r\n        8500, // agility\r\n        9000, // activity\r\n        7000, // approved\r\n    );\r\n    \r\n    assert_eq!(ix.program_id, ctx.program_id);\r\n    assert_eq!(ix.accounts.len(), 3);\r\n    assert!(ix.accounts[0].is_signer);\r\n}\r\n\r\n#[tokio::test]\r\nasync fn test_submit_score_max_values() {\r\n    let ctx = TestContext::new().await;\r\n    \r\n    let (config_pda, _bump) = ctx.get_config_pda();\r\n    let oracle = Keypair::new();\r\n    let user = Keypair::new();\r\n    let (user_score_pda, _) = ctx.get_user_score_pda(\u0026user.pubkey());\r\n    \r\n    let ix = create_submit_score_ix(\r\n        \u0026ctx.program_id,\r\n        \u0026oracle.pubkey(),\r\n        \u0026config_pda,\r\n        \u0026user_score_pda,\r\n        10000, // max\r\n        10000,\r\n        10000,\r\n        10000,\r\n        10000,\r\n    );\r\n    \r\n    assert_eq!(\u0026ix.data[8..10], \u002610000u16.to_le_bytes());\r\n}\r\n\r\n#[tokio::test]\r\nasync fn test_submit_score_zero_values() {\r\n    let ctx = TestContext::new().await;\r\n    \r\n    let (config_pda, _bump) = ctx.get_config_pda();\r\n    let oracle = Keypair::new();\r\n    let user = Keypair::new();\r\n    let (user_score_pda, _) = ctx.get_user_score_pda(\u0026user.pubkey());\r\n    \r\n    let ix = create_submit_score_ix(\r\n        \u0026ctx.program_id,\r\n        \u0026oracle.pubkey(),\r\n        \u0026config_pda,\r\n        \u0026user_score_pda,\r\n        0, 0, 0, 0, 0,\r\n    );\r\n    \r\n    assert_eq!(\u0026ix.data[8..10], \u00260u16.to_le_bytes());\r\n}\r\n\r\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","five-a-protocol","tests","vouch.rs"],"content":"//! Integration tests for five-a-protocol vouch instructions\r\n\r\nmod common;\r\n\r\nuse common::*;\r\nuse solana_sdk::signature::{Keypair, Signer};\r\n\r\n#[tokio::test]\r\nasync fn test_vouch_for_user_instruction_format() {\r\n    let ctx = TestContext::new().await;\r\n    \r\n    let (config_pda, _bump) = ctx.get_config_pda();\r\n    let voucher = Keypair::new();\r\n    let vouchee = Keypair::new();\r\n    \r\n    let ix = create_vouch_for_user_ix(\r\n        \u0026ctx.program_id,\r\n        \u0026voucher.pubkey(),\r\n        \u0026vouchee.pubkey(),\r\n        \u0026config_pda,\r\n    );\r\n    \r\n    assert_eq!(ix.program_id, ctx.program_id);\r\n    assert_eq!(ix.accounts.len(), 4);\r\n    assert!(ix.accounts[0].is_signer);\r\n}\r\n\r\n#[tokio::test]\r\nasync fn test_vouch_different_voucher_vouchee() {\r\n    let ctx = TestContext::new().await;\r\n    \r\n    let (config_pda, _bump) = ctx.get_config_pda();\r\n    let voucher = Keypair::new();\r\n    let vouchee = Keypair::new();\r\n    \r\n    let ix = create_vouch_for_user_ix(\r\n        \u0026ctx.program_id,\r\n        \u0026voucher.pubkey(),\r\n        \u0026vouchee.pubkey(),\r\n        \u0026config_pda,\r\n    );\r\n    \r\n    assert_ne!(ix.accounts[0].pubkey, ix.accounts[1].pubkey);\r\n}\r\n\r\n#[tokio::test]\r\nasync fn test_vouch_same_voucher_vouchee() {\r\n    let ctx = TestContext::new().await;\r\n    \r\n    let (config_pda, _bump) = ctx.get_config_pda();\r\n    let same_user = Keypair::new();\r\n    \r\n    let ix = create_vouch_for_user_ix(\r\n        \u0026ctx.program_id,\r\n        \u0026same_user.pubkey(),\r\n        \u0026same_user.pubkey(),\r\n        \u0026config_pda,\r\n    );\r\n    \r\n    assert_eq!(ix.accounts[0].pubkey, ix.accounts[1].pubkey);\r\n}\r\n\r\n#[tokio::test]\r\nasync fn test_vouch_multiple_vouchers() {\r\n    let ctx = TestContext::new().await;\r\n    \r\n    let (config_pda, _bump) = ctx.get_config_pda();\r\n    let vouchee = Keypair::new();\r\n    \r\n    for _ in 0..3 {\r\n        let voucher = Keypair::new();\r\n        let ix = create_vouch_for_user_ix(\r\n            \u0026ctx.program_id,\r\n            \u0026voucher.pubkey(),\r\n            \u0026vouchee.pubkey(),\r\n            \u0026config_pda,\r\n        );\r\n        \r\n        assert_eq!(ix.accounts[1].pubkey, vouchee.pubkey());\r\n    }\r\n}\r\n\r\n#[tokio::test]\r\nasync fn test_vouch_one_voucher_multiple_vouchees() {\r\n    let ctx = TestContext::new().await;\r\n    \r\n    let (config_pda, _bump) = ctx.get_config_pda();\r\n    let voucher = Keypair::new();\r\n    \r\n    for _ in 0..5 {\r\n        let vouchee = Keypair::new();\r\n        let ix = create_vouch_for_user_ix(\r\n            \u0026ctx.program_id,\r\n            \u0026voucher.pubkey(),\r\n            \u0026vouchee.pubkey(),\r\n            \u0026config_pda,\r\n        );\r\n        \r\n        assert_eq!(ix.accounts[0].pubkey, voucher.pubkey());\r\n    }\r\n}\r\n\r\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","gasless-protocol","src","constants.rs"],"content":"/// Seeds\r\npub const GASLESS_CONFIG_SEED: \u0026[u8] = b\"gasless-config\";\r\npub const SESSION_KEY_SEED: \u0026[u8] = b\"session-key\";\r\npub const USER_GASLESS_SEED: \u0026[u8] = b\"user-gasless\";\r\npub const FEE_VAULT_SEED: \u0026[u8] = b\"fee-vault\";\r\npub const DAILY_BUDGET_SEED: \u0026[u8] = b\"daily-budget\";\r\n\r\n/// Session configuration\r\npub const SESSION_DURATION: i64 = 24 * 60 * 60;   // 24 hours\r\npub const MAX_SESSION_ACTIONS: u32 = 1000;        // Max actions per session\r\npub const MAX_SESSION_SPEND: u64 = 100_000_000_000_000; // 100,000 VCoin max per session\r\n\r\n/// Fee configuration\r\npub const DEFAULT_SOL_FEE: u64 = 5_000;          // 0.000005 SOL per tx\r\npub const VCOIN_FEE_MULTIPLIER: u64 = 100;      // 100x VCoin equivalent\r\npub const SSCRE_DEDUCTION_BPS: u16 = 100;       // 1% from SSCRE claims\r\n\r\n/// Daily budget\r\npub const DAILY_SUBSIDY_BUDGET_SOL: u64 = 10_000_000_000; // 10 SOL per day\r\npub const MAX_SUBSIDIZED_TX_PER_USER: u32 = 50; // Max 50 free tx per user per day\r\n\r\n/// Action scope bits\r\npub const SCOPE_TIP: u16 = 1 \u003c\u003c 0;\r\npub const SCOPE_VOUCH: u16 = 1 \u003c\u003c 1;\r\npub const SCOPE_CONTENT: u16 = 1 \u003c\u003c 2;\r\npub const SCOPE_GOVERNANCE: u16 = 1 \u003c\u003c 3;\r\npub const SCOPE_TRANSFER: u16 = 1 \u003c\u003c 4;\r\npub const SCOPE_STAKE: u16 = 1 \u003c\u003c 5;\r\npub const SCOPE_CLAIM: u16 = 1 \u003c\u003c 6;\r\npub const SCOPE_FOLLOW: u16 = 1 \u003c\u003c 7;\r\npub const SCOPE_ALL: u16 = 0xFFFF;\r\n\r\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","gasless-protocol","src","contexts","create_session_key.rs"],"content":"use anchor_lang::prelude::*;\r\nuse crate::constants::*;\r\nuse crate::state::{GaslessConfig, SessionKey, UserGaslessStats};\r\n\r\n#[derive(Accounts)]\r\n#[instruction(session_pubkey: Pubkey)]\r\npub struct CreateSessionKey\u003c'info\u003e {\r\n    #[account(\r\n        seeds = [GASLESS_CONFIG_SEED],\r\n        bump = config.bump\r\n    )]\r\n    pub config: Account\u003c'info, GaslessConfig\u003e,\r\n    \r\n    #[account(\r\n        init,\r\n        payer = user,\r\n        space = SessionKey::LEN,\r\n        seeds = [SESSION_KEY_SEED, user.key().as_ref(), session_pubkey.as_ref()],\r\n        bump\r\n    )]\r\n    pub session_key: Account\u003c'info, SessionKey\u003e,\r\n    \r\n    #[account(\r\n        init_if_needed,\r\n        payer = user,\r\n        space = UserGaslessStats::LEN,\r\n        seeds = [USER_GASLESS_SEED, user.key().as_ref()],\r\n        bump\r\n    )]\r\n    pub user_stats: Account\u003c'info, UserGaslessStats\u003e,\r\n    \r\n    #[account(mut)]\r\n    pub user: Signer\u003c'info\u003e,\r\n    \r\n    pub system_program: Program\u003c'info, System\u003e,\r\n}\r\n\r\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","gasless-protocol","src","contexts","deduct_vcoin_fee.rs"],"content":"use anchor_lang::prelude::*;\r\nuse anchor_spl::token_2022::Token2022;\r\nuse anchor_spl::token_interface::{Mint, TokenAccount};\r\nuse crate::constants::*;\r\nuse crate::errors::GaslessError;\r\nuse crate::state::{GaslessConfig, UserGaslessStats};\r\n\r\n#[derive(Accounts)]\r\npub struct DeductVCoinFee\u003c'info\u003e {\r\n    #[account(\r\n        mut,\r\n        seeds = [GASLESS_CONFIG_SEED],\r\n        bump = config.bump\r\n    )]\r\n    pub config: Account\u003c'info, GaslessConfig\u003e,\r\n    \r\n    #[account(\r\n        init_if_needed,\r\n        payer = user,\r\n        space = UserGaslessStats::LEN,\r\n        seeds = [USER_GASLESS_SEED, user.key().as_ref()],\r\n        bump\r\n    )]\r\n    pub user_stats: Account\u003c'info, UserGaslessStats\u003e,\r\n    \r\n    #[account(constraint = vcoin_mint.key() == config.vcoin_mint @ GaslessError::InvalidMint)]\r\n    pub vcoin_mint: InterfaceAccount\u003c'info, Mint\u003e,\r\n    \r\n    /// User's VCoin account - MUST be owned by user and use VCoin mint\r\n    #[account(\r\n        mut,\r\n        constraint = user_token_account.owner == user.key() @ GaslessError::InvalidTokenAccount,\r\n        constraint = user_token_account.mint == config.vcoin_mint @ GaslessError::InvalidMint\r\n    )]\r\n    pub user_token_account: InterfaceAccount\u003c'info, TokenAccount\u003e,\r\n    \r\n    /// Fee vault - PDA owned vault with VCoin mint\r\n    #[account(\r\n        mut,\r\n        seeds = [FEE_VAULT_SEED],\r\n        bump,\r\n        constraint = fee_vault.mint == config.vcoin_mint @ GaslessError::InvalidMint\r\n    )]\r\n    pub fee_vault: InterfaceAccount\u003c'info, TokenAccount\u003e,\r\n    \r\n    #[account(mut)]\r\n    pub user: Signer\u003c'info\u003e,\r\n    \r\n    pub token_program: Program\u003c'info, Token2022\u003e,\r\n    pub system_program: Program\u003c'info, System\u003e,\r\n}\r\n\r\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","gasless-protocol","src","contexts","execute_session_action.rs"],"content":"use anchor_lang::prelude::*;\r\nuse crate::constants::*;\r\nuse crate::errors::GaslessError;\r\nuse crate::state::{GaslessConfig, SessionKey, UserGaslessStats};\r\n\r\n#[derive(Accounts)]\r\npub struct ExecuteSessionAction\u003c'info\u003e {\r\n    #[account(\r\n        mut,\r\n        seeds = [GASLESS_CONFIG_SEED],\r\n        bump = config.bump\r\n    )]\r\n    pub config: Account\u003c'info, GaslessConfig\u003e,\r\n    \r\n    #[account(\r\n        mut,\r\n        seeds = [SESSION_KEY_SEED, session_key.user.as_ref(), session_key.session_pubkey.as_ref()],\r\n        bump = session_key.bump,\r\n        constraint = session_key.user == user.key() @ GaslessError::Unauthorized\r\n    )]\r\n    pub session_key: Account\u003c'info, SessionKey\u003e,\r\n    \r\n    #[account(\r\n        mut,\r\n        seeds = [USER_GASLESS_SEED, user.key().as_ref()],\r\n        bump = user_stats.bump\r\n    )]\r\n    pub user_stats: Account\u003c'info, UserGaslessStats\u003e,\r\n    \r\n    pub user: Signer\u003c'info\u003e,\r\n}\r\n\r\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","gasless-protocol","src","contexts","get_config_stats.rs"],"content":"use anchor_lang::prelude::*;\r\nuse crate::constants::GASLESS_CONFIG_SEED;\r\nuse crate::state::GaslessConfig;\r\n\r\n#[derive(Accounts)]\r\npub struct GetConfigStats\u003c'info\u003e {\r\n    #[account(\r\n        seeds = [GASLESS_CONFIG_SEED],\r\n        bump = config.bump\r\n    )]\r\n    pub config: Account\u003c'info, GaslessConfig\u003e,\r\n}\r\n\r\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","gasless-protocol","src","contexts","get_session_info.rs"],"content":"use anchor_lang::prelude::*;\r\nuse crate::constants::SESSION_KEY_SEED;\r\nuse crate::state::SessionKey;\r\n\r\n#[derive(Accounts)]\r\npub struct GetSessionInfo\u003c'info\u003e {\r\n    #[account(\r\n        seeds = [SESSION_KEY_SEED, session_key.user.as_ref(), session_key.session_pubkey.as_ref()],\r\n        bump = session_key.bump\r\n    )]\r\n    pub session_key: Account\u003c'info, SessionKey\u003e,\r\n}\r\n\r\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","gasless-protocol","src","contexts","get_user_stats.rs"],"content":"use anchor_lang::prelude::*;\r\nuse crate::constants::USER_GASLESS_SEED;\r\nuse crate::state::UserGaslessStats;\r\n\r\n#[derive(Accounts)]\r\npub struct GetUserStats\u003c'info\u003e {\r\n    #[account(\r\n        seeds = [USER_GASLESS_SEED, user_stats.user.as_ref()],\r\n        bump = user_stats.bump\r\n    )]\r\n    pub user_stats: Account\u003c'info, UserGaslessStats\u003e,\r\n}\r\n\r\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","gasless-protocol","src","contexts","initialize.rs"],"content":"use anchor_lang::prelude::*;\r\nuse anchor_spl::token_2022::Token2022;\r\nuse anchor_spl::token_interface::{Mint, TokenAccount};\r\nuse crate::constants::*;\r\nuse crate::state::GaslessConfig;\r\n\r\n#[derive(Accounts)]\r\npub struct Initialize\u003c'info\u003e {\r\n    #[account(\r\n        init,\r\n        payer = authority,\r\n        space = GaslessConfig::LEN,\r\n        seeds = [GASLESS_CONFIG_SEED],\r\n        bump\r\n    )]\r\n    pub config: Account\u003c'info, GaslessConfig\u003e,\r\n    \r\n    pub vcoin_mint: InterfaceAccount\u003c'info, Mint\u003e,\r\n    \r\n    /// Fee vault for VCoin fees\r\n    #[account(\r\n        init,\r\n        payer = authority,\r\n        seeds = [FEE_VAULT_SEED],\r\n        bump,\r\n        token::mint = vcoin_mint,\r\n        token::authority = config,\r\n        token::token_program = token_program,\r\n    )]\r\n    pub fee_vault: InterfaceAccount\u003c'info, TokenAccount\u003e,\r\n    \r\n    #[account(mut)]\r\n    pub authority: Signer\u003c'info\u003e,\r\n    \r\n    pub token_program: Program\u003c'info, Token2022\u003e,\r\n    pub system_program: Program\u003c'info, System\u003e,\r\n}\r\n\r\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","gasless-protocol","src","contexts","mod.rs"],"content":"pub mod initialize;\r\npub mod create_session_key;\r\npub mod execute_session_action;\r\npub mod deduct_vcoin_fee;\r\npub mod revoke_session_key;\r\npub mod update_config;\r\npub mod update_authority;\r\npub mod get_session_info;\r\npub mod get_user_stats;\r\npub mod get_config_stats;\r\n\r\npub use initialize::*;\r\npub use create_session_key::*;\r\npub use execute_session_action::*;\r\npub use deduct_vcoin_fee::*;\r\npub use revoke_session_key::*;\r\npub use update_config::*;\r\npub use update_authority::*;\r\npub use get_session_info::*;\r\npub use get_user_stats::*;\r\npub use get_config_stats::*;\r\n\r\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","gasless-protocol","src","contexts","revoke_session_key.rs"],"content":"use anchor_lang::prelude::*;\r\nuse crate::constants::*;\r\nuse crate::errors::GaslessError;\r\nuse crate::state::{SessionKey, UserGaslessStats};\r\n\r\n#[derive(Accounts)]\r\npub struct RevokeSessionKey\u003c'info\u003e {\r\n    #[account(\r\n        mut,\r\n        seeds = [SESSION_KEY_SEED, session_key.user.as_ref(), session_key.session_pubkey.as_ref()],\r\n        bump = session_key.bump,\r\n        constraint = session_key.user == user.key() @ GaslessError::Unauthorized\r\n    )]\r\n    pub session_key: Account\u003c'info, SessionKey\u003e,\r\n    \r\n    #[account(\r\n        mut,\r\n        seeds = [USER_GASLESS_SEED, user.key().as_ref()],\r\n        bump = user_stats.bump\r\n    )]\r\n    pub user_stats: Account\u003c'info, UserGaslessStats\u003e,\r\n    \r\n    pub user: Signer\u003c'info\u003e,\r\n}\r\n\r\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","gasless-protocol","src","contexts","update_authority.rs"],"content":"use anchor_lang::prelude::*;\r\nuse crate::constants::GASLESS_CONFIG_SEED;\r\nuse crate::errors::GaslessError;\r\nuse crate::state::GaslessConfig;\r\n\r\n#[derive(Accounts)]\r\npub struct UpdateAuthority\u003c'info\u003e {\r\n    #[account(\r\n        mut,\r\n        seeds = [GASLESS_CONFIG_SEED],\r\n        bump = config.bump,\r\n        has_one = authority @ GaslessError::Unauthorized\r\n    )]\r\n    pub config: Account\u003c'info, GaslessConfig\u003e,\r\n    \r\n    pub authority: Signer\u003c'info\u003e,\r\n}\r\n\r\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","gasless-protocol","src","contexts","update_config.rs"],"content":"use anchor_lang::prelude::*;\r\nuse crate::constants::GASLESS_CONFIG_SEED;\r\nuse crate::errors::GaslessError;\r\nuse crate::state::GaslessConfig;\r\n\r\n#[derive(Accounts)]\r\npub struct UpdateConfig\u003c'info\u003e {\r\n    #[account(\r\n        mut,\r\n        seeds = [GASLESS_CONFIG_SEED],\r\n        bump = config.bump,\r\n        has_one = authority @ GaslessError::Unauthorized\r\n    )]\r\n    pub config: Account\u003c'info, GaslessConfig\u003e,\r\n    \r\n    pub authority: Signer\u003c'info\u003e,\r\n}\r\n\r\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","gasless-protocol","src","errors.rs"],"content":"use anchor_lang::prelude::*;\r\n\r\n#[error_code]\r\npub enum GaslessError {\r\n    #[msg(\"Unauthorized: Only the authority can perform this action\")]\r\n    Unauthorized,\r\n    #[msg(\"Gasless Protocol is paused\")]\r\n    ProtocolPaused,\r\n    #[msg(\"Session key expired\")]\r\n    SessionExpired,\r\n    #[msg(\"Session key revoked\")]\r\n    SessionRevoked,\r\n    #[msg(\"Action not in session scope\")]\r\n    ActionNotInScope,\r\n    #[msg(\"Session action limit exceeded\")]\r\n    SessionActionLimitExceeded,\r\n    #[msg(\"Session spend limit exceeded\")]\r\n    SessionSpendLimitExceeded,\r\n    #[msg(\"Daily subsidy budget exceeded\")]\r\n    DailyBudgetExceeded,\r\n    #[msg(\"User daily limit exceeded\")]\r\n    UserDailyLimitExceeded,\r\n    #[msg(\"Insufficient VCoin balance for fee\")]\r\n    InsufficientVCoinBalance,\r\n    #[msg(\"Invalid session key\")]\r\n    InvalidSessionKey,\r\n    #[msg(\"Session already exists\")]\r\n    SessionAlreadyExists,\r\n    #[msg(\"Fee deduction method not allowed\")]\r\n    FeeMethodNotAllowed,\r\n    #[msg(\"Invalid action type\")]\r\n    InvalidActionType,\r\n    #[msg(\"Arithmetic overflow\")]\r\n    Overflow,\r\n    #[msg(\"Invalid token account owner\")]\r\n    InvalidTokenAccount,\r\n    #[msg(\"Invalid token mint\")]\r\n    InvalidMint,\r\n}\r\n\r\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","gasless-protocol","src","events.rs"],"content":"use anchor_lang::prelude::*;\r\n\r\n#[event]\r\npub struct GaslessConfigInitialized {\r\n    pub authority: Pubkey,\r\n    pub fee_payer: Pubkey,\r\n    pub daily_budget: u64,\r\n}\r\n\r\n#[event]\r\npub struct SessionKeyCreated {\r\n    pub user: Pubkey,\r\n    pub session_pubkey: Pubkey,\r\n    pub scope: u16,\r\n    pub expires_at: i64,\r\n    pub fee_method: u8,\r\n}\r\n\r\n#[event]\r\npub struct SessionKeyRevoked {\r\n    pub user: Pubkey,\r\n    pub session_pubkey: Pubkey,\r\n    pub actions_used: u32,\r\n}\r\n\r\n#[event]\r\npub struct SessionActionExecuted {\r\n    pub user: Pubkey,\r\n    pub session_pubkey: Pubkey,\r\n    pub action_type: u16,\r\n    pub fee_method: u8,\r\n    pub fee_amount: u64,\r\n}\r\n\r\n#[event]\r\npub struct DailyBudgetReset {\r\n    pub day: u32,\r\n    pub previous_spent: u64,\r\n    pub new_budget: u64,\r\n}\r\n\r\n#[event]\r\npub struct FeeCollected {\r\n    pub user: Pubkey,\r\n    pub fee_method: u8,\r\n    pub amount: u64,\r\n    pub is_vcoin: bool,\r\n}\r\n\r\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","gasless-protocol","src","instructions","admin","initialize.rs"],"content":"use anchor_lang::prelude::*;\r\nuse crate::constants::*;\r\nuse crate::contexts::Initialize;\r\nuse crate::events::GaslessConfigInitialized;\r\nuse crate::state::GaslessConfig;\r\n\r\npub fn handler(\r\n    ctx: Context\u003cInitialize\u003e,\r\n    fee_payer: Pubkey,\r\n    daily_budget: u64,\r\n) -\u003e Result\u003c()\u003e {\r\n    let config = \u0026mut ctx.accounts.config;\r\n    \r\n    config.authority = ctx.accounts.authority.key();\r\n    config.fee_payer = fee_payer;\r\n    config.vcoin_mint = ctx.accounts.vcoin_mint.key();\r\n    config.fee_vault = ctx.accounts.fee_vault.key();\r\n    config.sscre_program = Pubkey::default();\r\n    config.daily_subsidy_budget = daily_budget;\r\n    config.sol_fee_per_tx = DEFAULT_SOL_FEE;\r\n    config.vcoin_fee_multiplier = VCOIN_FEE_MULTIPLIER;\r\n    config.sscre_deduction_bps = SSCRE_DEDUCTION_BPS;\r\n    config.max_subsidized_per_user = MAX_SUBSIDIZED_TX_PER_USER;\r\n    config.total_subsidized_tx = 0;\r\n    config.total_sol_spent = 0;\r\n    config.total_vcoin_collected = 0;\r\n    config.paused = false;\r\n    config.current_day = GaslessConfig::get_day_number(Clock::get()?.unix_timestamp);\r\n    config.day_spent = 0;\r\n    config.bump = ctx.bumps.config;\r\n    \r\n    emit!(GaslessConfigInitialized {\r\n        authority: config.authority,\r\n        fee_payer,\r\n        daily_budget,\r\n    });\r\n    \r\n    msg!(\"Gasless Protocol initialized with {} lamports daily budget\", daily_budget);\r\n    Ok(())\r\n}\r\n\r\n","traces":[{"line":7,"address":[],"length":0,"stats":{"Line":0}},{"line":12,"address":[],"length":0,"stats":{"Line":0}},{"line":14,"address":[],"length":0,"stats":{"Line":0}},{"line":15,"address":[],"length":0,"stats":{"Line":0}},{"line":16,"address":[],"length":0,"stats":{"Line":0}},{"line":17,"address":[],"length":0,"stats":{"Line":0}},{"line":18,"address":[],"length":0,"stats":{"Line":0}},{"line":19,"address":[],"length":0,"stats":{"Line":0}},{"line":20,"address":[],"length":0,"stats":{"Line":0}},{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":25},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","gasless-protocol","src","instructions","admin","mod.rs"],"content":"pub mod initialize;\r\npub mod update_fee_config;\r\npub mod update_daily_budget;\r\npub mod set_fee_payer;\r\npub mod set_sscre_program;\r\npub mod set_paused;\r\npub mod update_authority;\r\n\r\npub use initialize::*;\r\npub use update_fee_config::*;\r\npub use update_daily_budget::*;\r\npub use set_fee_payer::*;\r\npub use set_sscre_program::*;\r\npub use set_paused::*;\r\npub use update_authority::*;\r\n\r\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","gasless-protocol","src","instructions","admin","set_fee_payer.rs"],"content":"use anchor_lang::prelude::*;\r\nuse crate::contexts::UpdateConfig;\r\n\r\npub fn handler(ctx: Context\u003cUpdateConfig\u003e, new_fee_payer: Pubkey) -\u003e Result\u003c()\u003e {\r\n    ctx.accounts.config.fee_payer = new_fee_payer;\r\n    msg!(\"Fee payer updated to: {}\", new_fee_payer);\r\n    Ok(())\r\n}\r\n\r\n","traces":[{"line":4,"address":[],"length":0,"stats":{"Line":0}},{"line":5,"address":[],"length":0,"stats":{"Line":0}},{"line":6,"address":[],"length":0,"stats":{"Line":0}},{"line":7,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":4},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","gasless-protocol","src","instructions","admin","set_paused.rs"],"content":"use anchor_lang::prelude::*;\r\nuse crate::contexts::UpdateConfig;\r\n\r\npub fn handler(ctx: Context\u003cUpdateConfig\u003e, paused: bool) -\u003e Result\u003c()\u003e {\r\n    ctx.accounts.config.paused = paused;\r\n    msg!(\"Gasless Protocol paused: {}\", paused);\r\n    Ok(())\r\n}\r\n\r\n","traces":[{"line":4,"address":[],"length":0,"stats":{"Line":0}},{"line":5,"address":[],"length":0,"stats":{"Line":0}},{"line":6,"address":[],"length":0,"stats":{"Line":0}},{"line":7,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":4},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","gasless-protocol","src","instructions","admin","set_sscre_program.rs"],"content":"use anchor_lang::prelude::*;\r\nuse crate::contexts::UpdateConfig;\r\n\r\npub fn handler(ctx: Context\u003cUpdateConfig\u003e, sscre_program: Pubkey) -\u003e Result\u003c()\u003e {\r\n    ctx.accounts.config.sscre_program = sscre_program;\r\n    msg!(\"SSCRE program set to: {}\", sscre_program);\r\n    Ok(())\r\n}\r\n\r\n","traces":[{"line":4,"address":[],"length":0,"stats":{"Line":0}},{"line":5,"address":[],"length":0,"stats":{"Line":0}},{"line":6,"address":[],"length":0,"stats":{"Line":0}},{"line":7,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":4},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","gasless-protocol","src","instructions","admin","update_authority.rs"],"content":"use anchor_lang::prelude::*;\r\nuse crate::contexts::UpdateAuthority;\r\n\r\npub fn handler(ctx: Context\u003cUpdateAuthority\u003e, new_authority: Pubkey) -\u003e Result\u003c()\u003e {\r\n    ctx.accounts.config.authority = new_authority;\r\n    msg!(\"Authority updated to: {}\", new_authority);\r\n    Ok(())\r\n}\r\n\r\n","traces":[{"line":4,"address":[],"length":0,"stats":{"Line":0}},{"line":5,"address":[],"length":0,"stats":{"Line":0}},{"line":6,"address":[],"length":0,"stats":{"Line":0}},{"line":7,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":4},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","gasless-protocol","src","instructions","admin","update_daily_budget.rs"],"content":"use anchor_lang::prelude::*;\r\nuse crate::contexts::UpdateConfig;\r\n\r\npub fn handler(\r\n    ctx: Context\u003cUpdateConfig\u003e,\r\n    daily_budget: u64,\r\n    max_per_user: u32,\r\n) -\u003e Result\u003c()\u003e {\r\n    let config = \u0026mut ctx.accounts.config;\r\n    \r\n    config.daily_subsidy_budget = daily_budget;\r\n    config.max_subsidized_per_user = max_per_user;\r\n    \r\n    msg!(\"Daily budget updated: {} lamports, {} max per user\",\r\n        daily_budget, max_per_user);\r\n    Ok(())\r\n}\r\n\r\n","traces":[{"line":4,"address":[],"length":0,"stats":{"Line":0}},{"line":9,"address":[],"length":0,"stats":{"Line":0}},{"line":11,"address":[],"length":0,"stats":{"Line":0}},{"line":12,"address":[],"length":0,"stats":{"Line":0}},{"line":14,"address":[],"length":0,"stats":{"Line":0}},{"line":16,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":6},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","gasless-protocol","src","instructions","admin","update_fee_config.rs"],"content":"use anchor_lang::prelude::*;\r\nuse crate::contexts::UpdateConfig;\r\n\r\npub fn handler(\r\n    ctx: Context\u003cUpdateConfig\u003e,\r\n    sol_fee_per_tx: u64,\r\n    vcoin_fee_multiplier: u64,\r\n    sscre_deduction_bps: u16,\r\n) -\u003e Result\u003c()\u003e {\r\n    let config = \u0026mut ctx.accounts.config;\r\n    \r\n    config.sol_fee_per_tx = sol_fee_per_tx;\r\n    config.vcoin_fee_multiplier = vcoin_fee_multiplier;\r\n    config.sscre_deduction_bps = sscre_deduction_bps;\r\n    \r\n    msg!(\"Fee config updated: SOL={}, mult={}, SSCRE={}bps\",\r\n        sol_fee_per_tx, vcoin_fee_multiplier, sscre_deduction_bps);\r\n    Ok(())\r\n}\r\n\r\n","traces":[{"line":4,"address":[],"length":0,"stats":{"Line":0}},{"line":10,"address":[],"length":0,"stats":{"Line":0}},{"line":12,"address":[],"length":0,"stats":{"Line":0}},{"line":13,"address":[],"length":0,"stats":{"Line":0}},{"line":14,"address":[],"length":0,"stats":{"Line":0}},{"line":16,"address":[],"length":0,"stats":{"Line":0}},{"line":18,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":7},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","gasless-protocol","src","instructions","fee","deduct_vcoin.rs"],"content":"use anchor_lang::prelude::*;\r\nuse anchor_spl::token_2022;\r\nuse crate::contexts::DeductVCoinFee;\r\nuse crate::errors::GaslessError;\r\nuse crate::events::FeeCollected;\r\n\r\npub fn handler(ctx: Context\u003cDeductVCoinFee\u003e, amount: u64) -\u003e Result\u003c()\u003e {\r\n    let config = \u0026mut ctx.accounts.config;\r\n    let user_stats = \u0026mut ctx.accounts.user_stats;\r\n    \r\n    require!(!config.paused, GaslessError::ProtocolPaused);\r\n    \r\n    let clock = Clock::get()?;\r\n    \r\n    // Calculate VCoin fee equivalent\r\n    let vcoin_fee = config.sol_fee_per_tx\r\n        .saturating_mul(config.vcoin_fee_multiplier);\r\n    \r\n    let fee_to_deduct = if amount \u003e 0 { amount } else { vcoin_fee };\r\n    \r\n    // Transfer VCoin from user to fee vault\r\n    token_2022::transfer_checked(\r\n        CpiContext::new(ctx.accounts.token_program.to_account_info(),\r\n            token_2022::TransferChecked {\r\n                from: ctx.accounts.user_token_account.to_account_info(),\r\n                to: ctx.accounts.fee_vault.to_account_info(),\r\n                authority: ctx.accounts.user.to_account_info(),\r\n                mint: ctx.accounts.vcoin_mint.to_account_info(),\r\n            },\r\n        ),\r\n        fee_to_deduct,\r\n        ctx.accounts.vcoin_mint.decimals,\r\n    )?;\r\n    \r\n    // Update stats\r\n    config.total_vcoin_collected = config.total_vcoin_collected.saturating_add(fee_to_deduct);\r\n    user_stats.total_vcoin_fees = user_stats.total_vcoin_fees.saturating_add(fee_to_deduct);\r\n    user_stats.total_gasless_tx = user_stats.total_gasless_tx.saturating_add(1);\r\n    user_stats.last_gasless_at = clock.unix_timestamp;\r\n    user_stats.bump = ctx.bumps.user_stats;\r\n    \r\n    emit!(FeeCollected {\r\n        user: ctx.accounts.user.key(),\r\n        fee_method: 1,\r\n        amount: fee_to_deduct,\r\n        is_vcoin: true,\r\n    });\r\n    \r\n    msg!(\"VCoin fee deducted: {} VCoin\", fee_to_deduct);\r\n    Ok(())\r\n}\r\n\r\n","traces":[{"line":7,"address":[],"length":0,"stats":{"Line":0}},{"line":8,"address":[],"length":0,"stats":{"Line":0}},{"line":9,"address":[],"length":0,"stats":{"Line":0}},{"line":11,"address":[],"length":0,"stats":{"Line":0}},{"line":13,"address":[],"length":0,"stats":{"Line":0}},{"line":16,"address":[],"length":0,"stats":{"Line":0}},{"line":17,"address":[],"length":0,"stats":{"Line":0}},{"line":19,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":28},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","gasless-protocol","src","instructions","fee","mod.rs"],"content":"pub mod deduct_vcoin;\r\n\r\npub use deduct_vcoin::*;\r\n\r\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","gasless-protocol","src","instructions","mod.rs"],"content":"pub mod admin;\r\npub mod session;\r\npub mod fee;\r\npub mod query;\r\n\r\npub use admin::*;\r\npub use session::*;\r\npub use fee::*;\r\npub use query::*;\r\n\r\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","gasless-protocol","src","instructions","query","get_config_stats.rs"],"content":"use anchor_lang::prelude::*;\r\nuse crate::contexts::GetConfigStats;\r\n\r\npub fn handler(ctx: Context\u003cGetConfigStats\u003e) -\u003e Result\u003c()\u003e {\r\n    let config = \u0026ctx.accounts.config;\r\n    msg!(\"Total subsidized tx: {}\", config.total_subsidized_tx);\r\n    msg!(\"Total SOL spent: {}\", config.total_sol_spent);\r\n    msg!(\"Total VCoin collected: {}\", config.total_vcoin_collected);\r\n    msg!(\"Daily budget: {}\", config.daily_subsidy_budget);\r\n    msg!(\"Today spent: {}\", config.day_spent);\r\n    msg!(\"Paused: {}\", config.paused);\r\n    Ok(())\r\n}\r\n\r\n","traces":[{"line":4,"address":[],"length":0,"stats":{"Line":0}},{"line":5,"address":[],"length":0,"stats":{"Line":0}},{"line":6,"address":[],"length":0,"stats":{"Line":0}},{"line":7,"address":[],"length":0,"stats":{"Line":0}},{"line":8,"address":[],"length":0,"stats":{"Line":0}},{"line":9,"address":[],"length":0,"stats":{"Line":0}},{"line":10,"address":[],"length":0,"stats":{"Line":0}},{"line":11,"address":[],"length":0,"stats":{"Line":0}},{"line":12,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":9},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","gasless-protocol","src","instructions","query","get_session_info.rs"],"content":"use anchor_lang::prelude::*;\r\nuse crate::contexts::GetSessionInfo;\r\n\r\npub fn handler(ctx: Context\u003cGetSessionInfo\u003e) -\u003e Result\u003c()\u003e {\r\n    let session = \u0026ctx.accounts.session_key;\r\n    msg!(\"User: {}\", session.user);\r\n    msg!(\"Session Key: {}\", session.session_pubkey);\r\n    msg!(\"Scope: {:#06x}\", session.scope);\r\n    msg!(\"Actions: {}/{}\", session.actions_used, session.max_actions);\r\n    msg!(\"Spent: {}/{} VCoin\", session.vcoin_spent, session.max_spend);\r\n    msg!(\"Revoked: {}\", session.is_revoked);\r\n    Ok(())\r\n}\r\n\r\n","traces":[{"line":4,"address":[],"length":0,"stats":{"Line":0}},{"line":5,"address":[],"length":0,"stats":{"Line":0}},{"line":6,"address":[],"length":0,"stats":{"Line":0}},{"line":7,"address":[],"length":0,"stats":{"Line":0}},{"line":8,"address":[],"length":0,"stats":{"Line":0}},{"line":9,"address":[],"length":0,"stats":{"Line":0}},{"line":10,"address":[],"length":0,"stats":{"Line":0}},{"line":11,"address":[],"length":0,"stats":{"Line":0}},{"line":12,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":9},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","gasless-protocol","src","instructions","query","get_user_stats.rs"],"content":"use anchor_lang::prelude::*;\r\nuse crate::contexts::GetUserStats;\r\n\r\npub fn handler(ctx: Context\u003cGetUserStats\u003e) -\u003e Result\u003c()\u003e {\r\n    let stats = \u0026ctx.accounts.user_stats;\r\n    msg!(\"User: {}\", stats.user);\r\n    msg!(\"Total gasless tx: {}\", stats.total_gasless_tx);\r\n    msg!(\"Total subsidized: {}\", stats.total_subsidized);\r\n    msg!(\"Total VCoin fees: {}\", stats.total_vcoin_fees);\r\n    msg!(\"Sessions created: {}\", stats.sessions_created);\r\n    Ok(())\r\n}\r\n\r\n","traces":[{"line":4,"address":[],"length":0,"stats":{"Line":0}},{"line":5,"address":[],"length":0,"stats":{"Line":0}},{"line":6,"address":[],"length":0,"stats":{"Line":0}},{"line":7,"address":[],"length":0,"stats":{"Line":0}},{"line":8,"address":[],"length":0,"stats":{"Line":0}},{"line":9,"address":[],"length":0,"stats":{"Line":0}},{"line":10,"address":[],"length":0,"stats":{"Line":0}},{"line":11,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":8},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","gasless-protocol","src","instructions","query","mod.rs"],"content":"pub mod get_session_info;\r\npub mod get_user_stats;\r\npub mod get_config_stats;\r\n\r\npub use get_session_info::*;\r\npub use get_user_stats::*;\r\npub use get_config_stats::*;\r\n\r\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","gasless-protocol","src","instructions","session","create.rs"],"content":"use anchor_lang::prelude::*;\r\nuse crate::constants::*;\r\nuse crate::contexts::CreateSessionKey;\r\nuse crate::errors::GaslessError;\r\nuse crate::events::SessionKeyCreated;\r\nuse crate::state::FeeMethod;\r\n\r\npub fn handler(\r\n    ctx: Context\u003cCreateSessionKey\u003e,\r\n    session_pubkey: Pubkey,\r\n    scope: u16,\r\n    duration_seconds: i64,\r\n    max_actions: u32,\r\n    max_spend: u64,\r\n    fee_method: u8,\r\n) -\u003e Result\u003c()\u003e {\r\n    let config = \u0026ctx.accounts.config;\r\n    let session = \u0026mut ctx.accounts.session_key;\r\n    let user_stats = \u0026mut ctx.accounts.user_stats;\r\n    \r\n    require!(!config.paused, GaslessError::ProtocolPaused);\r\n    \r\n    let clock = Clock::get()?;\r\n    \r\n    // Limit session duration\r\n    let duration = if duration_seconds \u003e 0 \u0026\u0026 duration_seconds \u003c= SESSION_DURATION {\r\n        duration_seconds\r\n    } else {\r\n        SESSION_DURATION\r\n    };\r\n    \r\n    // Limit max actions\r\n    let actions = if max_actions \u003e 0 \u0026\u0026 max_actions \u003c= MAX_SESSION_ACTIONS {\r\n        max_actions\r\n    } else {\r\n        MAX_SESSION_ACTIONS\r\n    };\r\n    \r\n    // Limit max spend\r\n    let spend = if max_spend \u003e 0 \u0026\u0026 max_spend \u003c= MAX_SESSION_SPEND {\r\n        max_spend\r\n    } else {\r\n        MAX_SESSION_SPEND\r\n    };\r\n    \r\n    // Parse fee method\r\n    let method = match fee_method {\r\n        0 =\u003e FeeMethod::PlatformSubsidized,\r\n        1 =\u003e FeeMethod::VCoinDeduction,\r\n        2 =\u003e FeeMethod::SSCREDeduction,\r\n        _ =\u003e FeeMethod::VCoinDeduction,\r\n    };\r\n    \r\n    session.user = ctx.accounts.user.key();\r\n    session.session_pubkey = session_pubkey;\r\n    session.scope = scope;\r\n    session.created_at = clock.unix_timestamp;\r\n    session.expires_at = clock.unix_timestamp + duration;\r\n    session.actions_used = 0;\r\n    session.max_actions = actions;\r\n    session.vcoin_spent = 0;\r\n    session.max_spend = spend;\r\n    session.is_revoked = false;\r\n    session.last_action_at = 0;\r\n    session.fee_method = method;\r\n    session.bump = ctx.bumps.session_key;\r\n    \r\n    // Update user stats\r\n    user_stats.user = ctx.accounts.user.key();\r\n    user_stats.sessions_created = user_stats.sessions_created.saturating_add(1);\r\n    user_stats.active_session = session_pubkey;\r\n    user_stats.bump = ctx.bumps.user_stats;\r\n    \r\n    emit!(SessionKeyCreated {\r\n        user: session.user,\r\n        session_pubkey,\r\n        scope,\r\n        expires_at: session.expires_at,\r\n        fee_method,\r\n    });\r\n    \r\n    msg!(\"Session key created: scope={:#06x}, expires in {}s\", scope, duration);\r\n    Ok(())\r\n}\r\n\r\n","traces":[{"line":8,"address":[],"length":0,"stats":{"Line":0}},{"line":17,"address":[],"length":0,"stats":{"Line":0}},{"line":18,"address":[],"length":0,"stats":{"Line":0}},{"line":19,"address":[],"length":0,"stats":{"Line":0}},{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":45},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","gasless-protocol","src","instructions","session","execute_action.rs"],"content":"use anchor_lang::prelude::*;\r\nuse crate::contexts::ExecuteSessionAction;\r\nuse crate::errors::GaslessError;\r\nuse crate::events::{DailyBudgetReset, FeeCollected, SessionActionExecuted};\r\nuse crate::state::{FeeMethod, GaslessConfig};\r\n\r\npub fn handler(\r\n    ctx: Context\u003cExecuteSessionAction\u003e,\r\n    action_type: u16,\r\n    spend_amount: u64,\r\n) -\u003e Result\u003c()\u003e {\r\n    let config = \u0026mut ctx.accounts.config;\r\n    let session = \u0026mut ctx.accounts.session_key;\r\n    let user_stats = \u0026mut ctx.accounts.user_stats;\r\n    \r\n    require!(!config.paused, GaslessError::ProtocolPaused);\r\n    \r\n    let clock = Clock::get()?;\r\n    \r\n    // Check session validity\r\n    require!(session.is_valid(clock.unix_timestamp), GaslessError::SessionExpired);\r\n    require!(session.is_action_in_scope(action_type), GaslessError::ActionNotInScope);\r\n    \r\n    // Check action limit\r\n    require!(\r\n        session.actions_used \u003c session.max_actions,\r\n        GaslessError::SessionActionLimitExceeded\r\n    );\r\n    \r\n    // Check spend limit\r\n    require!(\r\n        session.vcoin_spent.saturating_add(spend_amount) \u003c= session.max_spend,\r\n        GaslessError::SessionSpendLimitExceeded\r\n    );\r\n    \r\n    // Handle daily budget for subsidized transactions\r\n    if matches!(session.fee_method, FeeMethod::PlatformSubsidized) {\r\n        // Reset daily budget if needed\r\n        if config.should_reset_daily_budget(clock.unix_timestamp) {\r\n            emit!(DailyBudgetReset {\r\n                day: config.current_day,\r\n                previous_spent: config.day_spent,\r\n                new_budget: config.daily_subsidy_budget,\r\n            });\r\n            config.current_day = GaslessConfig::get_day_number(clock.unix_timestamp);\r\n            config.day_spent = 0;\r\n        }\r\n        \r\n        // Check daily budget\r\n        require!(\r\n            config.day_spent.saturating_add(config.sol_fee_per_tx) \u003c= config.daily_subsidy_budget,\r\n            GaslessError::DailyBudgetExceeded\r\n        );\r\n        \r\n        // Check user daily limit\r\n        user_stats.check_daily_reset(clock.unix_timestamp);\r\n        require!(\r\n            user_stats.today_subsidized \u003c config.max_subsidized_per_user,\r\n            GaslessError::UserDailyLimitExceeded\r\n        );\r\n        \r\n        // Update budget tracking\r\n        config.day_spent = config.day_spent.saturating_add(config.sol_fee_per_tx);\r\n        config.total_sol_spent = config.total_sol_spent.saturating_add(config.sol_fee_per_tx);\r\n        config.total_subsidized_tx = config.total_subsidized_tx.saturating_add(1);\r\n        user_stats.today_subsidized = user_stats.today_subsidized.saturating_add(1);\r\n        user_stats.total_subsidized = user_stats.total_subsidized.saturating_add(1);\r\n        \r\n        emit!(FeeCollected {\r\n            user: session.user,\r\n            fee_method: 0,\r\n            amount: config.sol_fee_per_tx,\r\n            is_vcoin: false,\r\n        });\r\n    }\r\n    \r\n    // Update session\r\n    session.actions_used = session.actions_used.saturating_add(1);\r\n    session.vcoin_spent = session.vcoin_spent.saturating_add(spend_amount);\r\n    session.last_action_at = clock.unix_timestamp;\r\n    \r\n    // Update user stats\r\n    user_stats.total_gasless_tx = user_stats.total_gasless_tx.saturating_add(1);\r\n    if user_stats.first_gasless_at == 0 {\r\n        user_stats.first_gasless_at = clock.unix_timestamp;\r\n    }\r\n    user_stats.last_gasless_at = clock.unix_timestamp;\r\n    \r\n    emit!(SessionActionExecuted {\r\n        user: session.user,\r\n        session_pubkey: session.session_pubkey,\r\n        action_type,\r\n        fee_method: session.fee_method as u8,\r\n        fee_amount: spend_amount,\r\n    });\r\n    \r\n    msg!(\"Session action executed: type={:#06x}, spend={}\", action_type, spend_amount);\r\n    Ok(())\r\n}\r\n\r\n","traces":[{"line":7,"address":[],"length":0,"stats":{"Line":0}},{"line":12,"address":[],"length":0,"stats":{"Line":0}},{"line":13,"address":[],"length":0,"stats":{"Line":0}},{"line":14,"address":[],"length":0,"stats":{"Line":0}},{"line":16,"address":[],"length":0,"stats":{"Line":0}},{"line":18,"address":[],"length":0,"stats":{"Line":0}},{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":0}},{"line":98,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":54},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","gasless-protocol","src","instructions","session","mod.rs"],"content":"pub mod create;\r\npub mod execute_action;\r\npub mod revoke;\r\n\r\npub use create::*;\r\npub use execute_action::*;\r\npub use revoke::*;\r\n\r\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","gasless-protocol","src","instructions","session","revoke.rs"],"content":"use anchor_lang::prelude::*;\r\nuse crate::contexts::RevokeSessionKey;\r\nuse crate::errors::GaslessError;\r\nuse crate::events::SessionKeyRevoked;\r\n\r\npub fn handler(ctx: Context\u003cRevokeSessionKey\u003e) -\u003e Result\u003c()\u003e {\r\n    let session = \u0026mut ctx.accounts.session_key;\r\n    let user_stats = \u0026mut ctx.accounts.user_stats;\r\n    \r\n    require!(!session.is_revoked, GaslessError::SessionRevoked);\r\n    \r\n    session.is_revoked = true;\r\n    \r\n    // Clear active session if this was it\r\n    if user_stats.active_session == session.session_pubkey {\r\n        user_stats.active_session = Pubkey::default();\r\n    }\r\n    \r\n    emit!(SessionKeyRevoked {\r\n        user: session.user,\r\n        session_pubkey: session.session_pubkey,\r\n        actions_used: session.actions_used,\r\n    });\r\n    \r\n    msg!(\"Session key revoked after {} actions\", session.actions_used);\r\n    Ok(())\r\n}\r\n\r\n","traces":[{"line":6,"address":[],"length":0,"stats":{"Line":0}},{"line":7,"address":[],"length":0,"stats":{"Line":0}},{"line":8,"address":[],"length":0,"stats":{"Line":0}},{"line":10,"address":[],"length":0,"stats":{"Line":0}},{"line":12,"address":[],"length":0,"stats":{"Line":0}},{"line":15,"address":[],"length":0,"stats":{"Line":0}},{"line":16,"address":[],"length":0,"stats":{"Line":0}},{"line":19,"address":[],"length":0,"stats":{"Line":0}},{"line":20,"address":[],"length":0,"stats":{"Line":0}},{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":13},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","gasless-protocol","src","lib.rs"],"content":"use anchor_lang::prelude::*;\r\n\r\ndeclare_id!(\"FcXJAjzJs8eVY2WTRFXynQBpC7WZUqKZppyp9xS6PaB3\");\r\n\r\n/// Gasless Layer - Paymaster + Session Keys for Zero-Friction UX\r\n/// \r\n/// Enables gasless transactions for ViWoApp users.\r\n/// \r\n/// Key Features:\r\n/// - Paymaster: Platform subsidizes transaction fees\r\n/// - Session Keys: Temporary 24h signing keys with limited scope\r\n/// - VCoin Deduction: Automatic fee deduction from VCoin balance\r\n/// - SSCRE Integration: 1% deduction from reward claims\r\n/// \r\n/// Fee Deduction Methods:\r\n/// 1. Platform Subsidized (onboarding, governance)\r\n/// 2. VCoin Deduction (tips, transfers)\r\n/// 3. Reward Deduction (1% from SSCRE claims)\r\n/// \r\n/// Session Key Scopes:\r\n/// - Tip actions\r\n/// - Vouch actions\r\n/// - Content interactions\r\n/// - Governance voting\r\n\r\npub mod constants;\r\npub mod errors;\r\npub mod events;\r\npub mod state;\r\npub mod contexts;\r\npub mod instructions;\r\n\r\n#[cfg(test)]\r\nmod tests;\r\n\r\nuse contexts::*;\r\nuse instructions::*;\r\n\r\n#[program]\r\npub mod gasless_protocol {\r\n    use super::*;\r\n\r\n    /// Initialize gasless configuration\r\n    pub fn initialize(\r\n        ctx: Context\u003cInitialize\u003e,\r\n        fee_payer: Pubkey,\r\n        daily_budget: u64,\r\n    ) -\u003e Result\u003c()\u003e {\r\n        admin::initialize::handler(ctx, fee_payer, daily_budget)\r\n    }\r\n    \r\n    /// Create a session key for gasless transactions\r\n    pub fn create_session_key(\r\n        ctx: Context\u003cCreateSessionKey\u003e,\r\n        session_pubkey: Pubkey,\r\n        scope: u16,\r\n        duration_seconds: i64,\r\n        max_actions: u32,\r\n        max_spend: u64,\r\n        fee_method: u8,\r\n    ) -\u003e Result\u003c()\u003e {\r\n        session::create::handler(ctx, session_pubkey, scope, duration_seconds, max_actions, max_spend, fee_method)\r\n    }\r\n    \r\n    /// Execute an action using session key\r\n    pub fn execute_session_action(\r\n        ctx: Context\u003cExecuteSessionAction\u003e,\r\n        action_type: u16,\r\n        spend_amount: u64,\r\n    ) -\u003e Result\u003c()\u003e {\r\n        session::execute_action::handler(ctx, action_type, spend_amount)\r\n    }\r\n    \r\n    /// Deduct VCoin fee for gasless transaction\r\n    pub fn deduct_vcoin_fee(\r\n        ctx: Context\u003cDeductVCoinFee\u003e,\r\n        amount: u64,\r\n    ) -\u003e Result\u003c()\u003e {\r\n        fee::deduct_vcoin::handler(ctx, amount)\r\n    }\r\n    \r\n    /// Revoke a session key\r\n    pub fn revoke_session_key(ctx: Context\u003cRevokeSessionKey\u003e) -\u003e Result\u003c()\u003e {\r\n        session::revoke::handler(ctx)\r\n    }\r\n    \r\n    /// Update fee configuration\r\n    pub fn update_fee_config(\r\n        ctx: Context\u003cUpdateConfig\u003e,\r\n        sol_fee_per_tx: u64,\r\n        vcoin_fee_multiplier: u64,\r\n        sscre_deduction_bps: u16,\r\n    ) -\u003e Result\u003c()\u003e {\r\n        admin::update_fee_config::handler(ctx, sol_fee_per_tx, vcoin_fee_multiplier, sscre_deduction_bps)\r\n    }\r\n    \r\n    /// Update daily budget\r\n    pub fn update_daily_budget(\r\n        ctx: Context\u003cUpdateConfig\u003e,\r\n        daily_budget: u64,\r\n        max_per_user: u32,\r\n    ) -\u003e Result\u003c()\u003e {\r\n        admin::update_daily_budget::handler(ctx, daily_budget, max_per_user)\r\n    }\r\n    \r\n    /// Set fee payer (paymaster wallet)\r\n    pub fn set_fee_payer(ctx: Context\u003cUpdateConfig\u003e, new_fee_payer: Pubkey) -\u003e Result\u003c()\u003e {\r\n        admin::set_fee_payer::handler(ctx, new_fee_payer)\r\n    }\r\n    \r\n    /// Set SSCRE program reference\r\n    pub fn set_sscre_program(ctx: Context\u003cUpdateConfig\u003e, sscre_program: Pubkey) -\u003e Result\u003c()\u003e {\r\n        admin::set_sscre_program::handler(ctx, sscre_program)\r\n    }\r\n    \r\n    /// Pause/unpause protocol\r\n    pub fn set_paused(ctx: Context\u003cUpdateConfig\u003e, paused: bool) -\u003e Result\u003c()\u003e {\r\n        admin::set_paused::handler(ctx, paused)\r\n    }\r\n    \r\n    /// Update authority\r\n    pub fn update_authority(ctx: Context\u003cUpdateAuthority\u003e, new_authority: Pubkey) -\u003e Result\u003c()\u003e {\r\n        admin::update_authority::handler(ctx, new_authority)\r\n    }\r\n    \r\n    /// Get session key info\r\n    pub fn get_session_info(ctx: Context\u003cGetSessionInfo\u003e) -\u003e Result\u003c()\u003e {\r\n        query::get_session_info::handler(ctx)\r\n    }\r\n    \r\n    /// Get user gasless stats\r\n    pub fn get_user_gasless_stats(ctx: Context\u003cGetUserStats\u003e) -\u003e Result\u003c()\u003e {\r\n        query::get_user_stats::handler(ctx)\r\n    }\r\n    \r\n    /// Get config stats\r\n    pub fn get_config_stats(ctx: Context\u003cGetConfigStats\u003e) -\u003e Result\u003c()\u003e {\r\n        query::get_config_stats::handler(ctx)\r\n    }\r\n}\r\n","traces":[{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":98,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":0}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":112,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":0}},{"line":118,"address":[],"length":0,"stats":{"Line":0}},{"line":122,"address":[],"length":0,"stats":{"Line":0}},{"line":123,"address":[],"length":0,"stats":{"Line":0}},{"line":127,"address":[],"length":0,"stats":{"Line":0}},{"line":128,"address":[],"length":0,"stats":{"Line":0}},{"line":132,"address":[],"length":0,"stats":{"Line":0}},{"line":133,"address":[],"length":0,"stats":{"Line":0}},{"line":137,"address":[],"length":0,"stats":{"Line":0}},{"line":138,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":28},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","gasless-protocol","src","state","daily_budget.rs"],"content":"use anchor_lang::prelude::*;\r\n\r\n/// Daily budget tracking\r\n#[account]\r\n#[derive(Default)]\r\npub struct DailyBudget {\r\n    /// Day number\r\n    pub day: u32,\r\n    /// Total budget allocated\r\n    pub total_budget: u64,\r\n    /// Amount spent\r\n    pub spent: u64,\r\n    /// Transactions subsidized\r\n    pub tx_count: u64,\r\n    /// Unique users subsidized\r\n    pub unique_users: u32,\r\n    /// PDA bump\r\n    pub bump: u8,\r\n}\r\n\r\nimpl DailyBudget {\r\n    pub const LEN: usize = 8 + // discriminator\r\n        4 +  // day\r\n        8 +  // total_budget\r\n        8 +  // spent\r\n        8 +  // tx_count\r\n        4 +  // unique_users\r\n        1;   // bump\r\n}\r\n\r\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","gasless-protocol","src","state","fee_method.rs"],"content":"use anchor_lang::prelude::*;\r\n\r\n/// Fee deduction method\r\n#[derive(AnchorSerialize, AnchorDeserialize, Clone, Copy, PartialEq, Eq, Default, Debug)]\r\npub enum FeeMethod {\r\n    #[default]\r\n    PlatformSubsidized,\r\n    VCoinDeduction,\r\n    SSCREDeduction,\r\n}\r\n\r\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","gasless-protocol","src","state","gasless_config.rs"],"content":"use anchor_lang::prelude::*;\r\n\r\n/// Global gasless configuration\r\n#[account]\r\n#[derive(Default)]\r\npub struct GaslessConfig {\r\n    /// Admin authority\r\n    pub authority: Pubkey,\r\n    /// Fee payer wallet (paymaster)\r\n    pub fee_payer: Pubkey,\r\n    /// VCoin mint\r\n    pub vcoin_mint: Pubkey,\r\n    /// Fee vault for VCoin fees\r\n    pub fee_vault: Pubkey,\r\n    /// SSCRE program for reward deduction\r\n    pub sscre_program: Pubkey,\r\n    /// Daily subsidy budget (SOL lamports)\r\n    pub daily_subsidy_budget: u64,\r\n    /// SOL fee per transaction (lamports)\r\n    pub sol_fee_per_tx: u64,\r\n    /// VCoin fee multiplier\r\n    pub vcoin_fee_multiplier: u64,\r\n    /// SSCRE deduction rate (bps)\r\n    pub sscre_deduction_bps: u16,\r\n    /// Max subsidized tx per user per day\r\n    pub max_subsidized_per_user: u32,\r\n    /// Total transactions subsidized\r\n    pub total_subsidized_tx: u64,\r\n    /// Total SOL spent on subsidies\r\n    pub total_sol_spent: u64,\r\n    /// Total VCoin collected as fees\r\n    pub total_vcoin_collected: u64,\r\n    /// Whether protocol is paused\r\n    pub paused: bool,\r\n    /// Current day (for daily budget reset)\r\n    pub current_day: u32,\r\n    /// Day's spent budget\r\n    pub day_spent: u64,\r\n    /// PDA bump\r\n    pub bump: u8,\r\n}\r\n\r\nimpl GaslessConfig {\r\n    pub const LEN: usize = 8 + // discriminator\r\n        32 + // authority\r\n        32 + // fee_payer\r\n        32 + // vcoin_mint\r\n        32 + // fee_vault\r\n        32 + // sscre_program\r\n        8 +  // daily_subsidy_budget\r\n        8 +  // sol_fee_per_tx\r\n        8 +  // vcoin_fee_multiplier\r\n        2 +  // sscre_deduction_bps\r\n        4 +  // max_subsidized_per_user\r\n        8 +  // total_subsidized_tx\r\n        8 +  // total_sol_spent\r\n        8 +  // total_vcoin_collected\r\n        1 +  // paused\r\n        4 +  // current_day\r\n        8 +  // day_spent\r\n        1;   // bump\r\n    \r\n    /// Get current day number\r\n    pub fn get_day_number(timestamp: i64) -\u003e u32 {\r\n        (timestamp / 86400) as u32\r\n    }\r\n    \r\n    /// Check if daily budget reset needed\r\n    pub fn should_reset_daily_budget(\u0026self, current_timestamp: i64) -\u003e bool {\r\n        Self::get_day_number(current_timestamp) \u003e self.current_day\r\n    }\r\n}\r\n\r\n","traces":[{"line":64,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":65,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":69,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":70,"address":[],"length":0,"stats":{"Line":288230376151711744}}],"covered":4,"coverable":4},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","gasless-protocol","src","state","mod.rs"],"content":"pub mod fee_method;\r\npub mod gasless_config;\r\npub mod session_key;\r\npub mod user_gasless_stats;\r\npub mod daily_budget;\r\n\r\npub use fee_method::*;\r\npub use gasless_config::*;\r\npub use session_key::*;\r\npub use user_gasless_stats::*;\r\npub use daily_budget::*;\r\n\r\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","gasless-protocol","src","state","session_key.rs"],"content":"use anchor_lang::prelude::*;\r\nuse super::FeeMethod;\r\n\r\n/// Session key for temporary signing\r\n#[account]\r\n#[derive(Default)]\r\npub struct SessionKey {\r\n    /// User who owns this session\r\n    pub user: Pubkey,\r\n    /// The session key pubkey\r\n    pub session_pubkey: Pubkey,\r\n    /// Allowed action scope bitmap\r\n    pub scope: u16,\r\n    /// Session creation timestamp\r\n    pub created_at: i64,\r\n    /// Session expiry timestamp\r\n    pub expires_at: i64,\r\n    /// Actions executed in this session\r\n    pub actions_used: u32,\r\n    /// Max actions allowed\r\n    pub max_actions: u32,\r\n    /// VCoin spent via this session\r\n    pub vcoin_spent: u64,\r\n    /// Max VCoin spend allowed\r\n    pub max_spend: u64,\r\n    /// Whether session is revoked\r\n    pub is_revoked: bool,\r\n    /// Last action timestamp\r\n    pub last_action_at: i64,\r\n    /// Fee method for this session\r\n    pub fee_method: FeeMethod,\r\n    /// PDA bump\r\n    pub bump: u8,\r\n}\r\n\r\nimpl SessionKey {\r\n    pub const LEN: usize = 8 + // discriminator\r\n        32 + // user\r\n        32 + // session_pubkey\r\n        2 +  // scope\r\n        8 +  // created_at\r\n        8 +  // expires_at\r\n        4 +  // actions_used\r\n        4 +  // max_actions\r\n        8 +  // vcoin_spent\r\n        8 +  // max_spend\r\n        1 +  // is_revoked\r\n        8 +  // last_action_at\r\n        1 +  // fee_method\r\n        1;   // bump\r\n    \r\n    /// Check if action is in scope\r\n    pub fn is_action_in_scope(\u0026self, action_type: u16) -\u003e bool {\r\n        (self.scope \u0026 action_type) != 0\r\n    }\r\n    \r\n    /// Check if session is valid\r\n    pub fn is_valid(\u0026self, current_timestamp: i64) -\u003e bool {\r\n        !self.is_revoked \u0026\u0026 \r\n        current_timestamp \u003c= self.expires_at \u0026\u0026\r\n        self.actions_used \u003c self.max_actions\r\n    }\r\n}\r\n\r\n","traces":[{"line":53,"address":[],"length":0,"stats":{"Line":648518346341351424}},{"line":54,"address":[],"length":0,"stats":{"Line":648518346341351424}},{"line":58,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":59,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":60,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":61,"address":[],"length":0,"stats":{"Line":144115188075855872}}],"covered":6,"coverable":6},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","gasless-protocol","src","state","user_gasless_stats.rs"],"content":"use anchor_lang::prelude::*;\r\nuse super::GaslessConfig;\r\n\r\n/// User gasless statistics\r\n#[account]\r\n#[derive(Default)]\r\npub struct UserGaslessStats {\r\n    /// User wallet\r\n    pub user: Pubkey,\r\n    /// Total gasless transactions\r\n    pub total_gasless_tx: u64,\r\n    /// Total subsidized transactions\r\n    pub total_subsidized: u64,\r\n    /// Total VCoin paid as fees\r\n    pub total_vcoin_fees: u64,\r\n    /// Total SSCRE deductions\r\n    pub total_sscre_deductions: u64,\r\n    /// Sessions created\r\n    pub sessions_created: u32,\r\n    /// Active session (if any)\r\n    pub active_session: Pubkey,\r\n    /// Current day for daily limits\r\n    pub current_day: u32,\r\n    /// Today's subsidized tx count\r\n    pub today_subsidized: u32,\r\n    /// First gasless tx timestamp\r\n    pub first_gasless_at: i64,\r\n    /// Last gasless tx timestamp\r\n    pub last_gasless_at: i64,\r\n    /// PDA bump\r\n    pub bump: u8,\r\n}\r\n\r\nimpl UserGaslessStats {\r\n    pub const LEN: usize = 8 + // discriminator\r\n        32 + // user\r\n        8 +  // total_gasless_tx\r\n        8 +  // total_subsidized\r\n        8 +  // total_vcoin_fees\r\n        8 +  // total_sscre_deductions\r\n        4 +  // sessions_created\r\n        32 + // active_session\r\n        4 +  // current_day\r\n        4 +  // today_subsidized\r\n        8 +  // first_gasless_at\r\n        8 +  // last_gasless_at\r\n        1;   // bump\r\n    \r\n    /// Reset daily limits if new day\r\n    pub fn check_daily_reset(\u0026mut self, current_timestamp: i64) {\r\n        let day = GaslessConfig::get_day_number(current_timestamp);\r\n        if day \u003e self.current_day {\r\n            self.current_day = day;\r\n            self.today_subsidized = 0;\r\n        }\r\n    }\r\n}\r\n\r\n","traces":[{"line":50,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":51,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":52,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":53,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":54,"address":[],"length":0,"stats":{"Line":72057594037927936}}],"covered":5,"coverable":5},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","gasless-protocol","src","tests.rs"],"content":"//! Unit tests for Gasless Protocol\r\n//!\r\n//! These tests run against the ACTUAL program code.\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n    use crate::constants::*;\r\n    use crate::state::{GaslessConfig, SessionKey, UserGaslessStats, FeeMethod};\r\n    use anchor_lang::prelude::Pubkey;\r\n\r\n    // ========================================================================\r\n    // Constants Tests\r\n    // ========================================================================\r\n\r\n    #[test]\r\n    fn test_pda_seeds() {\r\n        assert_eq!(GASLESS_CONFIG_SEED, b\"gasless-config\");\r\n        assert_eq!(SESSION_KEY_SEED, b\"session-key\");\r\n        assert_eq!(USER_GASLESS_SEED, b\"user-gasless\");\r\n        assert_eq!(FEE_VAULT_SEED, b\"fee-vault\");\r\n        assert_eq!(DAILY_BUDGET_SEED, b\"daily-budget\");\r\n    }\r\n\r\n    #[test]\r\n    fn test_session_limits() {\r\n        assert_eq!(SESSION_DURATION, 24 * 60 * 60, \"24 hours\");\r\n        assert_eq!(MAX_SESSION_ACTIONS, 1000);\r\n        assert_eq!(MAX_SESSION_SPEND, 100_000_000_000_000, \"100K VCoin\");\r\n    }\r\n\r\n    #[test]\r\n    fn test_fee_configuration() {\r\n        assert_eq!(DEFAULT_SOL_FEE, 5_000, \"0.000005 SOL\");\r\n        assert_eq!(VCOIN_FEE_MULTIPLIER, 100, \"100x multiplier\");\r\n        assert_eq!(SSCRE_DEDUCTION_BPS, 100, \"1%\");\r\n    }\r\n\r\n    #[test]\r\n    fn test_daily_budget_limits() {\r\n        assert_eq!(DAILY_SUBSIDY_BUDGET_SOL, 10_000_000_000, \"10 SOL\");\r\n        assert_eq!(MAX_SUBSIDIZED_TX_PER_USER, 50);\r\n    }\r\n\r\n    #[test]\r\n    fn test_scope_bits() {\r\n        assert_eq!(SCOPE_TIP, 1 \u003c\u003c 0);\r\n        assert_eq!(SCOPE_VOUCH, 1 \u003c\u003c 1);\r\n        assert_eq!(SCOPE_CONTENT, 1 \u003c\u003c 2);\r\n        assert_eq!(SCOPE_GOVERNANCE, 1 \u003c\u003c 3);\r\n        assert_eq!(SCOPE_TRANSFER, 1 \u003c\u003c 4);\r\n        assert_eq!(SCOPE_STAKE, 1 \u003c\u003c 5);\r\n        assert_eq!(SCOPE_CLAIM, 1 \u003c\u003c 6);\r\n        assert_eq!(SCOPE_FOLLOW, 1 \u003c\u003c 7);\r\n        assert_eq!(SCOPE_ALL, 0xFFFF);\r\n    }\r\n\r\n    // ========================================================================\r\n    // State Size Tests\r\n    // ========================================================================\r\n\r\n    #[test]\r\n    fn test_gasless_config_size() {\r\n        let expected = 8 + 32 + 32 + 32 + 32 + 32 + 8 + 8 + 8 + 2 + 4 + 8 + 8 + 8 + 1 + 4 + 8 + 1;\r\n        assert_eq!(GaslessConfig::LEN, expected, \"Config size mismatch\");\r\n    }\r\n\r\n    #[test]\r\n    fn test_session_key_size() {\r\n        let expected = 8 + 32 + 32 + 2 + 8 + 8 + 4 + 4 + 8 + 8 + 1 + 8 + 1 + 1;\r\n        assert_eq!(SessionKey::LEN, expected, \"Session key size mismatch\");\r\n    }\r\n\r\n    #[test]\r\n    fn test_user_gasless_stats_size() {\r\n        let expected = 8 + 32 + 8 + 8 + 8 + 8 + 4 + 32 + 4 + 4 + 8 + 8 + 1;\r\n        assert_eq!(UserGaslessStats::LEN, expected, \"User stats size mismatch\");\r\n    }\r\n\r\n    // ========================================================================\r\n    // Session Key Scope Tests\r\n    // ========================================================================\r\n\r\n    #[test]\r\n    fn test_session_scope_all() {\r\n        let session = SessionKey {\r\n            scope: SCOPE_ALL,\r\n            ..Default::default()\r\n        };\r\n        \r\n        assert!(session.is_action_in_scope(SCOPE_TIP));\r\n        assert!(session.is_action_in_scope(SCOPE_VOUCH));\r\n        assert!(session.is_action_in_scope(SCOPE_GOVERNANCE));\r\n    }\r\n\r\n    #[test]\r\n    fn test_session_scope_selective() {\r\n        let session = SessionKey {\r\n            scope: SCOPE_TIP | SCOPE_CONTENT,\r\n            ..Default::default()\r\n        };\r\n        \r\n        assert!(session.is_action_in_scope(SCOPE_TIP));\r\n        assert!(session.is_action_in_scope(SCOPE_CONTENT));\r\n        assert!(!session.is_action_in_scope(SCOPE_VOUCH));\r\n        assert!(!session.is_action_in_scope(SCOPE_GOVERNANCE));\r\n    }\r\n\r\n    #[test]\r\n    fn test_session_scope_none() {\r\n        let session = SessionKey {\r\n            scope: 0,\r\n            ..Default::default()\r\n        };\r\n        \r\n        assert!(!session.is_action_in_scope(SCOPE_TIP));\r\n        assert!(!session.is_action_in_scope(SCOPE_VOUCH));\r\n    }\r\n\r\n    // ========================================================================\r\n    // Session Validity Tests\r\n    // ========================================================================\r\n\r\n    #[test]\r\n    fn test_session_is_valid() {\r\n        let session = SessionKey {\r\n            expires_at: 2000,\r\n            max_actions: 100,\r\n            actions_used: 50,\r\n            is_revoked: false,\r\n            ..Default::default()\r\n        };\r\n        \r\n        assert!(session.is_valid(1500), \"Should be valid\");\r\n    }\r\n\r\n    #[test]\r\n    fn test_session_expired() {\r\n        let session = SessionKey {\r\n            expires_at: 1000,\r\n            max_actions: 100,\r\n            actions_used: 50,\r\n            is_revoked: false,\r\n            ..Default::default()\r\n        };\r\n        \r\n        assert!(!session.is_valid(1500), \"Should be expired\");\r\n    }\r\n\r\n    #[test]\r\n    fn test_session_revoked() {\r\n        let session = SessionKey {\r\n            expires_at: 2000,\r\n            max_actions: 100,\r\n            actions_used: 50,\r\n            is_revoked: true,\r\n            ..Default::default()\r\n        };\r\n        \r\n        assert!(!session.is_valid(1500), \"Should be invalid (revoked)\");\r\n    }\r\n\r\n    #[test]\r\n    fn test_session_actions_exhausted() {\r\n        let session = SessionKey {\r\n            expires_at: 2000,\r\n            max_actions: 100,\r\n            actions_used: 100,\r\n            is_revoked: false,\r\n            ..Default::default()\r\n        };\r\n        \r\n        assert!(!session.is_valid(1500), \"Should be invalid (actions exhausted)\");\r\n    }\r\n\r\n    // ========================================================================\r\n    // Fee Method Tests\r\n    // ========================================================================\r\n\r\n    #[test]\r\n    fn test_fee_method_default() {\r\n        let method = FeeMethod::default();\r\n        assert_eq!(method, FeeMethod::PlatformSubsidized);\r\n    }\r\n\r\n    #[test]\r\n    fn test_fee_method_variants() {\r\n        let _subsidized = FeeMethod::PlatformSubsidized;\r\n        let _vcoin = FeeMethod::VCoinDeduction;\r\n        let _sscre = FeeMethod::SSCREDeduction;\r\n    }\r\n\r\n    // ========================================================================\r\n    // Daily Budget Tests\r\n    // ========================================================================\r\n\r\n    #[test]\r\n    fn test_get_day_number() {\r\n        let timestamp = 172800i64; // 2 days in seconds\r\n        let day = GaslessConfig::get_day_number(timestamp);\r\n        assert_eq!(day, 2);\r\n    }\r\n\r\n    #[test]\r\n    fn test_should_reset_daily_budget() {\r\n        let config = GaslessConfig {\r\n            current_day: 10,\r\n            ..Default::default()\r\n        };\r\n        \r\n        let day_10_timestamp = 10 * 86400i64;\r\n        let day_11_timestamp = 11 * 86400i64;\r\n        \r\n        assert!(!config.should_reset_daily_budget(day_10_timestamp));\r\n        assert!(config.should_reset_daily_budget(day_11_timestamp));\r\n    }\r\n\r\n    // ========================================================================\r\n    // User Stats Daily Reset Tests\r\n    // ========================================================================\r\n\r\n    #[test]\r\n    fn test_user_stats_daily_reset() {\r\n        let mut stats = UserGaslessStats {\r\n            current_day: 10,\r\n            today_subsidized: 25,\r\n            ..Default::default()\r\n        };\r\n        \r\n        let day_11_timestamp = 11 * 86400i64;\r\n        stats.check_daily_reset(day_11_timestamp);\r\n        \r\n        assert_eq!(stats.current_day, 11);\r\n        assert_eq!(stats.today_subsidized, 0);\r\n    }\r\n\r\n    #[test]\r\n    fn test_user_stats_no_reset_same_day() {\r\n        let mut stats = UserGaslessStats {\r\n            current_day: 10,\r\n            today_subsidized: 25,\r\n            ..Default::default()\r\n        };\r\n        \r\n        let day_10_timestamp = 10 * 86400i64 + 1000;\r\n        stats.check_daily_reset(day_10_timestamp);\r\n        \r\n        assert_eq!(stats.current_day, 10);\r\n        assert_eq!(stats.today_subsidized, 25); // Not reset\r\n    }\r\n\r\n    // ========================================================================\r\n    // PDA Derivation Tests\r\n    // ========================================================================\r\n\r\n    #[test]\r\n    fn test_session_key_pda_unique() {\r\n        let program_id = Pubkey::new_unique();\r\n        let user = Pubkey::new_unique();\r\n        let session1 = Pubkey::new_unique();\r\n        let session2 = Pubkey::new_unique();\r\n        \r\n        let (pda1, _) = Pubkey::find_program_address(\r\n            \u0026[SESSION_KEY_SEED, user.as_ref(), session1.as_ref()],\r\n            \u0026program_id\r\n        );\r\n        \r\n        let (pda2, _) = Pubkey::find_program_address(\r\n            \u0026[SESSION_KEY_SEED, user.as_ref(), session2.as_ref()],\r\n            \u0026program_id\r\n        );\r\n        \r\n        assert_ne!(pda1, pda2);\r\n    }\r\n\r\n    // ========================================================================\r\n    // Invariant Tests\r\n    // ========================================================================\r\n\r\n    #[test]\r\n    fn test_invariant_actions_bounded() {\r\n        let session = SessionKey {\r\n            actions_used: 500,\r\n            max_actions: 1000,\r\n            ..Default::default()\r\n        };\r\n        \r\n        assert!(session.actions_used \u003c= session.max_actions);\r\n    }\r\n\r\n    #[test]\r\n    fn test_invariant_spend_bounded() {\r\n        let session = SessionKey {\r\n            vcoin_spent: 50_000_000_000_000,\r\n            max_spend: 100_000_000_000_000,\r\n            ..Default::default()\r\n        };\r\n        \r\n        assert!(session.vcoin_spent \u003c= session.max_spend);\r\n    }\r\n\r\n    #[test]\r\n    fn test_invariant_daily_subsidy_bounded() {\r\n        let stats = UserGaslessStats {\r\n            today_subsidized: 30,\r\n            ..Default::default()\r\n        };\r\n        \r\n        assert!(stats.today_subsidized \u003c= MAX_SUBSIDIZED_TX_PER_USER);\r\n    }\r\n}\r\n\r\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","gasless-protocol","tests","admin.rs"],"content":"//! Integration tests for gasless-protocol admin instructions\r\n\r\nmod common;\r\n\r\nuse common::*;\r\nuse solana_sdk::signature::{Keypair, Signer};\r\n\r\n#[tokio::test]\r\nasync fn test_set_paused_true() {\r\n    let ctx = TestContext::new().await;\r\n    \r\n    let (config_pda, _bump) = ctx.get_config_pda();\r\n    \r\n    let ix = create_set_paused_ix(\r\n        \u0026ctx.program_id,\r\n        \u0026ctx.payer.pubkey(),\r\n        \u0026config_pda,\r\n        true,\r\n    );\r\n    \r\n    assert_eq!(ix.data[8], 1);\r\n}\r\n\r\n#[tokio::test]\r\nasync fn test_set_paused_false() {\r\n    let ctx = TestContext::new().await;\r\n    \r\n    let (config_pda, _bump) = ctx.get_config_pda();\r\n    \r\n    let ix = create_set_paused_ix(\r\n        \u0026ctx.program_id,\r\n        \u0026ctx.payer.pubkey(),\r\n        \u0026config_pda,\r\n        false,\r\n    );\r\n    \r\n    assert_eq!(ix.data[8], 0);\r\n}\r\n\r\n#[tokio::test]\r\nasync fn test_set_paused_unauthorized() {\r\n    let ctx = TestContext::new().await;\r\n    \r\n    let (config_pda, _bump) = ctx.get_config_pda();\r\n    let unauthorized = Keypair::new();\r\n    \r\n    let ix = create_set_paused_ix(\r\n        \u0026ctx.program_id,\r\n        \u0026unauthorized.pubkey(),\r\n        \u0026config_pda,\r\n        true,\r\n    );\r\n    \r\n    assert_eq!(ix.accounts[1].pubkey, unauthorized.pubkey());\r\n}\r\n\r\n#[tokio::test]\r\nasync fn test_set_paused_toggle() {\r\n    let ctx = TestContext::new().await;\r\n    \r\n    let (config_pda, _bump) = ctx.get_config_pda();\r\n    \r\n    for paused in [true, false, true, false] {\r\n        let ix = create_set_paused_ix(\r\n            \u0026ctx.program_id,\r\n            \u0026ctx.payer.pubkey(),\r\n            \u0026config_pda,\r\n            paused,\r\n        );\r\n        \r\n        assert_eq!(ix.data[8], if paused { 1 } else { 0 });\r\n    }\r\n}\r\n\r\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","gasless-protocol","tests","common","mod.rs"],"content":"//! Common test utilities for gasless-protocol integration tests\r\n\r\nuse anchor_lang::prelude::*;\r\nuse solana_program_test::*;\r\nuse solana_sdk::{\r\n    account::Account,\r\n    hash::Hash,\r\n    instruction::{AccountMeta, Instruction},\r\n    pubkey::Pubkey,\r\n    signature::{Keypair, Signer},\r\n    transaction::Transaction,\r\n};\r\n\r\npub const GASLESS_CONFIG_SEED: \u0026[u8] = b\"gasless-config\";\r\npub const SESSION_KEY_SEED: \u0026[u8] = b\"session-key\";\r\npub const USER_GASLESS_SEED: \u0026[u8] = b\"user-gasless\";\r\n\r\npub struct TestContext {\r\n    pub banks_client: BanksClient,\r\n    pub payer: Keypair,\r\n    pub recent_blockhash: Hash,\r\n    pub program_id: Pubkey,\r\n}\r\n\r\nimpl TestContext {\r\n    pub async fn new() -\u003e Self {\r\n        let program_id = gasless_protocol::id();\r\n        let program_test = ProgramTest::new(\r\n            \"gasless_protocol\",\r\n            program_id,\r\n            processor!(gasless_protocol::entry),\r\n        );\r\n\r\n        let (banks_client, payer, recent_blockhash) = program_test.start().await;\r\n\r\n        Self {\r\n            banks_client,\r\n            payer,\r\n            recent_blockhash,\r\n            program_id,\r\n        }\r\n    }\r\n\r\n    pub async fn refresh_blockhash(\u0026mut self) {\r\n        self.recent_blockhash = self.banks_client.get_latest_blockhash().await.unwrap();\r\n    }\r\n\r\n    pub async fn get_account(\u0026mut self, pubkey: Pubkey) -\u003e Option\u003cAccount\u003e {\r\n        self.banks_client.get_account(pubkey).await.unwrap()\r\n    }\r\n\r\n    pub fn get_config_pda(\u0026self) -\u003e (Pubkey, u8) {\r\n        Pubkey::find_program_address(\u0026[GASLESS_CONFIG_SEED], \u0026self.program_id)\r\n    }\r\n\r\n    pub fn get_session_pda(\u0026self, user: \u0026Pubkey, session_pubkey: \u0026Pubkey) -\u003e (Pubkey, u8) {\r\n        Pubkey::find_program_address(\r\n            \u0026[SESSION_KEY_SEED, user.as_ref(), session_pubkey.as_ref()],\r\n            \u0026self.program_id,\r\n        )\r\n    }\r\n\r\n    pub fn get_user_gasless_pda(\u0026self, user: \u0026Pubkey) -\u003e (Pubkey, u8) {\r\n        Pubkey::find_program_address(\u0026[USER_GASLESS_SEED, user.as_ref()], \u0026self.program_id)\r\n    }\r\n\r\n    pub async fn process_transaction(\r\n        \u0026mut self,\r\n        instructions: \u0026[Instruction],\r\n        signers: \u0026[\u0026Keypair],\r\n    ) -\u003e Result\u003c(), BanksClientError\u003e {\r\n        let mut all_signers = vec![\u0026self.payer];\r\n        all_signers.extend(signers);\r\n        \r\n        let tx = Transaction::new_signed_with_payer(\r\n            instructions,\r\n            Some(\u0026self.payer.pubkey()),\r\n            \u0026all_signers,\r\n            self.recent_blockhash,\r\n        );\r\n        \r\n        let result = self.banks_client.process_transaction(tx).await;\r\n        self.refresh_blockhash().await;\r\n        result\r\n    }\r\n}\r\n\r\npub fn create_initialize_ix(\r\n    program_id: \u0026Pubkey,\r\n    authority: \u0026Pubkey,\r\n    config: \u0026Pubkey,\r\n    fee_payer: \u0026Pubkey,\r\n    daily_budget: u64,\r\n) -\u003e Instruction {\r\n    let mut data = vec![0u8; 8 + 32 + 8];\r\n    let discriminator = anchor_lang::solana_program::hash::hash(b\"global:initialize\").to_bytes();\r\n    data[..8].copy_from_slice(\u0026discriminator[..8]);\r\n    data[8..40].copy_from_slice(fee_payer.as_ref());\r\n    data[40..48].copy_from_slice(\u0026daily_budget.to_le_bytes());\r\n\r\n    Instruction {\r\n        program_id: *program_id,\r\n        accounts: vec![\r\n            AccountMeta::new(*config, false),\r\n            AccountMeta::new(*authority, true),\r\n            AccountMeta::new_readonly(solana_sdk::system_program::id(), false),\r\n        ],\r\n        data,\r\n    }\r\n}\r\n\r\npub fn create_session_key_ix(\r\n    program_id: \u0026Pubkey,\r\n    user: \u0026Pubkey,\r\n    config: \u0026Pubkey,\r\n    session: \u0026Pubkey,\r\n    session_pubkey: \u0026Pubkey,\r\n    scope: u16,\r\n    duration_seconds: i64,\r\n    max_actions: u32,\r\n    max_spend: u64,\r\n    fee_method: u8,\r\n) -\u003e Instruction {\r\n    let mut data = vec![0u8; 8 + 32 + 2 + 8 + 4 + 8 + 1];\r\n    let discriminator = anchor_lang::solana_program::hash::hash(b\"global:create_session_key\").to_bytes();\r\n    data[..8].copy_from_slice(\u0026discriminator[..8]);\r\n    data[8..40].copy_from_slice(session_pubkey.as_ref());\r\n    data[40..42].copy_from_slice(\u0026scope.to_le_bytes());\r\n    data[42..50].copy_from_slice(\u0026duration_seconds.to_le_bytes());\r\n    data[50..54].copy_from_slice(\u0026max_actions.to_le_bytes());\r\n    data[54..62].copy_from_slice(\u0026max_spend.to_le_bytes());\r\n    data[62] = fee_method;\r\n\r\n    Instruction {\r\n        program_id: *program_id,\r\n        accounts: vec![\r\n            AccountMeta::new(*config, false),\r\n            AccountMeta::new(*session, false),\r\n            AccountMeta::new(*user, true),\r\n            AccountMeta::new_readonly(solana_sdk::system_program::id(), false),\r\n        ],\r\n        data,\r\n    }\r\n}\r\n\r\npub fn create_execute_session_action_ix(\r\n    program_id: \u0026Pubkey,\r\n    user: \u0026Pubkey,\r\n    config: \u0026Pubkey,\r\n    session: \u0026Pubkey,\r\n    action_type: u16,\r\n    spend_amount: u64,\r\n) -\u003e Instruction {\r\n    let mut data = vec![0u8; 8 + 2 + 8];\r\n    let discriminator = anchor_lang::solana_program::hash::hash(b\"global:execute_session_action\").to_bytes();\r\n    data[..8].copy_from_slice(\u0026discriminator[..8]);\r\n    data[8..10].copy_from_slice(\u0026action_type.to_le_bytes());\r\n    data[10..18].copy_from_slice(\u0026spend_amount.to_le_bytes());\r\n\r\n    Instruction {\r\n        program_id: *program_id,\r\n        accounts: vec![\r\n            AccountMeta::new(*config, false),\r\n            AccountMeta::new(*session, false),\r\n            AccountMeta::new(*user, true),\r\n        ],\r\n        data,\r\n    }\r\n}\r\n\r\npub fn create_deduct_vcoin_fee_ix(\r\n    program_id: \u0026Pubkey,\r\n    user: \u0026Pubkey,\r\n    config: \u0026Pubkey,\r\n    amount: u64,\r\n) -\u003e Instruction {\r\n    let mut data = vec![0u8; 8 + 8];\r\n    let discriminator = anchor_lang::solana_program::hash::hash(b\"global:deduct_vcoin_fee\").to_bytes();\r\n    data[..8].copy_from_slice(\u0026discriminator[..8]);\r\n    data[8..16].copy_from_slice(\u0026amount.to_le_bytes());\r\n\r\n    Instruction {\r\n        program_id: *program_id,\r\n        accounts: vec![\r\n            AccountMeta::new(*config, false),\r\n            AccountMeta::new(*user, true),\r\n            AccountMeta::new_readonly(spl_token_2022::id(), false),\r\n        ],\r\n        data,\r\n    }\r\n}\r\n\r\npub fn create_set_paused_ix(\r\n    program_id: \u0026Pubkey,\r\n    authority: \u0026Pubkey,\r\n    config: \u0026Pubkey,\r\n    paused: bool,\r\n) -\u003e Instruction {\r\n    let mut data = vec![0u8; 8 + 1];\r\n    let discriminator = anchor_lang::solana_program::hash::hash(b\"global:set_paused\").to_bytes();\r\n    data[..8].copy_from_slice(\u0026discriminator[..8]);\r\n    data[8] = if paused { 1 } else { 0 };\r\n\r\n    Instruction {\r\n        program_id: *program_id,\r\n        accounts: vec![\r\n            AccountMeta::new(*config, false),\r\n            AccountMeta::new(*authority, true),\r\n        ],\r\n        data,\r\n    }\r\n}\r\n\r\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","gasless-protocol","tests","fee.rs"],"content":"//! Integration tests for gasless-protocol fee deduction instructions\r\n\r\nmod common;\r\n\r\nuse common::*;\r\nuse solana_sdk::signature::{Keypair, Signer};\r\n\r\n#[tokio::test]\r\nasync fn test_deduct_vcoin_fee_instruction_format() {\r\n    let ctx = TestContext::new().await;\r\n    \r\n    let (config_pda, _bump) = ctx.get_config_pda();\r\n    let user = Keypair::new();\r\n    \r\n    let ix = create_deduct_vcoin_fee_ix(\r\n        \u0026ctx.program_id,\r\n        \u0026user.pubkey(),\r\n        \u0026config_pda,\r\n        1_000_000_000,\r\n    );\r\n    \r\n    assert_eq!(ix.program_id, ctx.program_id);\r\n    assert_eq!(ix.accounts.len(), 3);\r\n}\r\n\r\n#[tokio::test]\r\nasync fn test_deduct_vcoin_fee_different_amounts() {\r\n    let ctx = TestContext::new().await;\r\n    \r\n    let (config_pda, _bump) = ctx.get_config_pda();\r\n    let user = Keypair::new();\r\n    \r\n    for amount in [5_000u64, 10_000, 100_000, 1_000_000] {\r\n        let ix = create_deduct_vcoin_fee_ix(\r\n            \u0026ctx.program_id,\r\n            \u0026user.pubkey(),\r\n            \u0026config_pda,\r\n            amount,\r\n        );\r\n        \r\n        assert_eq!(\u0026ix.data[8..16], \u0026amount.to_le_bytes());\r\n    }\r\n}\r\n\r\n#[tokio::test]\r\nasync fn test_deduct_vcoin_fee_zero_amount() {\r\n    let ctx = TestContext::new().await;\r\n    \r\n    let (config_pda, _bump) = ctx.get_config_pda();\r\n    let user = Keypair::new();\r\n    \r\n    let ix = create_deduct_vcoin_fee_ix(\r\n        \u0026ctx.program_id,\r\n        \u0026user.pubkey(),\r\n        \u0026config_pda,\r\n        0,\r\n    );\r\n    \r\n    assert_eq!(\u0026ix.data[8..16], \u00260u64.to_le_bytes());\r\n}\r\n\r\n#[tokio::test]\r\nasync fn test_deduct_vcoin_fee_multiple_users() {\r\n    let ctx = TestContext::new().await;\r\n    \r\n    let (config_pda, _bump) = ctx.get_config_pda();\r\n    \r\n    for i in 0..5 {\r\n        let user = Keypair::new();\r\n        \r\n        let ix = create_deduct_vcoin_fee_ix(\r\n            \u0026ctx.program_id,\r\n            \u0026user.pubkey(),\r\n            \u0026config_pda,\r\n            (i + 1) as u64 * 1_000_000,\r\n        );\r\n        \r\n        assert!(ix.accounts[1].is_signer);\r\n    }\r\n}\r\n\r\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","gasless-protocol","tests","initialize.rs"],"content":"//! Integration tests for gasless-protocol initialize instruction\r\n\r\nmod common;\r\n\r\nuse common::*;\r\nuse solana_sdk::signature::{Keypair, Signer};\r\n\r\n#[tokio::test]\r\nasync fn test_initialize_success() {\r\n    let ctx = TestContext::new().await;\r\n    \r\n    let (config_pda, _bump) = ctx.get_config_pda();\r\n    let fee_payer = Keypair::new();\r\n    let daily_budget = 10_000_000_000u64;\r\n    \r\n    let ix = create_initialize_ix(\r\n        \u0026ctx.program_id,\r\n        \u0026ctx.payer.pubkey(),\r\n        \u0026config_pda,\r\n        \u0026fee_payer.pubkey(),\r\n        daily_budget,\r\n    );\r\n    \r\n    assert_eq!(ix.program_id, ctx.program_id);\r\n    assert_eq!(ix.accounts.len(), 3);\r\n}\r\n\r\n#[tokio::test]\r\nasync fn test_initialize_with_fee_payer() {\r\n    let ctx = TestContext::new().await;\r\n    \r\n    let (config_pda, _bump) = ctx.get_config_pda();\r\n    let fee_payer = Keypair::new();\r\n    \r\n    let ix = create_initialize_ix(\r\n        \u0026ctx.program_id,\r\n        \u0026ctx.payer.pubkey(),\r\n        \u0026config_pda,\r\n        \u0026fee_payer.pubkey(),\r\n        10_000_000_000,\r\n    );\r\n    \r\n    assert_eq!(\u0026ix.data[8..40], fee_payer.pubkey().as_ref());\r\n}\r\n\r\n#[tokio::test]\r\nasync fn test_initialize_different_budgets() {\r\n    let ctx = TestContext::new().await;\r\n    \r\n    let (config_pda, _bump) = ctx.get_config_pda();\r\n    let fee_payer = Keypair::new();\r\n    \r\n    for budget in [1_000_000_000u64, 10_000_000_000, 100_000_000_000] {\r\n        let ix = create_initialize_ix(\r\n            \u0026ctx.program_id,\r\n            \u0026ctx.payer.pubkey(),\r\n            \u0026config_pda,\r\n            \u0026fee_payer.pubkey(),\r\n            budget,\r\n        );\r\n        \r\n        assert_eq!(\u0026ix.data[40..48], \u0026budget.to_le_bytes());\r\n    }\r\n}\r\n\r\n#[tokio::test]\r\nasync fn test_initialize_zero_budget() {\r\n    let ctx = TestContext::new().await;\r\n    \r\n    let (config_pda, _bump) = ctx.get_config_pda();\r\n    let fee_payer = Keypair::new();\r\n    \r\n    let ix = create_initialize_ix(\r\n        \u0026ctx.program_id,\r\n        \u0026ctx.payer.pubkey(),\r\n        \u0026config_pda,\r\n        \u0026fee_payer.pubkey(),\r\n        0,\r\n    );\r\n    \r\n    assert_eq!(\u0026ix.data[40..48], \u00260u64.to_le_bytes());\r\n}\r\n\r\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","gasless-protocol","tests","session.rs"],"content":"//! Integration tests for gasless-protocol session key instructions\r\n\r\nmod common;\r\n\r\nuse common::*;\r\nuse solana_sdk::signature::{Keypair, Signer};\r\n\r\nconst SESSION_DURATION: i64 = 24 * 60 * 60;\r\n\r\n#[tokio::test]\r\nasync fn test_create_session_key_instruction_format() {\r\n    let ctx = TestContext::new().await;\r\n    \r\n    let (config_pda, _bump) = ctx.get_config_pda();\r\n    let user = Keypair::new();\r\n    let session_keypair = Keypair::new();\r\n    let (session_pda, _) = ctx.get_session_pda(\u0026user.pubkey(), \u0026session_keypair.pubkey());\r\n    \r\n    let ix = create_session_key_ix(\r\n        \u0026ctx.program_id,\r\n        \u0026user.pubkey(),\r\n        \u0026config_pda,\r\n        \u0026session_pda,\r\n        \u0026session_keypair.pubkey(),\r\n        0xFFFF, // all scopes\r\n        SESSION_DURATION,\r\n        1000,\r\n        100_000_000_000_000,\r\n        0,\r\n    );\r\n    \r\n    assert_eq!(ix.program_id, ctx.program_id);\r\n    assert_eq!(ix.accounts.len(), 4);\r\n}\r\n\r\n#[tokio::test]\r\nasync fn test_create_session_key_different_scopes() {\r\n    let ctx = TestContext::new().await;\r\n    \r\n    let (config_pda, _bump) = ctx.get_config_pda();\r\n    let user = Keypair::new();\r\n    \r\n    for scope in [0x01u16, 0x03, 0x0F, 0xFF, 0xFFFF] {\r\n        let session_keypair = Keypair::new();\r\n        let (session_pda, _) = ctx.get_session_pda(\u0026user.pubkey(), \u0026session_keypair.pubkey());\r\n        \r\n        let ix = create_session_key_ix(\r\n            \u0026ctx.program_id,\r\n            \u0026user.pubkey(),\r\n            \u0026config_pda,\r\n            \u0026session_pda,\r\n            \u0026session_keypair.pubkey(),\r\n            scope,\r\n            SESSION_DURATION,\r\n            1000,\r\n            100_000_000_000_000,\r\n            0,\r\n        );\r\n        \r\n        assert_eq!(\u0026ix.data[40..42], \u0026scope.to_le_bytes());\r\n    }\r\n}\r\n\r\n#[tokio::test]\r\nasync fn test_create_session_key_different_durations() {\r\n    let ctx = TestContext::new().await;\r\n    \r\n    let (config_pda, _bump) = ctx.get_config_pda();\r\n    let user = Keypair::new();\r\n    \r\n    for duration in [3600i64, 7200, 86400, 172800] {\r\n        let session_keypair = Keypair::new();\r\n        let (session_pda, _) = ctx.get_session_pda(\u0026user.pubkey(), \u0026session_keypair.pubkey());\r\n        \r\n        let ix = create_session_key_ix(\r\n            \u0026ctx.program_id,\r\n            \u0026user.pubkey(),\r\n            \u0026config_pda,\r\n            \u0026session_pda,\r\n            \u0026session_keypair.pubkey(),\r\n            0xFFFF,\r\n            duration,\r\n            1000,\r\n            100_000_000_000_000,\r\n            0,\r\n        );\r\n        \r\n        assert_eq!(\u0026ix.data[42..50], \u0026duration.to_le_bytes());\r\n    }\r\n}\r\n\r\n#[tokio::test]\r\nasync fn test_create_session_key_different_fee_methods() {\r\n    let ctx = TestContext::new().await;\r\n    \r\n    let (config_pda, _bump) = ctx.get_config_pda();\r\n    let user = Keypair::new();\r\n    \r\n    for fee_method in 0..=2 {\r\n        let session_keypair = Keypair::new();\r\n        let (session_pda, _) = ctx.get_session_pda(\u0026user.pubkey(), \u0026session_keypair.pubkey());\r\n        \r\n        let ix = create_session_key_ix(\r\n            \u0026ctx.program_id,\r\n            \u0026user.pubkey(),\r\n            \u0026config_pda,\r\n            \u0026session_pda,\r\n            \u0026session_keypair.pubkey(),\r\n            0xFFFF,\r\n            SESSION_DURATION,\r\n            1000,\r\n            100_000_000_000_000,\r\n            fee_method,\r\n        );\r\n        \r\n        assert_eq!(ix.data[62], fee_method);\r\n    }\r\n}\r\n\r\n#[tokio::test]\r\nasync fn test_execute_session_action_instruction_format() {\r\n    let ctx = TestContext::new().await;\r\n    \r\n    let (config_pda, _bump) = ctx.get_config_pda();\r\n    let user = Keypair::new();\r\n    let session = Keypair::new();\r\n    \r\n    let ix = create_execute_session_action_ix(\r\n        \u0026ctx.program_id,\r\n        \u0026user.pubkey(),\r\n        \u0026config_pda,\r\n        \u0026session.pubkey(),\r\n        1, // tip action\r\n        1_000_000_000,\r\n    );\r\n    \r\n    assert_eq!(ix.program_id, ctx.program_id);\r\n    assert_eq!(ix.accounts.len(), 3);\r\n}\r\n\r\n#[tokio::test]\r\nasync fn test_execute_session_action_different_types() {\r\n    let ctx = TestContext::new().await;\r\n    \r\n    let (config_pda, _bump) = ctx.get_config_pda();\r\n    let user = Keypair::new();\r\n    let session = Keypair::new();\r\n    \r\n    for action_type in 0..=7 {\r\n        let ix = create_execute_session_action_ix(\r\n            \u0026ctx.program_id,\r\n            \u0026user.pubkey(),\r\n            \u0026config_pda,\r\n            \u0026session.pubkey(),\r\n            action_type,\r\n            1_000_000_000,\r\n        );\r\n        \r\n        assert_eq!(\u0026ix.data[8..10], \u0026action_type.to_le_bytes());\r\n    }\r\n}\r\n\r\n#[tokio::test]\r\nasync fn test_execute_session_action_different_amounts() {\r\n    let ctx = TestContext::new().await;\r\n    \r\n    let (config_pda, _bump) = ctx.get_config_pda();\r\n    let user = Keypair::new();\r\n    let session = Keypair::new();\r\n    \r\n    for amount in [0u64, 1_000_000_000, 10_000_000_000, 100_000_000_000] {\r\n        let ix = create_execute_session_action_ix(\r\n            \u0026ctx.program_id,\r\n            \u0026user.pubkey(),\r\n            \u0026config_pda,\r\n            \u0026session.pubkey(),\r\n            1,\r\n            amount,\r\n        );\r\n        \r\n        assert_eq!(\u0026ix.data[10..18], \u0026amount.to_le_bytes());\r\n    }\r\n}\r\n\r\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","governance-protocol","src","constants.rs"],"content":"/// Seeds\r\npub const GOV_CONFIG_SEED: \u0026[u8] = b\"gov-config\";\r\npub const PROPOSAL_SEED: \u0026[u8] = b\"proposal\";\r\npub const VOTE_RECORD_SEED: \u0026[u8] = b\"vote-record\";\r\npub const DELEGATION_SEED: \u0026[u8] = b\"delegation\";\r\npub const DELEGATE_STATS_SEED: \u0026[u8] = b\"delegate-stats\";\r\npub const PRIVATE_VOTING_SEED: \u0026[u8] = b\"private-voting\";\r\n\r\n/// Governance thresholds (in veVCoin)\r\npub const COMMUNITY_THRESHOLD: u64 = 1;\r\npub const DELEGATE_THRESHOLD: u64 = 1_000;\r\npub const COUNCIL_THRESHOLD: u64 = 10_000;\r\n\r\n/// Default governance parameters\r\npub const DEFAULT_VOTING_PERIOD: i64 = 7 * 24 * 60 * 60;  // 7 days\r\npub const DEFAULT_TIMELOCK_DELAY: i64 = 48 * 60 * 60;     // 48 hours\r\npub const DEFAULT_QUORUM: u64 = 1_000_000;                 // 1M effective votes\r\npub const DEFAULT_PROPOSAL_THRESHOLD: u64 = 1_000;         // 1000 veVCoin to propose\r\n\r\n/// Tier multipliers (x1000 for precision)\r\npub const TIER_MULT_NONE: u64 = 1000;      // 1.0x\r\npub const TIER_MULT_BRONZE: u64 = 1000;    // 1.0x\r\npub const TIER_MULT_SILVER: u64 = 2000;    // 2.0x\r\npub const TIER_MULT_GOLD: u64 = 5000;      // 5.0x\r\npub const TIER_MULT_PLATINUM: u64 = 10000; // 10.0x\r\n\r\n/// Anti-plutocracy threshold\r\npub const DIMINISHING_THRESHOLD: u64 = 100_000;\r\n\r\n/// ZK voting constants\r\npub const MIN_DECRYPTION_THRESHOLD: u8 = 3;\r\npub const MAX_COMMITTEE_SIZE: usize = 5;\r\n\r\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","governance-protocol","src","contexts","aggregate_revealed_votes.rs"],"content":"use anchor_lang::prelude::*;\r\nuse crate::constants::*;\r\nuse crate::errors::GovernanceError;\r\nuse crate::state::{Proposal, PrivateVotingConfig, GovernanceConfig};\r\n\r\n#[derive(Accounts)]\r\npub struct AggregateRevealedVotes\u003c'info\u003e {\r\n    #[account(\r\n        mut,\r\n        seeds = [PROPOSAL_SEED, proposal.id.to_le_bytes().as_ref()],\r\n        bump = proposal.bump\r\n    )]\r\n    pub proposal: Account\u003c'info, Proposal\u003e,\r\n    \r\n    #[account(\r\n        mut,\r\n        seeds = [PRIVATE_VOTING_SEED, proposal.key().as_ref()],\r\n        bump = private_voting_config.bump\r\n    )]\r\n    pub private_voting_config: Account\u003c'info, PrivateVotingConfig\u003e,\r\n    \r\n    #[account(\r\n        seeds = [GOV_CONFIG_SEED],\r\n        bump = governance_config.bump,\r\n        has_one = authority @ GovernanceError::Unauthorized\r\n    )]\r\n    pub governance_config: Account\u003c'info, GovernanceConfig\u003e,\r\n    \r\n    pub authority: Signer\u003c'info\u003e,\r\n}\r\n\r\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","governance-protocol","src","contexts","cast_private_vote.rs"],"content":"use anchor_lang::prelude::*;\r\nuse crate::constants::*;\r\nuse crate::state::{Proposal, PrivateVotingConfig, VoteRecord};\r\n\r\n#[derive(Accounts)]\r\npub struct CastPrivateVote\u003c'info\u003e {\r\n    #[account(\r\n        seeds = [PROPOSAL_SEED, proposal.id.to_le_bytes().as_ref()],\r\n        bump = proposal.bump\r\n    )]\r\n    pub proposal: Account\u003c'info, Proposal\u003e,\r\n    \r\n    #[account(\r\n        seeds = [PRIVATE_VOTING_SEED, proposal.key().as_ref()],\r\n        bump = private_voting_config.bump\r\n    )]\r\n    pub private_voting_config: Account\u003c'info, PrivateVotingConfig\u003e,\r\n    \r\n    #[account(\r\n        init,\r\n        payer = voter,\r\n        space = VoteRecord::LEN,\r\n        seeds = [VOTE_RECORD_SEED, proposal.key().as_ref(), voter.key().as_ref()],\r\n        bump\r\n    )]\r\n    pub vote_record: Account\u003c'info, VoteRecord\u003e,\r\n    \r\n    #[account(mut)]\r\n    pub voter: Signer\u003c'info\u003e,\r\n    \r\n    pub system_program: Program\u003c'info, System\u003e,\r\n}\r\n\r\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","governance-protocol","src","contexts","cast_vote.rs"],"content":"use anchor_lang::prelude::*;\r\nuse crate::constants::*;\r\nuse crate::state::{Proposal, VoteRecord};\r\n\r\n#[derive(Accounts)]\r\npub struct CastVote\u003c'info\u003e {\r\n    #[account(\r\n        mut,\r\n        seeds = [PROPOSAL_SEED, proposal.id.to_le_bytes().as_ref()],\r\n        bump = proposal.bump\r\n    )]\r\n    pub proposal: Account\u003c'info, Proposal\u003e,\r\n    \r\n    #[account(\r\n        init,\r\n        payer = voter,\r\n        space = VoteRecord::LEN,\r\n        seeds = [VOTE_RECORD_SEED, proposal.key().as_ref(), voter.key().as_ref()],\r\n        bump\r\n    )]\r\n    pub vote_record: Account\u003c'info, VoteRecord\u003e,\r\n    \r\n    #[account(mut)]\r\n    pub voter: Signer\u003c'info\u003e,\r\n    \r\n    pub system_program: Program\u003c'info, System\u003e,\r\n}\r\n\r\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","governance-protocol","src","contexts","create_proposal.rs"],"content":"use anchor_lang::prelude::*;\r\nuse crate::constants::*;\r\nuse crate::state::{GovernanceConfig, Proposal};\r\n\r\n#[derive(Accounts)]\r\npub struct CreateProposal\u003c'info\u003e {\r\n    #[account(\r\n        mut,\r\n        seeds = [GOV_CONFIG_SEED],\r\n        bump = governance_config.bump\r\n    )]\r\n    pub governance_config: Account\u003c'info, GovernanceConfig\u003e,\r\n    \r\n    #[account(\r\n        init,\r\n        payer = proposer,\r\n        space = Proposal::LEN,\r\n        seeds = [PROPOSAL_SEED, (governance_config.proposal_count + 1).to_le_bytes().as_ref()],\r\n        bump\r\n    )]\r\n    pub proposal: Account\u003c'info, Proposal\u003e,\r\n    \r\n    #[account(mut)]\r\n    pub proposer: Signer\u003c'info\u003e,\r\n    \r\n    pub system_program: Program\u003c'info, System\u003e,\r\n}\r\n\r\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","governance-protocol","src","contexts","delegate_votes.rs"],"content":"use anchor_lang::prelude::*;\r\nuse crate::constants::*;\r\nuse crate::state::{Delegation, DelegateStats};\r\n\r\n#[derive(Accounts)]\r\npub struct DelegateVotes\u003c'info\u003e {\r\n    #[account(\r\n        init,\r\n        payer = delegator,\r\n        space = Delegation::LEN,\r\n        seeds = [DELEGATION_SEED, delegator.key().as_ref()],\r\n        bump\r\n    )]\r\n    pub delegation: Account\u003c'info, Delegation\u003e,\r\n    \r\n    #[account(\r\n        init_if_needed,\r\n        payer = delegator,\r\n        space = DelegateStats::LEN,\r\n        seeds = [DELEGATE_STATS_SEED, delegate.key().as_ref()],\r\n        bump\r\n    )]\r\n    pub delegate_stats: Account\u003c'info, DelegateStats\u003e,\r\n    \r\n    #[account(mut)]\r\n    pub delegator: Signer\u003c'info\u003e,\r\n    \r\n    /// CHECK: Delegate receiving voting power\r\n    pub delegate: UncheckedAccount\u003c'info\u003e,\r\n    \r\n    pub system_program: Program\u003c'info, System\u003e,\r\n}\r\n\r\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","governance-protocol","src","contexts","enable_private_voting.rs"],"content":"use anchor_lang::prelude::*;\r\nuse crate::constants::*;\r\nuse crate::state::{Proposal, PrivateVotingConfig};\r\n\r\n#[derive(Accounts)]\r\npub struct EnablePrivateVoting\u003c'info\u003e {\r\n    #[account(\r\n        seeds = [PROPOSAL_SEED, proposal.id.to_le_bytes().as_ref()],\r\n        bump = proposal.bump,\r\n        has_one = proposer\r\n    )]\r\n    pub proposal: Account\u003c'info, Proposal\u003e,\r\n    \r\n    #[account(\r\n        init,\r\n        payer = proposer,\r\n        space = PrivateVotingConfig::LEN,\r\n        seeds = [PRIVATE_VOTING_SEED, proposal.key().as_ref()],\r\n        bump\r\n    )]\r\n    pub private_voting_config: Account\u003c'info, PrivateVotingConfig\u003e,\r\n    \r\n    #[account(mut)]\r\n    pub proposer: Signer\u003c'info\u003e,\r\n    \r\n    pub system_program: Program\u003c'info, System\u003e,\r\n}\r\n\r\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","governance-protocol","src","contexts","execute_proposal.rs"],"content":"use anchor_lang::prelude::*;\r\nuse crate::constants::PROPOSAL_SEED;\r\nuse crate::state::Proposal;\r\n\r\n#[derive(Accounts)]\r\npub struct ExecuteProposal\u003c'info\u003e {\r\n    #[account(\r\n        mut,\r\n        seeds = [PROPOSAL_SEED, proposal.id.to_le_bytes().as_ref()],\r\n        bump = proposal.bump\r\n    )]\r\n    pub proposal: Account\u003c'info, Proposal\u003e,\r\n    \r\n    pub executor: Signer\u003c'info\u003e,\r\n}\r\n\r\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","governance-protocol","src","contexts","finalize_proposal.rs"],"content":"use anchor_lang::prelude::*;\r\nuse crate::constants::*;\r\nuse crate::state::{GovernanceConfig, Proposal};\r\n\r\n#[derive(Accounts)]\r\npub struct FinalizeProposal\u003c'info\u003e {\r\n    #[account(\r\n        seeds = [GOV_CONFIG_SEED],\r\n        bump = governance_config.bump\r\n    )]\r\n    pub governance_config: Account\u003c'info, GovernanceConfig\u003e,\r\n    \r\n    #[account(\r\n        mut,\r\n        seeds = [PROPOSAL_SEED, proposal.id.to_le_bytes().as_ref()],\r\n        bump = proposal.bump\r\n    )]\r\n    pub proposal: Account\u003c'info, Proposal\u003e,\r\n    \r\n    pub finalizer: Signer\u003c'info\u003e,\r\n}\r\n\r\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","governance-protocol","src","contexts","get_proposal.rs"],"content":"use anchor_lang::prelude::*;\r\nuse crate::constants::PROPOSAL_SEED;\r\nuse crate::state::Proposal;\r\n\r\n#[derive(Accounts)]\r\npub struct GetProposal\u003c'info\u003e {\r\n    #[account(\r\n        seeds = [PROPOSAL_SEED, proposal.id.to_le_bytes().as_ref()],\r\n        bump = proposal.bump\r\n    )]\r\n    pub proposal: Account\u003c'info, Proposal\u003e,\r\n}\r\n\r\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","governance-protocol","src","contexts","initialize.rs"],"content":"use anchor_lang::prelude::*;\r\nuse crate::constants::GOV_CONFIG_SEED;\r\nuse crate::state::GovernanceConfig;\r\n\r\n#[derive(Accounts)]\r\npub struct Initialize\u003c'info\u003e {\r\n    #[account(\r\n        init,\r\n        payer = authority,\r\n        space = GovernanceConfig::LEN,\r\n        seeds = [GOV_CONFIG_SEED],\r\n        bump\r\n    )]\r\n    pub governance_config: Account\u003c'info, GovernanceConfig\u003e,\r\n    \r\n    #[account(mut)]\r\n    pub authority: Signer\u003c'info\u003e,\r\n    \r\n    pub system_program: Program\u003c'info, System\u003e,\r\n}\r\n\r\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","governance-protocol","src","contexts","initiate_reveal.rs"],"content":"use anchor_lang::prelude::*;\r\nuse crate::constants::*;\r\nuse crate::state::{Proposal, PrivateVotingConfig};\r\n\r\n#[derive(Accounts)]\r\npub struct InitiateReveal\u003c'info\u003e {\r\n    #[account(\r\n        seeds = [PROPOSAL_SEED, proposal.id.to_le_bytes().as_ref()],\r\n        bump = proposal.bump\r\n    )]\r\n    pub proposal: Account\u003c'info, Proposal\u003e,\r\n    \r\n    #[account(\r\n        mut,\r\n        seeds = [PRIVATE_VOTING_SEED, proposal.key().as_ref()],\r\n        bump = private_voting_config.bump\r\n    )]\r\n    pub private_voting_config: Account\u003c'info, PrivateVotingConfig\u003e,\r\n    \r\n    pub initiator: Signer\u003c'info\u003e,\r\n}\r\n\r\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","governance-protocol","src","contexts","mod.rs"],"content":"pub mod initialize;\r\npub mod create_proposal;\r\npub mod cast_vote;\r\npub mod cast_private_vote;\r\npub mod enable_private_voting;\r\npub mod initiate_reveal;\r\npub mod submit_decryption_share;\r\npub mod aggregate_revealed_votes;\r\npub mod finalize_proposal;\r\npub mod execute_proposal;\r\npub mod delegate_votes;\r\npub mod revoke_delegation;\r\npub mod update_config;\r\npub mod update_authority;\r\npub mod get_proposal;\r\n\r\npub use initialize::*;\r\npub use create_proposal::*;\r\npub use cast_vote::*;\r\npub use cast_private_vote::*;\r\npub use enable_private_voting::*;\r\npub use initiate_reveal::*;\r\npub use submit_decryption_share::*;\r\npub use aggregate_revealed_votes::*;\r\npub use finalize_proposal::*;\r\npub use execute_proposal::*;\r\npub use delegate_votes::*;\r\npub use revoke_delegation::*;\r\npub use update_config::*;\r\npub use update_authority::*;\r\npub use get_proposal::*;\r\n\r\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","governance-protocol","src","contexts","revoke_delegation.rs"],"content":"use anchor_lang::prelude::*;\r\nuse crate::constants::*;\r\nuse crate::state::{Delegation, DelegateStats};\r\n\r\n#[derive(Accounts)]\r\npub struct RevokeDelegation\u003c'info\u003e {\r\n    #[account(\r\n        mut,\r\n        close = delegator,\r\n        seeds = [DELEGATION_SEED, delegator.key().as_ref()],\r\n        bump = delegation.bump,\r\n        has_one = delegator\r\n    )]\r\n    pub delegation: Account\u003c'info, Delegation\u003e,\r\n    \r\n    #[account(\r\n        mut,\r\n        seeds = [DELEGATE_STATS_SEED, delegation.delegate.as_ref()],\r\n        bump = delegate_stats.bump\r\n    )]\r\n    pub delegate_stats: Account\u003c'info, DelegateStats\u003e,\r\n    \r\n    #[account(mut)]\r\n    pub delegator: Signer\u003c'info\u003e,\r\n}\r\n\r\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","governance-protocol","src","contexts","submit_decryption_share.rs"],"content":"use anchor_lang::prelude::*;\r\nuse crate::constants::PRIVATE_VOTING_SEED;\r\nuse crate::state::PrivateVotingConfig;\r\n\r\n#[derive(Accounts)]\r\npub struct SubmitDecryptionShare\u003c'info\u003e {\r\n    #[account(\r\n        mut,\r\n        seeds = [PRIVATE_VOTING_SEED, private_voting_config.proposal.as_ref()],\r\n        bump = private_voting_config.bump\r\n    )]\r\n    pub private_voting_config: Account\u003c'info, PrivateVotingConfig\u003e,\r\n    \r\n    pub committee_member: Signer\u003c'info\u003e,\r\n}\r\n\r\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","governance-protocol","src","contexts","update_authority.rs"],"content":"use anchor_lang::prelude::*;\r\nuse crate::constants::GOV_CONFIG_SEED;\r\nuse crate::errors::GovernanceError;\r\nuse crate::state::GovernanceConfig;\r\n\r\n#[derive(Accounts)]\r\npub struct UpdateAuthority\u003c'info\u003e {\r\n    #[account(\r\n        mut,\r\n        seeds = [GOV_CONFIG_SEED],\r\n        bump = governance_config.bump,\r\n        has_one = authority @ GovernanceError::Unauthorized\r\n    )]\r\n    pub governance_config: Account\u003c'info, GovernanceConfig\u003e,\r\n    \r\n    pub authority: Signer\u003c'info\u003e,\r\n}\r\n\r\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","governance-protocol","src","contexts","update_config.rs"],"content":"use anchor_lang::prelude::*;\r\nuse crate::constants::GOV_CONFIG_SEED;\r\nuse crate::errors::GovernanceError;\r\nuse crate::state::GovernanceConfig;\r\n\r\n#[derive(Accounts)]\r\npub struct UpdateConfig\u003c'info\u003e {\r\n    #[account(\r\n        mut,\r\n        seeds = [GOV_CONFIG_SEED],\r\n        bump = governance_config.bump,\r\n        has_one = authority @ GovernanceError::Unauthorized\r\n    )]\r\n    pub governance_config: Account\u003c'info, GovernanceConfig\u003e,\r\n    \r\n    pub authority: Signer\u003c'info\u003e,\r\n}\r\n\r\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","governance-protocol","src","errors.rs"],"content":"use anchor_lang::prelude::*;\r\n\r\n#[error_code]\r\npub enum GovernanceError {\r\n    #[msg(\"Unauthorized: Only the authority can perform this action\")]\r\n    Unauthorized,\r\n    #[msg(\"Governance is paused\")]\r\n    GovernancePaused,\r\n    #[msg(\"Insufficient veVCoin to create proposal\")]\r\n    InsufficientVeVCoin,\r\n    #[msg(\"Proposal not found\")]\r\n    ProposalNotFound,\r\n    #[msg(\"Voting period has not started\")]\r\n    VotingNotStarted,\r\n    #[msg(\"Voting period has ended\")]\r\n    VotingEnded,\r\n    #[msg(\"Voting period has not ended\")]\r\n    VotingNotEnded,\r\n    #[msg(\"Already voted on this proposal\")]\r\n    AlreadyVoted,\r\n    #[msg(\"Invalid vote choice\")]\r\n    InvalidVoteChoice,\r\n    #[msg(\"Quorum not reached\")]\r\n    QuorumNotReached,\r\n    #[msg(\"Proposal already executed\")]\r\n    ProposalAlreadyExecuted,\r\n    #[msg(\"Timelock not expired\")]\r\n    TimelockNotExpired,\r\n    #[msg(\"Cannot delegate to self\")]\r\n    CannotDelegateSelf,\r\n    #[msg(\"Delegation already exists\")]\r\n    DelegationExists,\r\n    #[msg(\"Delegation not found\")]\r\n    DelegationNotFound,\r\n    #[msg(\"ZK voting not enabled for this proposal\")]\r\n    ZKVotingNotEnabled,\r\n    #[msg(\"ZK reveal not started\")]\r\n    RevealNotStarted,\r\n    #[msg(\"ZK reveal already complete\")]\r\n    RevealAlreadyComplete,\r\n    #[msg(\"Invalid decryption share\")]\r\n    InvalidDecryptionShare,\r\n    #[msg(\"Invalid ZK proof\")]\r\n    InvalidZKProof,\r\n    #[msg(\"Arithmetic overflow\")]\r\n    Overflow,\r\n}\r\n\r\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","governance-protocol","src","events.rs"],"content":"use anchor_lang::prelude::*;\r\n\r\n#[event]\r\npub struct ProposalCreated {\r\n    pub id: u64,\r\n    pub proposer: Pubkey,\r\n    pub proposal_type: u8,\r\n    pub start_time: i64,\r\n    pub end_time: i64,\r\n}\r\n\r\n#[event]\r\npub struct VoteCast {\r\n    pub proposal_id: u64,\r\n    pub voter: Pubkey,\r\n    pub choice: u8,\r\n    pub weight: u64,\r\n    pub is_private: bool,\r\n}\r\n\r\n#[event]\r\npub struct ProposalExecuted {\r\n    pub id: u64,\r\n    pub executor: Pubkey,\r\n    pub timestamp: i64,\r\n}\r\n\r\n#[event]\r\npub struct DelegationCreated {\r\n    pub delegator: Pubkey,\r\n    pub delegate: Pubkey,\r\n    pub amount: u64,\r\n    pub delegation_type: u8,\r\n}\r\n\r\n#[event]\r\npub struct ZKRevealComplete {\r\n    pub proposal_id: u64,\r\n    pub votes_for: u128,\r\n    pub votes_against: u128,\r\n    pub votes_abstain: u128,\r\n}\r\n\r\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","governance-protocol","src","instructions","admin","initialize.rs"],"content":"use anchor_lang::prelude::*;\r\nuse crate::constants::*;\r\nuse crate::contexts::Initialize;\r\n\r\npub fn handler(\r\n    ctx: Context\u003cInitialize\u003e,\r\n    staking_program: Pubkey,\r\n    five_a_program: Pubkey,\r\n) -\u003e Result\u003c()\u003e {\r\n    let config = \u0026mut ctx.accounts.governance_config;\r\n    \r\n    config.authority = ctx.accounts.authority.key();\r\n    config.staking_program = staking_program;\r\n    config.five_a_program = five_a_program;\r\n    config.proposal_threshold = DEFAULT_PROPOSAL_THRESHOLD;\r\n    config.quorum = DEFAULT_QUORUM;\r\n    config.voting_period = DEFAULT_VOTING_PERIOD;\r\n    config.timelock_delay = DEFAULT_TIMELOCK_DELAY;\r\n    config.proposal_count = 0;\r\n    config.treasury_balance = 200_000_000 * 1_000_000_000; // 200M VCoin\r\n    config.paused = false;\r\n    config.bump = ctx.bumps.governance_config;\r\n    \r\n    msg!(\"Governance protocol initialized\");\r\n    Ok(())\r\n}\r\n\r\n","traces":[{"line":5,"address":[],"length":0,"stats":{"Line":0}},{"line":10,"address":[],"length":0,"stats":{"Line":0}},{"line":12,"address":[],"length":0,"stats":{"Line":0}},{"line":13,"address":[],"length":0,"stats":{"Line":0}},{"line":14,"address":[],"length":0,"stats":{"Line":0}},{"line":15,"address":[],"length":0,"stats":{"Line":0}},{"line":16,"address":[],"length":0,"stats":{"Line":0}},{"line":17,"address":[],"length":0,"stats":{"Line":0}},{"line":18,"address":[],"length":0,"stats":{"Line":0}},{"line":19,"address":[],"length":0,"stats":{"Line":0}},{"line":20,"address":[],"length":0,"stats":{"Line":0}},{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":15},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","governance-protocol","src","instructions","admin","mod.rs"],"content":"pub mod initialize;\r\npub mod update_config;\r\npub mod set_paused;\r\npub mod update_authority;\r\n\r\npub use initialize::*;\r\npub use update_config::*;\r\npub use set_paused::*;\r\npub use update_authority::*;\r\n\r\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","governance-protocol","src","instructions","admin","set_paused.rs"],"content":"use anchor_lang::prelude::*;\r\nuse crate::contexts::UpdateConfig;\r\n\r\npub fn handler(ctx: Context\u003cUpdateConfig\u003e, paused: bool) -\u003e Result\u003c()\u003e {\r\n    ctx.accounts.governance_config.paused = paused;\r\n    msg!(\"Governance paused: {}\", paused);\r\n    Ok(())\r\n}\r\n\r\n","traces":[{"line":4,"address":[],"length":0,"stats":{"Line":0}},{"line":5,"address":[],"length":0,"stats":{"Line":0}},{"line":6,"address":[],"length":0,"stats":{"Line":0}},{"line":7,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":4},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","governance-protocol","src","instructions","admin","update_authority.rs"],"content":"use anchor_lang::prelude::*;\r\nuse crate::contexts::UpdateAuthority;\r\n\r\npub fn handler(ctx: Context\u003cUpdateAuthority\u003e, new_authority: Pubkey) -\u003e Result\u003c()\u003e {\r\n    ctx.accounts.governance_config.authority = new_authority;\r\n    msg!(\"Authority updated to: {}\", new_authority);\r\n    Ok(())\r\n}\r\n\r\n","traces":[{"line":4,"address":[],"length":0,"stats":{"Line":0}},{"line":5,"address":[],"length":0,"stats":{"Line":0}},{"line":6,"address":[],"length":0,"stats":{"Line":0}},{"line":7,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":4},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","governance-protocol","src","instructions","admin","update_config.rs"],"content":"use anchor_lang::prelude::*;\r\nuse crate::contexts::UpdateConfig;\r\n\r\npub fn handler(\r\n    ctx: Context\u003cUpdateConfig\u003e,\r\n    proposal_threshold: Option\u003cu64\u003e,\r\n    quorum: Option\u003cu64\u003e,\r\n    voting_period: Option\u003ci64\u003e,\r\n    timelock_delay: Option\u003ci64\u003e,\r\n) -\u003e Result\u003c()\u003e {\r\n    let config = \u0026mut ctx.accounts.governance_config;\r\n    \r\n    if let Some(threshold) = proposal_threshold {\r\n        config.proposal_threshold = threshold;\r\n    }\r\n    if let Some(q) = quorum {\r\n        config.quorum = q;\r\n    }\r\n    if let Some(period) = voting_period {\r\n        config.voting_period = period;\r\n    }\r\n    if let Some(delay) = timelock_delay {\r\n        config.timelock_delay = delay;\r\n    }\r\n    \r\n    msg!(\"Governance config updated\");\r\n    Ok(())\r\n}\r\n\r\n","traces":[{"line":4,"address":[],"length":0,"stats":{"Line":0}},{"line":11,"address":[],"length":0,"stats":{"Line":0}},{"line":13,"address":[],"length":0,"stats":{"Line":0}},{"line":14,"address":[],"length":0,"stats":{"Line":0}},{"line":16,"address":[],"length":0,"stats":{"Line":0}},{"line":17,"address":[],"length":0,"stats":{"Line":0}},{"line":19,"address":[],"length":0,"stats":{"Line":0}},{"line":20,"address":[],"length":0,"stats":{"Line":0}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":12},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","governance-protocol","src","instructions","delegation","delegate.rs"],"content":"use anchor_lang::prelude::*;\r\nuse crate::contexts::DelegateVotes;\r\nuse crate::errors::GovernanceError;\r\nuse crate::events::DelegationCreated;\r\n\r\npub fn handler(\r\n    ctx: Context\u003cDelegateVotes\u003e,\r\n    delegation_type: u8,\r\n    categories: u8,\r\n    vevcoin_amount: u64,\r\n    expires_at: i64,\r\n    revocable: bool,\r\n) -\u003e Result\u003c()\u003e {\r\n    let delegator_key = ctx.accounts.delegator.key();\r\n    let delegate_key = ctx.accounts.delegate.key();\r\n    \r\n    require!(delegator_key != delegate_key, GovernanceError::CannotDelegateSelf);\r\n    \r\n    let clock = Clock::get()?;\r\n    \r\n    let delegation = \u0026mut ctx.accounts.delegation;\r\n    delegation.delegator = delegator_key;\r\n    delegation.delegate = delegate_key;\r\n    delegation.delegation_type = delegation_type;\r\n    delegation.categories = categories;\r\n    delegation.delegated_amount = vevcoin_amount;\r\n    delegation.delegated_at = clock.unix_timestamp;\r\n    delegation.expires_at = expires_at;\r\n    delegation.revocable = revocable;\r\n    delegation.bump = ctx.bumps.delegation;\r\n    \r\n    // Update delegate stats\r\n    let delegate_stats = \u0026mut ctx.accounts.delegate_stats;\r\n    delegate_stats.delegate = delegate_key;\r\n    delegate_stats.unique_delegators = delegate_stats.unique_delegators.saturating_add(1);\r\n    delegate_stats.total_delegated_vevcoin = delegate_stats\r\n        .total_delegated_vevcoin\r\n        .saturating_add(vevcoin_amount);\r\n    delegate_stats.bump = ctx.bumps.delegate_stats;\r\n    \r\n    emit!(DelegationCreated {\r\n        delegator: delegator_key,\r\n        delegate: delegate_key,\r\n        amount: vevcoin_amount,\r\n        delegation_type,\r\n    });\r\n    \r\n    msg!(\"Delegation created: {} veVCoin\", vevcoin_amount);\r\n    Ok(())\r\n}\r\n\r\n","traces":[{"line":6,"address":[],"length":0,"stats":{"Line":0}},{"line":14,"address":[],"length":0,"stats":{"Line":0}},{"line":15,"address":[],"length":0,"stats":{"Line":0}},{"line":17,"address":[],"length":0,"stats":{"Line":0}},{"line":19,"address":[],"length":0,"stats":{"Line":0}},{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":29},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","governance-protocol","src","instructions","delegation","mod.rs"],"content":"pub mod delegate;\r\npub mod revoke;\r\n\r\npub use delegate::*;\r\npub use revoke::*;\r\n\r\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","governance-protocol","src","instructions","delegation","revoke.rs"],"content":"use anchor_lang::prelude::*;\r\nuse crate::contexts::RevokeDelegation;\r\n\r\npub fn handler(ctx: Context\u003cRevokeDelegation\u003e) -\u003e Result\u003c()\u003e {\r\n    let delegation = \u0026ctx.accounts.delegation;\r\n    let delegate_stats = \u0026mut ctx.accounts.delegate_stats;\r\n    \r\n    // Update delegate stats\r\n    delegate_stats.unique_delegators = delegate_stats.unique_delegators.saturating_sub(1);\r\n    delegate_stats.total_delegated_vevcoin = delegate_stats\r\n        .total_delegated_vevcoin\r\n        .saturating_sub(delegation.delegated_amount);\r\n    \r\n    msg!(\"Delegation revoked\");\r\n    Ok(())\r\n}\r\n\r\n","traces":[{"line":4,"address":[],"length":0,"stats":{"Line":0}},{"line":5,"address":[],"length":0,"stats":{"Line":0}},{"line":6,"address":[],"length":0,"stats":{"Line":0}},{"line":9,"address":[],"length":0,"stats":{"Line":0}},{"line":10,"address":[],"length":0,"stats":{"Line":0}},{"line":11,"address":[],"length":0,"stats":{"Line":0}},{"line":12,"address":[],"length":0,"stats":{"Line":0}},{"line":14,"address":[],"length":0,"stats":{"Line":0}},{"line":15,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":9},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","governance-protocol","src","instructions","mod.rs"],"content":"pub mod admin;\r\npub mod proposal;\r\npub mod vote;\r\npub mod delegation;\r\npub mod zk_voting;\r\npub mod query;\r\n\r\npub use admin::*;\r\npub use proposal::*;\r\npub use vote::*;\r\npub use delegation::*;\r\npub use zk_voting::*;\r\npub use query::*;\r\n\r\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","governance-protocol","src","instructions","proposal","create.rs"],"content":"use anchor_lang::prelude::*;\r\nuse crate::contexts::CreateProposal;\r\nuse crate::errors::GovernanceError;\r\nuse crate::events::ProposalCreated;\r\nuse crate::state::ProposalStatus;\r\n\r\npub fn handler(\r\n    ctx: Context\u003cCreateProposal\u003e,\r\n    title_hash: [u8; 32],\r\n    description_uri: String,\r\n    proposal_type: u8,\r\n    enable_private_voting: bool,\r\n) -\u003e Result\u003c()\u003e {\r\n    let config = \u0026mut ctx.accounts.governance_config;\r\n    require!(!config.paused, GovernanceError::GovernancePaused);\r\n    require!(description_uri.len() \u003c= 128, GovernanceError::Overflow);\r\n    \r\n    let clock = Clock::get()?;\r\n    \r\n    // Increment proposal count\r\n    config.proposal_count = config.proposal_count.saturating_add(1);\r\n    \r\n    let proposal = \u0026mut ctx.accounts.proposal;\r\n    proposal.id = config.proposal_count;\r\n    proposal.proposer = ctx.accounts.proposer.key();\r\n    proposal.title_hash = title_hash;\r\n    \r\n    let uri_bytes = description_uri.as_bytes();\r\n    proposal.description_uri[..uri_bytes.len()].copy_from_slice(uri_bytes);\r\n    proposal.uri_len = uri_bytes.len() as u8;\r\n    \r\n    proposal.proposal_type = proposal_type;\r\n    proposal.start_time = clock.unix_timestamp;\r\n    proposal.end_time = clock.unix_timestamp + config.voting_period;\r\n    proposal.votes_for = 0;\r\n    proposal.votes_against = 0;\r\n    proposal.votes_abstain = 0;\r\n    proposal.status = ProposalStatus::Active as u8;\r\n    proposal.execution_time = 0;\r\n    proposal.executed = false;\r\n    proposal.is_private_voting = enable_private_voting;\r\n    proposal.bump = ctx.bumps.proposal;\r\n    \r\n    emit!(ProposalCreated {\r\n        id: proposal.id,\r\n        proposer: proposal.proposer,\r\n        proposal_type,\r\n        start_time: proposal.start_time,\r\n        end_time: proposal.end_time,\r\n    });\r\n    \r\n    msg!(\"Proposal created: {}\", proposal.id);\r\n    Ok(())\r\n}\r\n\r\n","traces":[{"line":7,"address":[],"length":0,"stats":{"Line":0}},{"line":14,"address":[],"length":0,"stats":{"Line":0}},{"line":15,"address":[],"length":0,"stats":{"Line":0}},{"line":16,"address":[],"length":0,"stats":{"Line":0}},{"line":18,"address":[],"length":0,"stats":{"Line":0}},{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":32},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","governance-protocol","src","instructions","proposal","execute.rs"],"content":"use anchor_lang::prelude::*;\r\nuse crate::contexts::ExecuteProposal;\r\nuse crate::errors::GovernanceError;\r\nuse crate::events::ProposalExecuted;\r\nuse crate::state::ProposalStatus;\r\n\r\npub fn handler(ctx: Context\u003cExecuteProposal\u003e) -\u003e Result\u003c()\u003e {\r\n    let proposal = \u0026mut ctx.accounts.proposal;\r\n    \r\n    require!(\r\n        proposal.status == ProposalStatus::Passed as u8,\r\n        GovernanceError::ProposalNotFound\r\n    );\r\n    require!(!proposal.executed, GovernanceError::ProposalAlreadyExecuted);\r\n    \r\n    let clock = Clock::get()?;\r\n    require!(\r\n        clock.unix_timestamp \u003e= proposal.execution_time,\r\n        GovernanceError::TimelockNotExpired\r\n    );\r\n    \r\n    proposal.executed = true;\r\n    proposal.status = ProposalStatus::Executed as u8;\r\n    \r\n    emit!(ProposalExecuted {\r\n        id: proposal.id,\r\n        executor: ctx.accounts.executor.key(),\r\n        timestamp: clock.unix_timestamp,\r\n    });\r\n    \r\n    msg!(\"Proposal {} executed\", proposal.id);\r\n    Ok(())\r\n}\r\n\r\n","traces":[{"line":7,"address":[],"length":0,"stats":{"Line":0}},{"line":8,"address":[],"length":0,"stats":{"Line":0}},{"line":10,"address":[],"length":0,"stats":{"Line":0}},{"line":11,"address":[],"length":0,"stats":{"Line":0}},{"line":12,"address":[],"length":0,"stats":{"Line":0}},{"line":14,"address":[],"length":0,"stats":{"Line":0}},{"line":16,"address":[],"length":0,"stats":{"Line":0}},{"line":17,"address":[],"length":0,"stats":{"Line":0}},{"line":18,"address":[],"length":0,"stats":{"Line":0}},{"line":19,"address":[],"length":0,"stats":{"Line":0}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":18},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","governance-protocol","src","instructions","proposal","finalize.rs"],"content":"use anchor_lang::prelude::*;\r\nuse crate::contexts::FinalizeProposal;\r\nuse crate::errors::GovernanceError;\r\nuse crate::state::ProposalStatus;\r\n\r\npub fn handler(ctx: Context\u003cFinalizeProposal\u003e) -\u003e Result\u003c()\u003e {\r\n    let config = \u0026ctx.accounts.governance_config;\r\n    let proposal = \u0026mut ctx.accounts.proposal;\r\n    \r\n    let clock = Clock::get()?;\r\n    require!(\r\n        clock.unix_timestamp \u003e proposal.end_time,\r\n        GovernanceError::VotingNotEnded\r\n    );\r\n    \r\n    let total_votes = proposal.votes_for + proposal.votes_against + proposal.votes_abstain;\r\n    \r\n    // Check quorum\r\n    if total_votes \u003c config.quorum as u128 {\r\n        proposal.status = ProposalStatus::Rejected as u8;\r\n        msg!(\"Proposal rejected: quorum not reached\");\r\n        return Ok(());\r\n    }\r\n    \r\n    // Determine outcome\r\n    if proposal.votes_for \u003e proposal.votes_against {\r\n        proposal.status = ProposalStatus::Passed as u8;\r\n        proposal.execution_time = clock.unix_timestamp + config.timelock_delay;\r\n        msg!(\"Proposal passed, execution time: {}\", proposal.execution_time);\r\n    } else {\r\n        proposal.status = ProposalStatus::Rejected as u8;\r\n        msg!(\"Proposal rejected\");\r\n    }\r\n    \r\n    Ok(())\r\n}\r\n\r\n","traces":[{"line":6,"address":[],"length":0,"stats":{"Line":0}},{"line":7,"address":[],"length":0,"stats":{"Line":0}},{"line":8,"address":[],"length":0,"stats":{"Line":0}},{"line":10,"address":[],"length":0,"stats":{"Line":0}},{"line":11,"address":[],"length":0,"stats":{"Line":0}},{"line":12,"address":[],"length":0,"stats":{"Line":0}},{"line":13,"address":[],"length":0,"stats":{"Line":0}},{"line":16,"address":[],"length":0,"stats":{"Line":0}},{"line":19,"address":[],"length":0,"stats":{"Line":0}},{"line":20,"address":[],"length":0,"stats":{"Line":0}},{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":19},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","governance-protocol","src","instructions","proposal","mod.rs"],"content":"pub mod create;\r\npub mod finalize;\r\npub mod execute;\r\n\r\npub use create::*;\r\npub use finalize::*;\r\npub use execute::*;\r\n\r\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","governance-protocol","src","instructions","query","get_proposal.rs"],"content":"use anchor_lang::prelude::*;\r\nuse crate::contexts::GetProposal;\r\n\r\npub fn handler(ctx: Context\u003cGetProposal\u003e) -\u003e Result\u003c()\u003e {\r\n    let proposal = \u0026ctx.accounts.proposal;\r\n    msg!(\"ID: {}\", proposal.id);\r\n    msg!(\"Status: {}\", proposal.status);\r\n    msg!(\"For: {}\", proposal.votes_for);\r\n    msg!(\"Against: {}\", proposal.votes_against);\r\n    msg!(\"Abstain: {}\", proposal.votes_abstain);\r\n    Ok(())\r\n}\r\n\r\n","traces":[{"line":4,"address":[],"length":0,"stats":{"Line":0}},{"line":5,"address":[],"length":0,"stats":{"Line":0}},{"line":6,"address":[],"length":0,"stats":{"Line":0}},{"line":7,"address":[],"length":0,"stats":{"Line":0}},{"line":8,"address":[],"length":0,"stats":{"Line":0}},{"line":9,"address":[],"length":0,"stats":{"Line":0}},{"line":10,"address":[],"length":0,"stats":{"Line":0}},{"line":11,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":8},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","governance-protocol","src","instructions","query","mod.rs"],"content":"pub mod get_proposal;\r\n\r\npub use get_proposal::*;\r\n\r\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","governance-protocol","src","instructions","vote","cast.rs"],"content":"use anchor_lang::prelude::*;\r\nuse crate::contexts::CastVote;\r\nuse crate::errors::GovernanceError;\r\nuse crate::events::VoteCast;\r\nuse crate::state::{VoteChoice, calculate_voting_power};\r\n\r\npub fn handler(\r\n    ctx: Context\u003cCastVote\u003e,\r\n    choice: u8,\r\n    vevcoin_balance: u64,\r\n    five_a_score: u16,\r\n    tier: u8,\r\n) -\u003e Result\u003c()\u003e {\r\n    let proposal = \u0026mut ctx.accounts.proposal;\r\n    \r\n    // Verify voting period\r\n    let clock = Clock::get()?;\r\n    require!(\r\n        clock.unix_timestamp \u003e= proposal.start_time,\r\n        GovernanceError::VotingNotStarted\r\n    );\r\n    require!(\r\n        clock.unix_timestamp \u003c= proposal.end_time,\r\n        GovernanceError::VotingEnded\r\n    );\r\n    require!(\r\n        !proposal.is_private_voting,\r\n        GovernanceError::ZKVotingNotEnabled\r\n    );\r\n    \r\n    let vote_choice = VoteChoice::from_u8(choice)\r\n        .ok_or(GovernanceError::InvalidVoteChoice)?;\r\n    \r\n    // Calculate voting power\r\n    let vote_weight = calculate_voting_power(vevcoin_balance, five_a_score, tier);\r\n    \r\n    // Record vote\r\n    let vote_record = \u0026mut ctx.accounts.vote_record;\r\n    vote_record.voter = ctx.accounts.voter.key();\r\n    vote_record.proposal = proposal.key();\r\n    vote_record.vote_weight = vote_weight;\r\n    vote_record.vote_choice = choice;\r\n    vote_record.voted_at = clock.unix_timestamp;\r\n    vote_record.is_private = false;\r\n    vote_record.revealed = true;\r\n    vote_record.bump = ctx.bumps.vote_record;\r\n    \r\n    // Update proposal vote counts\r\n    match vote_choice {\r\n        VoteChoice::For =\u003e {\r\n            proposal.votes_for = proposal.votes_for.saturating_add(vote_weight as u128);\r\n        }\r\n        VoteChoice::Against =\u003e {\r\n            proposal.votes_against = proposal.votes_against.saturating_add(vote_weight as u128);\r\n        }\r\n        VoteChoice::Abstain =\u003e {\r\n            proposal.votes_abstain = proposal.votes_abstain.saturating_add(vote_weight as u128);\r\n        }\r\n    }\r\n    \r\n    emit!(VoteCast {\r\n        proposal_id: proposal.id,\r\n        voter: vote_record.voter,\r\n        choice,\r\n        weight: vote_weight,\r\n        is_private: false,\r\n    });\r\n    \r\n    msg!(\"Vote cast: {} with weight {}\", choice, vote_weight);\r\n    Ok(())\r\n}\r\n\r\n","traces":[{"line":7,"address":[],"length":0,"stats":{"Line":0}},{"line":14,"address":[],"length":0,"stats":{"Line":0}},{"line":17,"address":[],"length":0,"stats":{"Line":0}},{"line":18,"address":[],"length":0,"stats":{"Line":0}},{"line":19,"address":[],"length":0,"stats":{"Line":0}},{"line":20,"address":[],"length":0,"stats":{"Line":0}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":39},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","governance-protocol","src","instructions","vote","cast_private.rs"],"content":"use anchor_lang::prelude::*;\r\nuse crate::contexts::CastPrivateVote;\r\nuse crate::errors::GovernanceError;\r\nuse crate::events::VoteCast;\r\n\r\npub fn handler(\r\n    ctx: Context\u003cCastPrivateVote\u003e,\r\n    encrypted_choice: [u8; 32],\r\n    encrypted_weight: [u8; 32],\r\n    zk_proof: [u8; 128],\r\n) -\u003e Result\u003c()\u003e {\r\n    let proposal = \u0026ctx.accounts.proposal;\r\n    let private_config = \u0026ctx.accounts.private_voting_config;\r\n    \r\n    require!(proposal.is_private_voting, GovernanceError::ZKVotingNotEnabled);\r\n    require!(private_config.is_enabled, GovernanceError::ZKVotingNotEnabled);\r\n    \r\n    let clock = Clock::get()?;\r\n    require!(\r\n        clock.unix_timestamp \u003e= proposal.start_time,\r\n        GovernanceError::VotingNotStarted\r\n    );\r\n    require!(\r\n        clock.unix_timestamp \u003c= proposal.end_time,\r\n        GovernanceError::VotingEnded\r\n    );\r\n    \r\n    // Record private vote\r\n    let vote_record = \u0026mut ctx.accounts.vote_record;\r\n    vote_record.voter = ctx.accounts.voter.key();\r\n    vote_record.proposal = proposal.key();\r\n    vote_record.vote_weight = 0; // Hidden until reveal\r\n    vote_record.vote_choice = 0; // Hidden until reveal\r\n    vote_record.voted_at = clock.unix_timestamp;\r\n    vote_record.is_private = true;\r\n    vote_record.encrypted_choice = encrypted_choice;\r\n    vote_record.encrypted_weight = encrypted_weight;\r\n    vote_record.zk_proof = zk_proof;\r\n    vote_record.revealed = false;\r\n    vote_record.bump = ctx.bumps.vote_record;\r\n    \r\n    emit!(VoteCast {\r\n        proposal_id: proposal.id,\r\n        voter: vote_record.voter,\r\n        choice: 0, // Hidden\r\n        weight: 0, // Hidden\r\n        is_private: true,\r\n    });\r\n    \r\n    msg!(\"Private vote cast\");\r\n    Ok(())\r\n}\r\n\r\n","traces":[{"line":6,"address":[],"length":0,"stats":{"Line":0}},{"line":12,"address":[],"length":0,"stats":{"Line":0}},{"line":13,"address":[],"length":0,"stats":{"Line":0}},{"line":15,"address":[],"length":0,"stats":{"Line":0}},{"line":16,"address":[],"length":0,"stats":{"Line":0}},{"line":18,"address":[],"length":0,"stats":{"Line":0}},{"line":19,"address":[],"length":0,"stats":{"Line":0}},{"line":20,"address":[],"length":0,"stats":{"Line":0}},{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":32},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","governance-protocol","src","instructions","vote","mod.rs"],"content":"pub mod cast;\r\npub mod cast_private;\r\n\r\npub use cast::*;\r\npub use cast_private::*;\r\n\r\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","governance-protocol","src","instructions","zk_voting","aggregate_revealed_votes.rs"],"content":"use anchor_lang::prelude::*;\r\nuse crate::contexts::AggregateRevealedVotes;\r\nuse crate::errors::GovernanceError;\r\nuse crate::events::ZKRevealComplete;\r\n\r\npub fn handler(\r\n    ctx: Context\u003cAggregateRevealedVotes\u003e,\r\n    aggregated_for: u128,\r\n    aggregated_against: u128,\r\n    aggregated_abstain: u128,\r\n) -\u003e Result\u003c()\u003e {\r\n    let proposal = \u0026mut ctx.accounts.proposal;\r\n    let private_config = \u0026mut ctx.accounts.private_voting_config;\r\n    \r\n    require!(private_config.reveal_started, GovernanceError::RevealNotStarted);\r\n    require!(\r\n        private_config.shares_received \u003e= private_config.decryption_threshold,\r\n        GovernanceError::InvalidDecryptionShare\r\n    );\r\n    \r\n    // Update aggregated totals\r\n    private_config.aggregated_for = aggregated_for;\r\n    private_config.aggregated_against = aggregated_against;\r\n    private_config.aggregated_abstain = aggregated_abstain;\r\n    private_config.reveal_completed = true;\r\n    \r\n    // Update proposal with revealed totals\r\n    proposal.votes_for = aggregated_for;\r\n    proposal.votes_against = aggregated_against;\r\n    proposal.votes_abstain = aggregated_abstain;\r\n    \r\n    emit!(ZKRevealComplete {\r\n        proposal_id: proposal.id,\r\n        votes_for: aggregated_for,\r\n        votes_against: aggregated_against,\r\n        votes_abstain: aggregated_abstain,\r\n    });\r\n    \r\n    msg!(\"ZK reveal complete: For={}, Against={}, Abstain={}\", \r\n        aggregated_for, aggregated_against, aggregated_abstain);\r\n    Ok(())\r\n}\r\n\r\n","traces":[{"line":6,"address":[],"length":0,"stats":{"Line":0}},{"line":12,"address":[],"length":0,"stats":{"Line":0}},{"line":13,"address":[],"length":0,"stats":{"Line":0}},{"line":15,"address":[],"length":0,"stats":{"Line":0}},{"line":16,"address":[],"length":0,"stats":{"Line":0}},{"line":17,"address":[],"length":0,"stats":{"Line":0}},{"line":18,"address":[],"length":0,"stats":{"Line":0}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":21},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","governance-protocol","src","instructions","zk_voting","enable_private_voting.rs"],"content":"use anchor_lang::prelude::*;\r\nuse crate::contexts::EnablePrivateVoting;\r\n\r\npub fn handler(\r\n    ctx: Context\u003cEnablePrivateVoting\u003e,\r\n    encryption_pubkey: Pubkey,\r\n    decryption_committee: [Pubkey; 5],\r\n    committee_size: u8,\r\n    decryption_threshold: u8,\r\n) -\u003e Result\u003c()\u003e {\r\n    let private_config = \u0026mut ctx.accounts.private_voting_config;\r\n    \r\n    private_config.proposal = ctx.accounts.proposal.key();\r\n    private_config.is_enabled = true;\r\n    private_config.encryption_pubkey = encryption_pubkey;\r\n    private_config.decryption_committee = decryption_committee;\r\n    private_config.committee_size = committee_size;\r\n    private_config.decryption_threshold = decryption_threshold;\r\n    private_config.shares_received = 0;\r\n    private_config.reveal_started = false;\r\n    private_config.reveal_completed = false;\r\n    private_config.aggregated_for = 0;\r\n    private_config.aggregated_against = 0;\r\n    private_config.aggregated_abstain = 0;\r\n    private_config.bump = ctx.bumps.private_voting_config;\r\n    \r\n    msg!(\"Private voting enabled with {}-of-{} threshold\", \r\n        decryption_threshold, committee_size);\r\n    Ok(())\r\n}\r\n\r\n","traces":[{"line":4,"address":[],"length":0,"stats":{"Line":0}},{"line":11,"address":[],"length":0,"stats":{"Line":0}},{"line":13,"address":[],"length":0,"stats":{"Line":0}},{"line":14,"address":[],"length":0,"stats":{"Line":0}},{"line":15,"address":[],"length":0,"stats":{"Line":0}},{"line":16,"address":[],"length":0,"stats":{"Line":0}},{"line":17,"address":[],"length":0,"stats":{"Line":0}},{"line":18,"address":[],"length":0,"stats":{"Line":0}},{"line":19,"address":[],"length":0,"stats":{"Line":0}},{"line":20,"address":[],"length":0,"stats":{"Line":0}},{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":17},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","governance-protocol","src","instructions","zk_voting","initiate_reveal.rs"],"content":"use anchor_lang::prelude::*;\r\nuse crate::contexts::InitiateReveal;\r\nuse crate::errors::GovernanceError;\r\n\r\npub fn handler(ctx: Context\u003cInitiateReveal\u003e) -\u003e Result\u003c()\u003e {\r\n    let proposal = \u0026ctx.accounts.proposal;\r\n    let private_config = \u0026mut ctx.accounts.private_voting_config;\r\n    \r\n    let clock = Clock::get()?;\r\n    require!(\r\n        clock.unix_timestamp \u003e proposal.end_time,\r\n        GovernanceError::VotingNotEnded\r\n    );\r\n    require!(!private_config.reveal_started, GovernanceError::RevealAlreadyComplete);\r\n    \r\n    private_config.reveal_started = true;\r\n    \r\n    msg!(\"ZK reveal initiated for proposal {}\", proposal.id);\r\n    Ok(())\r\n}\r\n\r\n","traces":[{"line":5,"address":[],"length":0,"stats":{"Line":0}},{"line":6,"address":[],"length":0,"stats":{"Line":0}},{"line":7,"address":[],"length":0,"stats":{"Line":0}},{"line":9,"address":[],"length":0,"stats":{"Line":0}},{"line":10,"address":[],"length":0,"stats":{"Line":0}},{"line":11,"address":[],"length":0,"stats":{"Line":0}},{"line":12,"address":[],"length":0,"stats":{"Line":0}},{"line":14,"address":[],"length":0,"stats":{"Line":0}},{"line":16,"address":[],"length":0,"stats":{"Line":0}},{"line":18,"address":[],"length":0,"stats":{"Line":0}},{"line":19,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":11},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","governance-protocol","src","instructions","zk_voting","mod.rs"],"content":"pub mod enable_private_voting;\r\npub mod initiate_reveal;\r\npub mod submit_decryption_share;\r\npub mod aggregate_revealed_votes;\r\n\r\npub use enable_private_voting::*;\r\npub use initiate_reveal::*;\r\npub use submit_decryption_share::*;\r\npub use aggregate_revealed_votes::*;\r\n\r\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","governance-protocol","src","instructions","zk_voting","submit_decryption_share.rs"],"content":"use anchor_lang::prelude::*;\r\nuse crate::contexts::SubmitDecryptionShare;\r\nuse crate::errors::GovernanceError;\r\n\r\npub fn handler(\r\n    ctx: Context\u003cSubmitDecryptionShare\u003e,\r\n    _decryption_share: [u8; 32],\r\n    committee_index: u8,\r\n) -\u003e Result\u003c()\u003e {\r\n    let private_config = \u0026mut ctx.accounts.private_voting_config;\r\n    \r\n    require!(private_config.reveal_started, GovernanceError::RevealNotStarted);\r\n    require!(!private_config.reveal_completed, GovernanceError::RevealAlreadyComplete);\r\n    \r\n    // Verify committee member\r\n    let committee_member = ctx.accounts.committee_member.key();\r\n    require!(\r\n        private_config.decryption_committee[committee_index as usize] == committee_member,\r\n        GovernanceError::Unauthorized\r\n    );\r\n    \r\n    private_config.shares_received = private_config.shares_received.saturating_add(1);\r\n    \r\n    msg!(\"Decryption share {} of {} received\", \r\n        private_config.shares_received, \r\n        private_config.decryption_threshold);\r\n    Ok(())\r\n}\r\n\r\n","traces":[{"line":5,"address":[],"length":0,"stats":{"Line":0}},{"line":10,"address":[],"length":0,"stats":{"Line":0}},{"line":12,"address":[],"length":0,"stats":{"Line":0}},{"line":13,"address":[],"length":0,"stats":{"Line":0}},{"line":16,"address":[],"length":0,"stats":{"Line":0}},{"line":17,"address":[],"length":0,"stats":{"Line":0}},{"line":18,"address":[],"length":0,"stats":{"Line":0}},{"line":19,"address":[],"length":0,"stats":{"Line":0}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":13},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","governance-protocol","src","lib.rs"],"content":"use anchor_lang::prelude::*;\r\n\r\ndeclare_id!(\"3R256kBN9iXozjypQFRAmegBhd6HJqXWqdNG7Th78HYe\");\r\n\r\n/// Governance Protocol\r\n/// \r\n/// Full on-chain governance using veVCoin for voting power, boosted by 5A score.\r\n/// Supports ZK Private Voting where votes are encrypted during voting period.\r\n/// \r\n/// Voting Power Formula:\r\n/// - Quadratic: base_votes = sqrt(vcoin_tokens)\r\n/// - 5A Boost: five_a_boost = 1.0 + (five_a_score / 100)  // 1.0x to 2.0x\r\n/// - Tier Multiplier: Bronze=1.0x, Silver=2.0x, Gold=5.0x, Platinum=10.0x\r\n/// - effective_votes = base_votes * five_a_boost * tier_multiplier\r\n/// \r\n/// Governance Tiers:\r\n/// - Community (1+ veVCoin): Can vote\r\n/// - Delegate (1,000+ veVCoin): Can create proposals\r\n/// - Council (10,000+ veVCoin): Fast-track proposals\r\n\r\npub mod constants;\r\npub mod errors;\r\npub mod events;\r\npub mod state;\r\npub mod contexts;\r\npub mod instructions;\r\n\r\n#[cfg(test)]\r\nmod tests;\r\n\r\nuse contexts::*;\r\nuse instructions::*;\r\n\r\n#[program]\r\npub mod governance_protocol {\r\n    use super::*;\r\n\r\n    /// Initialize governance protocol\r\n    pub fn initialize(\r\n        ctx: Context\u003cInitialize\u003e,\r\n        staking_program: Pubkey,\r\n        five_a_program: Pubkey,\r\n    ) -\u003e Result\u003c()\u003e {\r\n        admin::initialize::handler(ctx, staking_program, five_a_program)\r\n    }\r\n    \r\n    /// Create a new proposal\r\n    pub fn create_proposal(\r\n        ctx: Context\u003cCreateProposal\u003e,\r\n        title_hash: [u8; 32],\r\n        description_uri: String,\r\n        proposal_type: u8,\r\n        enable_private_voting: bool,\r\n    ) -\u003e Result\u003c()\u003e {\r\n        proposal::create::handler(ctx, title_hash, description_uri, proposal_type, enable_private_voting)\r\n    }\r\n    \r\n    /// Cast a public vote\r\n    pub fn cast_vote(\r\n        ctx: Context\u003cCastVote\u003e,\r\n        choice: u8,\r\n        vevcoin_balance: u64,\r\n        five_a_score: u16,\r\n        tier: u8,\r\n    ) -\u003e Result\u003c()\u003e {\r\n        vote::cast::handler(ctx, choice, vevcoin_balance, five_a_score, tier)\r\n    }\r\n    \r\n    /// Cast a ZK private vote\r\n    pub fn cast_private_vote(\r\n        ctx: Context\u003cCastPrivateVote\u003e,\r\n        encrypted_choice: [u8; 32],\r\n        encrypted_weight: [u8; 32],\r\n        zk_proof: [u8; 128],\r\n    ) -\u003e Result\u003c()\u003e {\r\n        vote::cast_private::handler(ctx, encrypted_choice, encrypted_weight, zk_proof)\r\n    }\r\n    \r\n    /// Enable ZK private voting for a proposal\r\n    pub fn enable_private_voting(\r\n        ctx: Context\u003cEnablePrivateVoting\u003e,\r\n        encryption_pubkey: Pubkey,\r\n        decryption_committee: [Pubkey; 5],\r\n        committee_size: u8,\r\n        decryption_threshold: u8,\r\n    ) -\u003e Result\u003c()\u003e {\r\n        zk_voting::enable_private_voting::handler(ctx, encryption_pubkey, decryption_committee, committee_size, decryption_threshold)\r\n    }\r\n    \r\n    /// Initiate ZK vote reveal after voting ends\r\n    pub fn initiate_reveal(ctx: Context\u003cInitiateReveal\u003e) -\u003e Result\u003c()\u003e {\r\n        zk_voting::initiate_reveal::handler(ctx)\r\n    }\r\n    \r\n    /// Submit decryption share (committee member)\r\n    pub fn submit_decryption_share(\r\n        ctx: Context\u003cSubmitDecryptionShare\u003e,\r\n        decryption_share: [u8; 32],\r\n        committee_index: u8,\r\n    ) -\u003e Result\u003c()\u003e {\r\n        zk_voting::submit_decryption_share::handler(ctx, decryption_share, committee_index)\r\n    }\r\n    \r\n    /// Complete ZK reveal and aggregate votes\r\n    pub fn aggregate_revealed_votes(\r\n        ctx: Context\u003cAggregateRevealedVotes\u003e,\r\n        aggregated_for: u128,\r\n        aggregated_against: u128,\r\n        aggregated_abstain: u128,\r\n    ) -\u003e Result\u003c()\u003e {\r\n        zk_voting::aggregate_revealed_votes::handler(ctx, aggregated_for, aggregated_against, aggregated_abstain)\r\n    }\r\n    \r\n    /// Finalize proposal (determine pass/fail)\r\n    pub fn finalize_proposal(ctx: Context\u003cFinalizeProposal\u003e) -\u003e Result\u003c()\u003e {\r\n        proposal::finalize::handler(ctx)\r\n    }\r\n    \r\n    /// Execute a passed proposal\r\n    pub fn execute_proposal(ctx: Context\u003cExecuteProposal\u003e) -\u003e Result\u003c()\u003e {\r\n        proposal::execute::handler(ctx)\r\n    }\r\n    \r\n    /// Delegate voting power\r\n    pub fn delegate_votes(\r\n        ctx: Context\u003cDelegateVotes\u003e,\r\n        delegation_type: u8,\r\n        categories: u8,\r\n        vevcoin_amount: u64,\r\n        expires_at: i64,\r\n        revocable: bool,\r\n    ) -\u003e Result\u003c()\u003e {\r\n        delegation::delegate::handler(ctx, delegation_type, categories, vevcoin_amount, expires_at, revocable)\r\n    }\r\n    \r\n    /// Revoke delegation\r\n    pub fn revoke_delegation(ctx: Context\u003cRevokeDelegation\u003e) -\u003e Result\u003c()\u003e {\r\n        delegation::revoke::handler(ctx)\r\n    }\r\n    \r\n    /// Update governance parameters\r\n    pub fn update_config(\r\n        ctx: Context\u003cUpdateConfig\u003e,\r\n        proposal_threshold: Option\u003cu64\u003e,\r\n        quorum: Option\u003cu64\u003e,\r\n        voting_period: Option\u003ci64\u003e,\r\n        timelock_delay: Option\u003ci64\u003e,\r\n    ) -\u003e Result\u003c()\u003e {\r\n        admin::update_config::handler(ctx, proposal_threshold, quorum, voting_period, timelock_delay)\r\n    }\r\n    \r\n    /// Pause/unpause governance\r\n    pub fn set_paused(ctx: Context\u003cUpdateConfig\u003e, paused: bool) -\u003e Result\u003c()\u003e {\r\n        admin::set_paused::handler(ctx, paused)\r\n    }\r\n    \r\n    /// Update authority\r\n    pub fn update_authority(ctx: Context\u003cUpdateAuthority\u003e, new_authority: Pubkey) -\u003e Result\u003c()\u003e {\r\n        admin::update_authority::handler(ctx, new_authority)\r\n    }\r\n    \r\n    /// Get proposal info\r\n    pub fn get_proposal(ctx: Context\u003cGetProposal\u003e) -\u003e Result\u003c()\u003e {\r\n        query::get_proposal::handler(ctx)\r\n    }\r\n}\r\n","traces":[{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":105,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":0}},{"line":125,"address":[],"length":0,"stats":{"Line":0}},{"line":133,"address":[],"length":0,"stats":{"Line":0}},{"line":137,"address":[],"length":0,"stats":{"Line":0}},{"line":138,"address":[],"length":0,"stats":{"Line":0}},{"line":142,"address":[],"length":0,"stats":{"Line":0}},{"line":149,"address":[],"length":0,"stats":{"Line":0}},{"line":153,"address":[],"length":0,"stats":{"Line":0}},{"line":154,"address":[],"length":0,"stats":{"Line":0}},{"line":158,"address":[],"length":0,"stats":{"Line":0}},{"line":159,"address":[],"length":0,"stats":{"Line":0}},{"line":163,"address":[],"length":0,"stats":{"Line":0}},{"line":164,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":32},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","governance-protocol","src","state","delegate_stats.rs"],"content":"use anchor_lang::prelude::*;\r\n\r\n/// Delegate statistics\r\n#[account]\r\n#[derive(Default)]\r\npub struct DelegateStats {\r\n    /// Delegate wallet\r\n    pub delegate: Pubkey,\r\n    /// League tier (0=Bronze, 1=Silver, 2=Gold, 3=Diamond)\r\n    pub league_tier: u8,\r\n    /// Total proposals voted on\r\n    pub total_proposals_voted: u32,\r\n    /// Proposals voted with winning outcome\r\n    pub proposals_with_outcome: u32,\r\n    /// Voting accuracy (0-10000)\r\n    pub voting_accuracy: u16,\r\n    /// Participation rate (0-10000)\r\n    pub participation_rate: u16,\r\n    /// Number of unique delegators\r\n    pub unique_delegators: u32,\r\n    /// Total veVCoin delegated to this delegate\r\n    pub total_delegated_vevcoin: u64,\r\n    /// Delegator satisfaction score (0-10000)\r\n    pub delegator_satisfaction: u16,\r\n    /// Last vote timestamp\r\n    pub last_vote_at: i64,\r\n    /// Tier last updated\r\n    pub tier_updated_at: i64,\r\n    /// Whether eligible for promotion\r\n    pub promotion_eligible: bool,\r\n    /// Whether warned about demotion\r\n    pub demotion_warning: bool,\r\n    /// PDA bump\r\n    pub bump: u8,\r\n}\r\n\r\nimpl DelegateStats {\r\n    pub const LEN: usize = 8 + // discriminator\r\n        32 + // delegate\r\n        1 +  // league_tier\r\n        4 +  // total_proposals_voted\r\n        4 +  // proposals_with_outcome\r\n        2 +  // voting_accuracy\r\n        2 +  // participation_rate\r\n        4 +  // unique_delegators\r\n        8 +  // total_delegated_vevcoin\r\n        2 +  // delegator_satisfaction\r\n        8 +  // last_vote_at\r\n        8 +  // tier_updated_at\r\n        1 +  // promotion_eligible\r\n        1 +  // demotion_warning\r\n        1;   // bump\r\n    \r\n    /// Get max delegation percent based on tier\r\n    pub fn max_delegation_pct(\u0026self) -\u003e u16 {\r\n        match self.league_tier {\r\n            0 =\u003e 100,  // 1% Bronze\r\n            1 =\u003e 300,  // 3% Silver\r\n            2 =\u003e 500,  // 5% Gold\r\n            3 =\u003e 1000, // 10% Diamond\r\n            _ =\u003e 100,\r\n        }\r\n    }\r\n}\r\n\r\n","traces":[{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":7},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","governance-protocol","src","state","delegation.rs"],"content":"use anchor_lang::prelude::*;\r\n\r\n/// Delegation account (PDA per delegator)\r\n#[account]\r\n#[derive(Default)]\r\npub struct Delegation {\r\n    /// Who is delegating\r\n    pub delegator: Pubkey,\r\n    /// Who receives voting power\r\n    pub delegate: Pubkey,\r\n    /// Delegation type\r\n    pub delegation_type: u8,\r\n    /// Category bitmap (for PerCategory)\r\n    pub categories: u8,\r\n    /// Amount of veVCoin delegated\r\n    pub delegated_amount: u64,\r\n    /// When delegated\r\n    pub delegated_at: i64,\r\n    /// Expiration (0 = never)\r\n    pub expires_at: i64,\r\n    /// Whether revocable mid-vote\r\n    pub revocable: bool,\r\n    /// PDA bump\r\n    pub bump: u8,\r\n}\r\n\r\nimpl Delegation {\r\n    pub const LEN: usize = 8 + // discriminator\r\n        32 + // delegator\r\n        32 + // delegate\r\n        1 +  // delegation_type\r\n        1 +  // categories\r\n        8 +  // delegated_amount\r\n        8 +  // delegated_at\r\n        8 +  // expires_at\r\n        1 +  // revocable\r\n        1;   // bump\r\n}\r\n\r\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","governance-protocol","src","state","delegation_type.rs"],"content":"use anchor_lang::prelude::*;\r\n\r\n/// Delegation type enum\r\n#[derive(AnchorSerialize, AnchorDeserialize, Clone, Copy, PartialEq, Eq, Default)]\r\npub enum DelegationType {\r\n    #[default]\r\n    Full = 0,\r\n    PerCategory = 1,\r\n    PerProposal = 2,\r\n}\r\n\r\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","governance-protocol","src","state","governance_config.rs"],"content":"use anchor_lang::prelude::*;\r\n\r\n/// Global governance configuration\r\n#[account]\r\n#[derive(Default)]\r\npub struct GovernanceConfig {\r\n    /// Admin authority\r\n    pub authority: Pubkey,\r\n    /// Staking program\r\n    pub staking_program: Pubkey,\r\n    /// 5A Protocol program\r\n    pub five_a_program: Pubkey,\r\n    /// veVCoin required to propose\r\n    pub proposal_threshold: u64,\r\n    /// Minimum votes for valid proposal\r\n    pub quorum: u64,\r\n    /// Voting period in seconds\r\n    pub voting_period: i64,\r\n    /// Timelock delay before execution\r\n    pub timelock_delay: i64,\r\n    /// Total proposals created\r\n    pub proposal_count: u64,\r\n    /// Treasury balance (200M VCoin)\r\n    pub treasury_balance: u64,\r\n    /// Whether governance is paused\r\n    pub paused: bool,\r\n    /// PDA bump\r\n    pub bump: u8,\r\n}\r\n\r\nimpl GovernanceConfig {\r\n    pub const LEN: usize = 8 + // discriminator\r\n        32 + // authority\r\n        32 + // staking_program\r\n        32 + // five_a_program\r\n        8 +  // proposal_threshold\r\n        8 +  // quorum\r\n        8 +  // voting_period\r\n        8 +  // timelock_delay\r\n        8 +  // proposal_count\r\n        8 +  // treasury_balance\r\n        1 +  // paused\r\n        1;   // bump\r\n}\r\n\r\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","governance-protocol","src","state","mod.rs"],"content":"pub mod vote_choice;\r\npub mod proposal_status;\r\npub mod proposal_type;\r\npub mod delegation_type;\r\npub mod governance_config;\r\npub mod proposal;\r\npub mod vote_record;\r\npub mod private_voting_config;\r\npub mod delegation;\r\npub mod delegate_stats;\r\npub mod utils;\r\n\r\npub use vote_choice::*;\r\npub use proposal_status::*;\r\npub use proposal_type::*;\r\npub use delegation_type::*;\r\npub use governance_config::*;\r\npub use proposal::*;\r\npub use vote_record::*;\r\npub use private_voting_config::*;\r\npub use delegation::*;\r\npub use delegate_stats::*;\r\npub use utils::*;\r\n\r\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","governance-protocol","src","state","private_voting_config.rs"],"content":"use anchor_lang::prelude::*;\r\n\r\n/// ZK Private voting configuration (per proposal)\r\n#[account]\r\n#[derive(Default)]\r\npub struct PrivateVotingConfig {\r\n    /// Proposal\r\n    pub proposal: Pubkey,\r\n    /// Whether private voting is enabled\r\n    pub is_enabled: bool,\r\n    /// Threshold encryption public key\r\n    pub encryption_pubkey: Pubkey,\r\n    /// Decryption threshold (e.g., 3-of-5)\r\n    pub decryption_threshold: u8,\r\n    /// Decryption committee (max 5)\r\n    pub decryption_committee: [Pubkey; 5],\r\n    /// Committee size\r\n    pub committee_size: u8,\r\n    /// Decryption shares received\r\n    pub shares_received: u8,\r\n    /// Whether reveal has started\r\n    pub reveal_started: bool,\r\n    /// Whether reveal is complete\r\n    pub reveal_completed: bool,\r\n    /// Aggregated votes for (revealed)\r\n    pub aggregated_for: u128,\r\n    /// Aggregated votes against\r\n    pub aggregated_against: u128,\r\n    /// Aggregated abstain\r\n    pub aggregated_abstain: u128,\r\n    /// PDA bump\r\n    pub bump: u8,\r\n}\r\n\r\nimpl PrivateVotingConfig {\r\n    pub const LEN: usize = 8 + // discriminator\r\n        32 + // proposal\r\n        1 +  // is_enabled\r\n        32 + // encryption_pubkey\r\n        1 +  // decryption_threshold\r\n        (32 * 5) + // decryption_committee\r\n        1 +  // committee_size\r\n        1 +  // shares_received\r\n        1 +  // reveal_started\r\n        1 +  // reveal_completed\r\n        16 + // aggregated_for\r\n        16 + // aggregated_against\r\n        16 + // aggregated_abstain\r\n        1;   // bump\r\n}\r\n\r\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","governance-protocol","src","state","proposal.rs"],"content":"use anchor_lang::prelude::*;\r\n\r\n/// Proposal account\r\n#[account]\r\npub struct Proposal {\r\n    /// Proposal ID\r\n    pub id: u64,\r\n    /// Proposer\r\n    pub proposer: Pubkey,\r\n    /// Hash of title\r\n    pub title_hash: [u8; 32],\r\n    /// IPFS link to description\r\n    pub description_uri: [u8; 128],\r\n    /// URI length\r\n    pub uri_len: u8,\r\n    /// Proposal type\r\n    pub proposal_type: u8,\r\n    /// Voting start time\r\n    pub start_time: i64,\r\n    /// Voting end time\r\n    pub end_time: i64,\r\n    /// Votes for (u128 for large-scale)\r\n    pub votes_for: u128,\r\n    /// Votes against\r\n    pub votes_against: u128,\r\n    /// Abstain votes\r\n    pub votes_abstain: u128,\r\n    /// Current status\r\n    pub status: u8,\r\n    /// Execution time (after timelock)\r\n    pub execution_time: i64,\r\n    /// Whether executed\r\n    pub executed: bool,\r\n    /// Whether ZK voting is enabled\r\n    pub is_private_voting: bool,\r\n    /// PDA bump\r\n    pub bump: u8,\r\n}\r\n\r\nimpl Default for Proposal {\r\n    fn default() -\u003e Self {\r\n        Self {\r\n            id: 0,\r\n            proposer: Pubkey::default(),\r\n            title_hash: [0u8; 32],\r\n            description_uri: [0u8; 128],\r\n            uri_len: 0,\r\n            proposal_type: 0,\r\n            start_time: 0,\r\n            end_time: 0,\r\n            votes_for: 0,\r\n            votes_against: 0,\r\n            votes_abstain: 0,\r\n            status: 0,\r\n            execution_time: 0,\r\n            executed: false,\r\n            is_private_voting: false,\r\n            bump: 0,\r\n        }\r\n    }\r\n}\r\n\r\nimpl Proposal {\r\n    pub const LEN: usize = 8 + // discriminator\r\n        8 +   // id\r\n        32 +  // proposer\r\n        32 +  // title_hash\r\n        128 + // description_uri\r\n        1 +   // uri_len\r\n        1 +   // proposal_type\r\n        8 +   // start_time\r\n        8 +   // end_time\r\n        16 +  // votes_for (u128)\r\n        16 +  // votes_against\r\n        16 +  // votes_abstain\r\n        1 +   // status\r\n        8 +   // execution_time\r\n        1 +   // executed\r\n        1 +   // is_private_voting\r\n        1;    // bump\r\n}\r\n\r\n","traces":[{"line":41,"address":[],"length":0,"stats":{"Line":504403158265495552}},{"line":44,"address":[],"length":0,"stats":{"Line":1008806316530991104}},{"line":45,"address":[],"length":0,"stats":{"Line":504403158265495552}},{"line":46,"address":[],"length":0,"stats":{"Line":504403158265495552}}],"covered":4,"coverable":4},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","governance-protocol","src","state","proposal_status.rs"],"content":"use anchor_lang::prelude::*;\r\n\r\n/// Proposal status enum\r\n#[derive(AnchorSerialize, AnchorDeserialize, Clone, Copy, PartialEq, Eq, Default, Debug)]\r\npub enum ProposalStatus {\r\n    #[default]\r\n    Pending = 0,\r\n    Active = 1,\r\n    Passed = 2,\r\n    Rejected = 3,\r\n    Executed = 4,\r\n    Cancelled = 5,\r\n}\r\n\r\nimpl ProposalStatus {\r\n    pub fn from_u8(value: u8) -\u003e Option\u003cSelf\u003e {\r\n        match value {\r\n            0 =\u003e Some(ProposalStatus::Pending),\r\n            1 =\u003e Some(ProposalStatus::Active),\r\n            2 =\u003e Some(ProposalStatus::Passed),\r\n            3 =\u003e Some(ProposalStatus::Rejected),\r\n            4 =\u003e Some(ProposalStatus::Executed),\r\n            5 =\u003e Some(ProposalStatus::Cancelled),\r\n            _ =\u003e None,\r\n        }\r\n    }\r\n}\r\n\r\n","traces":[{"line":16,"address":[],"length":0,"stats":{"Line":1224979098644774912}},{"line":17,"address":[],"length":0,"stats":{"Line":1224979098644774912}},{"line":18,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":19,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":20,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":21,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":22,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":23,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":24,"address":[],"length":0,"stats":{"Line":72057594037927936}}],"covered":9,"coverable":9},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","governance-protocol","src","state","proposal_type.rs"],"content":"use anchor_lang::prelude::*;\r\n\r\n/// Proposal type enum\r\n#[derive(AnchorSerialize, AnchorDeserialize, Clone, Copy, PartialEq, Eq, Default)]\r\npub enum ProposalType {\r\n    #[default]\r\n    Parameter = 0,\r\n    Treasury = 1,\r\n    Protocol = 2,\r\n    Emissions = 3,\r\n}\r\n\r\nimpl ProposalType {\r\n    pub fn from_u8(value: u8) -\u003e Option\u003cSelf\u003e {\r\n        match value {\r\n            0 =\u003e Some(ProposalType::Parameter),\r\n            1 =\u003e Some(ProposalType::Treasury),\r\n            2 =\u003e Some(ProposalType::Protocol),\r\n            3 =\u003e Some(ProposalType::Emissions),\r\n            _ =\u003e None,\r\n        }\r\n    }\r\n}\r\n\r\n","traces":[{"line":14,"address":[],"length":0,"stats":{"Line":0}},{"line":15,"address":[],"length":0,"stats":{"Line":0}},{"line":16,"address":[],"length":0,"stats":{"Line":0}},{"line":17,"address":[],"length":0,"stats":{"Line":0}},{"line":18,"address":[],"length":0,"stats":{"Line":0}},{"line":19,"address":[],"length":0,"stats":{"Line":0}},{"line":20,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":7},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","governance-protocol","src","state","utils.rs"],"content":"use crate::constants::*;\r\n\r\n/// Helper to calculate voting power\r\npub fn calculate_voting_power(\r\n    vevcoin_balance: u64,\r\n    five_a_score: u16,  // 0-10000\r\n    tier: u8,\r\n) -\u003e u64 {\r\n    // Step 1: Quadratic base votes\r\n    let base_votes = integer_sqrt(vevcoin_balance);\r\n    \r\n    // Step 2: 5A boost (1.0x to 2.0x)\r\n    let five_a_boost = 1000 + (five_a_score as u64 / 10); // 1000-2000\r\n    \r\n    // Step 3: Tier multiplier\r\n    let tier_mult = match tier {\r\n        0 =\u003e TIER_MULT_NONE,\r\n        1 =\u003e TIER_MULT_BRONZE,\r\n        2 =\u003e TIER_MULT_SILVER,\r\n        3 =\u003e TIER_MULT_GOLD,\r\n        4 =\u003e TIER_MULT_PLATINUM,\r\n        _ =\u003e TIER_MULT_NONE,\r\n    };\r\n    \r\n    // Step 4: Combined (divide by 1_000_000 to normalize)\r\n    let raw_votes = (base_votes * five_a_boost * tier_mult) / 1_000_000;\r\n    \r\n    // Step 5: Diminishing returns for extreme concentration\r\n    if raw_votes \u003e DIMINISHING_THRESHOLD {\r\n        DIMINISHING_THRESHOLD + integer_sqrt(raw_votes - DIMINISHING_THRESHOLD)\r\n    } else {\r\n        raw_votes\r\n    }\r\n}\r\n\r\n/// Integer square root using Newton's method\r\npub fn integer_sqrt(n: u64) -\u003e u64 {\r\n    if n == 0 {\r\n        return 0;\r\n    }\r\n    let mut x = n;\r\n    let mut y = (x + 1) / 2;\r\n    while y \u003c x {\r\n        x = y;\r\n        y = (x + n / x) / 2;\r\n    }\r\n    x\r\n}\r\n\r\n","traces":[{"line":4,"address":[],"length":0,"stats":{"Line":504403158265495552}},{"line":10,"address":[],"length":0,"stats":{"Line":1513209474796486656}},{"line":13,"address":[],"length":0,"stats":{"Line":1008806316530991104}},{"line":16,"address":[],"length":0,"stats":{"Line":1008806316530991104}},{"line":17,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":18,"address":[],"length":0,"stats":{"Line":0}},{"line":19,"address":[],"length":0,"stats":{"Line":0}},{"line":20,"address":[],"length":0,"stats":{"Line":0}},{"line":21,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":1008806316530991104}},{"line":29,"address":[],"length":0,"stats":{"Line":504403158265495552}},{"line":30,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":32,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":37,"address":[],"length":0,"stats":{"Line":1585267068834414592}},{"line":38,"address":[],"length":0,"stats":{"Line":1585267068834414592}},{"line":39,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":41,"address":[],"length":0,"stats":{"Line":2882303761517117440}},{"line":42,"address":[],"length":0,"stats":{"Line":2882303761517117440}},{"line":43,"address":[],"length":0,"stats":{"Line":12105675798371893248}},{"line":44,"address":[],"length":0,"stats":{"Line":10664523917613334528}},{"line":45,"address":[],"length":0,"stats":{"Line":10664523917613334528}},{"line":47,"address":[],"length":0,"stats":{"Line":1441151880758558720}}],"covered":19,"coverable":23},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","governance-protocol","src","state","vote_choice.rs"],"content":"use anchor_lang::prelude::*;\r\n\r\n/// Vote choice enum\r\n#[derive(AnchorSerialize, AnchorDeserialize, Clone, Copy, PartialEq, Eq, Default)]\r\npub enum VoteChoice {\r\n    #[default]\r\n    Abstain = 0,\r\n    For = 1,\r\n    Against = 2,\r\n}\r\n\r\nimpl VoteChoice {\r\n    pub fn from_u8(value: u8) -\u003e Option\u003cSelf\u003e {\r\n        match value {\r\n            0 =\u003e Some(VoteChoice::Abstain),\r\n            1 =\u003e Some(VoteChoice::For),\r\n            2 =\u003e Some(VoteChoice::Against),\r\n            _ =\u003e None,\r\n        }\r\n    }\r\n}\r\n\r\n","traces":[{"line":13,"address":[],"length":0,"stats":{"Line":0}},{"line":14,"address":[],"length":0,"stats":{"Line":0}},{"line":15,"address":[],"length":0,"stats":{"Line":0}},{"line":16,"address":[],"length":0,"stats":{"Line":0}},{"line":17,"address":[],"length":0,"stats":{"Line":0}},{"line":18,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":6},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","governance-protocol","src","state","vote_record.rs"],"content":"use anchor_lang::prelude::*;\r\n\r\n/// Vote record (PDA per user per proposal)\r\n#[account]\r\npub struct VoteRecord {\r\n    /// Voter\r\n    pub voter: Pubkey,\r\n    /// Proposal\r\n    pub proposal: Pubkey,\r\n    /// Vote weight (veVCoin * 5A boost)\r\n    pub vote_weight: u64,\r\n    /// Vote choice\r\n    pub vote_choice: u8,\r\n    /// Timestamp\r\n    pub voted_at: i64,\r\n    /// Whether this is a ZK encrypted vote\r\n    pub is_private: bool,\r\n    /// Encrypted choice (for ZK voting)\r\n    pub encrypted_choice: [u8; 32],\r\n    /// Encrypted weight (for ZK voting)\r\n    pub encrypted_weight: [u8; 32],\r\n    /// ZK proof\r\n    pub zk_proof: [u8; 128],\r\n    /// Whether vote has been revealed\r\n    pub revealed: bool,\r\n    /// PDA bump\r\n    pub bump: u8,\r\n}\r\n\r\nimpl Default for VoteRecord {\r\n    fn default() -\u003e Self {\r\n        Self {\r\n            voter: Pubkey::default(),\r\n            proposal: Pubkey::default(),\r\n            vote_weight: 0,\r\n            vote_choice: 0,\r\n            voted_at: 0,\r\n            is_private: false,\r\n            encrypted_choice: [0u8; 32],\r\n            encrypted_weight: [0u8; 32],\r\n            zk_proof: [0u8; 128],\r\n            revealed: false,\r\n            bump: 0,\r\n        }\r\n    }\r\n}\r\n\r\nimpl VoteRecord {\r\n    pub const LEN: usize = 8 + // discriminator\r\n        32 + // voter\r\n        32 + // proposal\r\n        8 +  // vote_weight\r\n        1 +  // vote_choice\r\n        8 +  // voted_at\r\n        1 +  // is_private\r\n        32 + // encrypted_choice\r\n        32 + // encrypted_weight\r\n        128 + // zk_proof\r\n        1 +  // revealed\r\n        1;   // bump\r\n}\r\n\r\n","traces":[{"line":31,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":33,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":34,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":39,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":40,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":41,"address":[],"length":0,"stats":{"Line":72057594037927936}}],"covered":6,"coverable":6},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","governance-protocol","src","tests.rs"],"content":"//! Unit tests for Governance Protocol\r\n//!\r\n//! These tests run against the ACTUAL program code.\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n    use crate::constants::*;\r\n    use crate::state::{GovernanceConfig, Proposal, VoteRecord, ProposalStatus};\r\n    use crate::state::utils::{calculate_voting_power, integer_sqrt};\r\n    use anchor_lang::prelude::Pubkey;\r\n\r\n    // ========================================================================\r\n    // Constants Tests\r\n    // ========================================================================\r\n\r\n    #[test]\r\n    fn test_governance_seeds() {\r\n        assert_eq!(GOV_CONFIG_SEED, b\"gov-config\");\r\n        assert_eq!(PROPOSAL_SEED, b\"proposal\");\r\n        assert_eq!(VOTE_RECORD_SEED, b\"vote-record\");\r\n        assert_eq!(DELEGATION_SEED, b\"delegation\");\r\n    }\r\n\r\n    #[test]\r\n    fn test_governance_thresholds() {\r\n        assert_eq!(COMMUNITY_THRESHOLD, 1, \"1 veVCoin to vote\");\r\n        assert_eq!(DELEGATE_THRESHOLD, 1_000, \"1000 veVCoin to create proposals\");\r\n        assert_eq!(COUNCIL_THRESHOLD, 10_000, \"10000 veVCoin for council\");\r\n    }\r\n\r\n    #[test]\r\n    fn test_default_voting_period() {\r\n        assert_eq!(DEFAULT_VOTING_PERIOD, 7 * 24 * 60 * 60, \"7 days voting period\");\r\n    }\r\n\r\n    #[test]\r\n    fn test_default_timelock() {\r\n        assert_eq!(DEFAULT_TIMELOCK_DELAY, 48 * 60 * 60, \"48 hours timelock\");\r\n    }\r\n\r\n    #[test]\r\n    fn test_default_quorum() {\r\n        assert_eq!(DEFAULT_QUORUM, 1_000_000, \"1M effective votes for quorum\");\r\n    }\r\n\r\n    #[test]\r\n    fn test_tier_multipliers() {\r\n        assert_eq!(TIER_MULT_NONE, 1000, \"1.0x for None\");\r\n        assert_eq!(TIER_MULT_BRONZE, 1000, \"1.0x for Bronze\");\r\n        assert_eq!(TIER_MULT_SILVER, 2000, \"2.0x for Silver\");\r\n        assert_eq!(TIER_MULT_GOLD, 5000, \"5.0x for Gold\");\r\n        assert_eq!(TIER_MULT_PLATINUM, 10000, \"10.0x for Platinum\");\r\n    }\r\n\r\n    #[test]\r\n    fn test_diminishing_threshold() {\r\n        assert_eq!(DIMINISHING_THRESHOLD, 100_000, \"100K vote cap before diminishing\");\r\n    }\r\n\r\n    #[test]\r\n    fn test_zk_voting_constants() {\r\n        assert_eq!(MIN_DECRYPTION_THRESHOLD, 3, \"Minimum 3 committee members\");\r\n        assert_eq!(MAX_COMMITTEE_SIZE, 5, \"Maximum 5 committee members\");\r\n    }\r\n\r\n    // ========================================================================\r\n    // State Size Tests\r\n    // ========================================================================\r\n\r\n    #[test]\r\n    fn test_governance_config_size() {\r\n        let expected = 8 + 32 + 32 + 32 + 8 + 8 + 8 + 8 + 8 + 8 + 1 + 1;\r\n        assert_eq!(GovernanceConfig::LEN, expected, \"Config size mismatch\");\r\n    }\r\n\r\n    #[test]\r\n    fn test_proposal_size() {\r\n        let expected = 8 + 8 + 32 + 32 + 128 + 1 + 1 + 8 + 8 + 16 + 16 + 16 + 1 + 8 + 1 + 1 + 1;\r\n        assert_eq!(Proposal::LEN, expected, \"Proposal size mismatch\");\r\n    }\r\n\r\n    #[test]\r\n    fn test_vote_record_size() {\r\n        let expected = 8 + 32 + 32 + 8 + 1 + 8 + 1 + 32 + 32 + 128 + 1 + 1;\r\n        assert_eq!(VoteRecord::LEN, expected, \"VoteRecord size mismatch\");\r\n    }\r\n\r\n    // ========================================================================\r\n    // Integer Square Root Tests\r\n    // ========================================================================\r\n\r\n    #[test]\r\n    fn test_sqrt_zero() {\r\n        assert_eq!(integer_sqrt(0), 0);\r\n    }\r\n\r\n    #[test]\r\n    fn test_sqrt_one() {\r\n        assert_eq!(integer_sqrt(1), 1);\r\n    }\r\n\r\n    #[test]\r\n    fn test_sqrt_perfect_squares() {\r\n        assert_eq!(integer_sqrt(4), 2);\r\n        assert_eq!(integer_sqrt(9), 3);\r\n        assert_eq!(integer_sqrt(16), 4);\r\n        assert_eq!(integer_sqrt(100), 10);\r\n        assert_eq!(integer_sqrt(10000), 100);\r\n        assert_eq!(integer_sqrt(1_000_000), 1000);\r\n    }\r\n\r\n    #[test]\r\n    fn test_sqrt_non_perfect() {\r\n        // sqrt(2) ≈ 1.41, floor = 1\r\n        assert_eq!(integer_sqrt(2), 1);\r\n        // sqrt(5) ≈ 2.23, floor = 2\r\n        assert_eq!(integer_sqrt(5), 2);\r\n        // sqrt(99) ≈ 9.95, floor = 9\r\n        assert_eq!(integer_sqrt(99), 9);\r\n    }\r\n\r\n    #[test]\r\n    fn test_sqrt_large_values() {\r\n        // sqrt(1B) = 31622\r\n        assert_eq!(integer_sqrt(1_000_000_000), 31622);\r\n        // sqrt(1T) = 1M\r\n        assert_eq!(integer_sqrt(1_000_000_000_000), 1_000_000);\r\n    }\r\n\r\n    // ========================================================================\r\n    // Voting Power Calculation Tests\r\n    // ========================================================================\r\n\r\n    #[test]\r\n    fn test_voting_power_basic() {\r\n        // 10000 veVCoin, 0 5A score, no tier\r\n        let power = calculate_voting_power(10_000, 0, 0);\r\n        \r\n        // sqrt(10000) = 100\r\n        // 5A boost = 1000 + 0 = 1000\r\n        // tier mult = 1000\r\n        // raw = 100 * 1000 * 1000 / 1_000_000 = 100\r\n        assert_eq!(power, 100);\r\n    }\r\n\r\n    #[test]\r\n    fn test_voting_power_with_5a() {\r\n        // 10000 veVCoin, max 5A score (10000 = 100%), no tier\r\n        let power = calculate_voting_power(10_000, 10_000, 0);\r\n        \r\n        // sqrt(10000) = 100\r\n        // 5A boost = 1000 + 1000 = 2000 (2.0x)\r\n        // tier mult = 1000\r\n        // raw = 100 * 2000 * 1000 / 1_000_000 = 200\r\n        assert_eq!(power, 200);\r\n    }\r\n\r\n    #[test]\r\n    fn test_voting_power_platinum_tier() {\r\n        // 10000 veVCoin, 0 5A score, Platinum tier\r\n        let power = calculate_voting_power(10_000, 0, 4);\r\n        \r\n        // sqrt(10000) = 100\r\n        // 5A boost = 1000\r\n        // tier mult = 10000 (10x)\r\n        // raw = 100 * 1000 * 10000 / 1_000_000 = 1000\r\n        assert_eq!(power, 1000);\r\n    }\r\n\r\n    #[test]\r\n    fn test_voting_power_all_boosts() {\r\n        // 10000 veVCoin, max 5A, Platinum tier\r\n        let power = calculate_voting_power(10_000, 10_000, 4);\r\n        \r\n        // sqrt(10000) = 100\r\n        // 5A boost = 2000 (2.0x)\r\n        // tier mult = 10000 (10x)\r\n        // raw = 100 * 2000 * 10000 / 1_000_000 = 2000\r\n        assert_eq!(power, 2000);\r\n    }\r\n\r\n    #[test]\r\n    fn test_voting_power_diminishing_returns() {\r\n        // Very large stake to trigger diminishing returns\r\n        let vevcoin = 100_000_000_000u64; // 100B (extreme case)\r\n        let power = calculate_voting_power(vevcoin, 10_000, 4);\r\n        \r\n        // raw votes would be enormous, but diminishing returns kicks in\r\n        // Should be capped: DIMINISHING_THRESHOLD + sqrt(excess)\r\n        assert!(power \u003e DIMINISHING_THRESHOLD);\r\n    }\r\n\r\n    #[test]\r\n    fn test_voting_power_zero_vevcoin() {\r\n        let power = calculate_voting_power(0, 10_000, 4);\r\n        assert_eq!(power, 0, \"Zero veVCoin = zero voting power\");\r\n    }\r\n\r\n    // ========================================================================\r\n    // Proposal Status Tests\r\n    // ========================================================================\r\n\r\n    #[test]\r\n    fn test_proposal_status_from_u8() {\r\n        assert_eq!(ProposalStatus::from_u8(0), Some(ProposalStatus::Pending));\r\n        assert_eq!(ProposalStatus::from_u8(1), Some(ProposalStatus::Active));\r\n        assert_eq!(ProposalStatus::from_u8(2), Some(ProposalStatus::Passed));\r\n        assert_eq!(ProposalStatus::from_u8(3), Some(ProposalStatus::Rejected));\r\n        assert_eq!(ProposalStatus::from_u8(4), Some(ProposalStatus::Executed));\r\n        assert_eq!(ProposalStatus::from_u8(5), Some(ProposalStatus::Cancelled));\r\n        assert_eq!(ProposalStatus::from_u8(6), None);\r\n    }\r\n\r\n    #[test]\r\n    fn test_proposal_status_default() {\r\n        let status = ProposalStatus::default();\r\n        assert_eq!(status, ProposalStatus::Pending);\r\n    }\r\n\r\n    // ========================================================================\r\n    // Proposal State Tests\r\n    // ========================================================================\r\n\r\n    #[test]\r\n    fn test_proposal_default() {\r\n        let proposal = Proposal::default();\r\n        assert_eq!(proposal.id, 0);\r\n        assert_eq!(proposal.votes_for, 0);\r\n        assert_eq!(proposal.votes_against, 0);\r\n        assert_eq!(proposal.votes_abstain, 0);\r\n        assert!(!proposal.executed);\r\n    }\r\n\r\n    #[test]\r\n    fn test_vote_totals() {\r\n        let mut proposal = Proposal::default();\r\n        proposal.votes_for = 1000;\r\n        proposal.votes_against = 500;\r\n        proposal.votes_abstain = 200;\r\n        \r\n        let total = proposal.votes_for + proposal.votes_against + proposal.votes_abstain;\r\n        assert_eq!(total, 1700);\r\n    }\r\n\r\n    #[test]\r\n    fn test_proposal_passes() {\r\n        let proposal = Proposal {\r\n            votes_for: 2000,\r\n            votes_against: 500,\r\n            ..Default::default()\r\n        };\r\n        \r\n        assert!(proposal.votes_for \u003e proposal.votes_against, \"Should pass\");\r\n    }\r\n\r\n    #[test]\r\n    fn test_proposal_rejected() {\r\n        let proposal = Proposal {\r\n            votes_for: 400,\r\n            votes_against: 600,\r\n            ..Default::default()\r\n        };\r\n        \r\n        assert!(proposal.votes_for \u003c proposal.votes_against, \"Should be rejected\");\r\n    }\r\n\r\n    // ========================================================================\r\n    // Quorum Tests\r\n    // ========================================================================\r\n\r\n    #[test]\r\n    fn test_quorum_reached() {\r\n        let quorum = DEFAULT_QUORUM;\r\n        let proposal = Proposal {\r\n            votes_for: 800_000,\r\n            votes_against: 300_000,\r\n            votes_abstain: 100_000,\r\n            ..Default::default()\r\n        };\r\n        \r\n        let total = proposal.votes_for + proposal.votes_against + proposal.votes_abstain;\r\n        assert!(total as u64 \u003e= quorum, \"Quorum should be reached\");\r\n    }\r\n\r\n    #[test]\r\n    fn test_quorum_not_reached() {\r\n        let quorum = DEFAULT_QUORUM;\r\n        let proposal = Proposal {\r\n            votes_for: 100_000,\r\n            votes_against: 50_000,\r\n            ..Default::default()\r\n        };\r\n        \r\n        let total = proposal.votes_for + proposal.votes_against + proposal.votes_abstain;\r\n        assert!((total as u64) \u003c quorum, \"Quorum should not be reached\");\r\n    }\r\n\r\n    // ========================================================================\r\n    // Timelock Tests\r\n    // ========================================================================\r\n\r\n    #[test]\r\n    fn test_timelock_calculation() {\r\n        let end_time = 1000i64;\r\n        let execution_time = end_time + DEFAULT_TIMELOCK_DELAY;\r\n        \r\n        assert_eq!(execution_time, 1000 + 48 * 60 * 60);\r\n    }\r\n\r\n    #[test]\r\n    fn test_can_execute_after_timelock() {\r\n        let execution_time = 1000i64;\r\n        let current_time = 2000i64;\r\n        \r\n        assert!(current_time \u003e= execution_time, \"Should be executable\");\r\n    }\r\n\r\n    #[test]\r\n    fn test_cannot_execute_before_timelock() {\r\n        let execution_time = 1000i64;\r\n        let current_time = 500i64;\r\n        \r\n        assert!(current_time \u003c execution_time, \"Should not be executable\");\r\n    }\r\n\r\n    // ========================================================================\r\n    // Vote Record Tests\r\n    // ========================================================================\r\n\r\n    #[test]\r\n    fn test_vote_record_default() {\r\n        let vote = VoteRecord::default();\r\n        assert_eq!(vote.vote_weight, 0);\r\n        assert_eq!(vote.vote_choice, 0);\r\n        assert!(!vote.is_private);\r\n        assert!(!vote.revealed);\r\n    }\r\n\r\n    // ========================================================================\r\n    // Invariant Tests\r\n    // ========================================================================\r\n\r\n    #[test]\r\n    fn test_invariant_vote_totals() {\r\n        // votes_for + votes_against + votes_abstain = total_votes\r\n        let proposal = Proposal {\r\n            votes_for: 1000,\r\n            votes_against: 500,\r\n            votes_abstain: 200,\r\n            ..Default::default()\r\n        };\r\n        \r\n        let calculated_total = proposal.votes_for + proposal.votes_against + proposal.votes_abstain;\r\n        assert_eq!(calculated_total, 1700);\r\n    }\r\n\r\n    #[test]\r\n    fn test_invariant_voting_power_bounded() {\r\n        // Even with max inputs, voting power should be bounded\r\n        let max_vevcoin = u64::MAX / 1000; // Prevent overflow in calculation\r\n        let power = calculate_voting_power(max_vevcoin, 10_000, 4);\r\n        \r\n        assert!(power \u003c u64::MAX, \"Voting power should not overflow\");\r\n    }\r\n\r\n    #[test]\r\n    fn test_invariant_proposal_state_machine() {\r\n        // Valid state transitions:\r\n        // Pending -\u003e Active\r\n        // Active -\u003e Passed | Rejected | Cancelled\r\n        // Passed -\u003e Executed\r\n        \r\n        let valid_transitions = [\r\n            (0, 1), // Pending -\u003e Active\r\n            (1, 2), // Active -\u003e Passed\r\n            (1, 3), // Active -\u003e Rejected\r\n            (1, 5), // Active -\u003e Cancelled\r\n            (2, 4), // Passed -\u003e Executed\r\n        ];\r\n        \r\n        for (from, to) in valid_transitions {\r\n            let from_status = ProposalStatus::from_u8(from);\r\n            let to_status = ProposalStatus::from_u8(to);\r\n            assert!(from_status.is_some() \u0026\u0026 to_status.is_some());\r\n        }\r\n    }\r\n\r\n    // ========================================================================\r\n    // PDA Derivation Tests\r\n    // ========================================================================\r\n\r\n    #[test]\r\n    fn test_proposal_pda_unique() {\r\n        let program_id = Pubkey::new_unique();\r\n        \r\n        let (pda1, _) = Pubkey::find_program_address(\r\n            \u0026[PROPOSAL_SEED, \u00261u64.to_le_bytes()],\r\n            \u0026program_id\r\n        );\r\n        \r\n        let (pda2, _) = Pubkey::find_program_address(\r\n            \u0026[PROPOSAL_SEED, \u00262u64.to_le_bytes()],\r\n            \u0026program_id\r\n        );\r\n        \r\n        assert_ne!(pda1, pda2, \"Different proposal IDs should have different PDAs\");\r\n    }\r\n\r\n    #[test]\r\n    fn test_vote_record_pda_unique() {\r\n        let program_id = Pubkey::new_unique();\r\n        let voter = Pubkey::new_unique();\r\n        let proposal1 = Pubkey::new_unique();\r\n        let proposal2 = Pubkey::new_unique();\r\n        \r\n        let (pda1, _) = Pubkey::find_program_address(\r\n            \u0026[VOTE_RECORD_SEED, voter.as_ref(), proposal1.as_ref()],\r\n            \u0026program_id\r\n        );\r\n        \r\n        let (pda2, _) = Pubkey::find_program_address(\r\n            \u0026[VOTE_RECORD_SEED, voter.as_ref(), proposal2.as_ref()],\r\n            \u0026program_id\r\n        );\r\n        \r\n        assert_ne!(pda1, pda2, \"Same voter, different proposals = different PDAs\");\r\n    }\r\n}\r\n\r\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","governance-protocol","tests","admin.rs"],"content":"//! Integration tests for governance-protocol admin instructions\r\n\r\nmod common;\r\n\r\nuse common::*;\r\nuse solana_sdk::signature::{Keypair, Signer};\r\n\r\n#[tokio::test]\r\nasync fn test_set_paused_true() {\r\n    let mut ctx = TestContext::new().await;\r\n    \r\n    let (config_pda, _bump) = ctx.get_config_pda();\r\n    let staking_program = Keypair::new();\r\n    let five_a_program = Keypair::new();\r\n    \r\n    let init_ix = create_initialize_ix(\r\n        \u0026ctx.program_id,\r\n        \u0026ctx.payer.pubkey(),\r\n        \u0026config_pda,\r\n        \u0026staking_program.pubkey(),\r\n        \u0026five_a_program.pubkey(),\r\n    );\r\n    \r\n    ctx.process_transaction(\u0026[init_ix], \u0026[]).await.unwrap();\r\n    \r\n    let pause_ix = create_set_paused_ix(\r\n        \u0026ctx.program_id,\r\n        \u0026ctx.payer.pubkey(),\r\n        \u0026config_pda,\r\n        true,\r\n    );\r\n    \r\n    let result = ctx.process_transaction(\u0026[pause_ix], \u0026[]).await;\r\n    assert!(result.is_ok());\r\n}\r\n\r\n#[tokio::test]\r\nasync fn test_set_paused_false() {\r\n    let mut ctx = TestContext::new().await;\r\n    \r\n    let (config_pda, _bump) = ctx.get_config_pda();\r\n    let staking_program = Keypair::new();\r\n    let five_a_program = Keypair::new();\r\n    \r\n    let init_ix = create_initialize_ix(\r\n        \u0026ctx.program_id,\r\n        \u0026ctx.payer.pubkey(),\r\n        \u0026config_pda,\r\n        \u0026staking_program.pubkey(),\r\n        \u0026five_a_program.pubkey(),\r\n    );\r\n    \r\n    ctx.process_transaction(\u0026[init_ix], \u0026[]).await.unwrap();\r\n    \r\n    let pause_ix = create_set_paused_ix(\u0026ctx.program_id, \u0026ctx.payer.pubkey(), \u0026config_pda, true);\r\n    ctx.process_transaction(\u0026[pause_ix], \u0026[]).await.unwrap();\r\n    \r\n    let unpause_ix = create_set_paused_ix(\u0026ctx.program_id, \u0026ctx.payer.pubkey(), \u0026config_pda, false);\r\n    let result = ctx.process_transaction(\u0026[unpause_ix], \u0026[]).await;\r\n    assert!(result.is_ok());\r\n}\r\n\r\n#[tokio::test]\r\nasync fn test_set_paused_unauthorized() {\r\n    let mut ctx = TestContext::new().await;\r\n    \r\n    let (config_pda, _bump) = ctx.get_config_pda();\r\n    let staking_program = Keypair::new();\r\n    let five_a_program = Keypair::new();\r\n    \r\n    let init_ix = create_initialize_ix(\r\n        \u0026ctx.program_id,\r\n        \u0026ctx.payer.pubkey(),\r\n        \u0026config_pda,\r\n        \u0026staking_program.pubkey(),\r\n        \u0026five_a_program.pubkey(),\r\n    );\r\n    \r\n    ctx.process_transaction(\u0026[init_ix], \u0026[]).await.unwrap();\r\n    \r\n    let unauthorized = Keypair::new();\r\n    let pause_ix = create_set_paused_ix(\r\n        \u0026ctx.program_id,\r\n        \u0026unauthorized.pubkey(),\r\n        \u0026config_pda,\r\n        true,\r\n    );\r\n    \r\n    assert_eq!(pause_ix.accounts[0].pubkey, unauthorized.pubkey());\r\n}\r\n\r\n#[tokio::test]\r\nasync fn test_set_paused_toggle() {\r\n    let mut ctx = TestContext::new().await;\r\n    \r\n    let (config_pda, _bump) = ctx.get_config_pda();\r\n    let staking_program = Keypair::new();\r\n    let five_a_program = Keypair::new();\r\n    \r\n    let init_ix = create_initialize_ix(\r\n        \u0026ctx.program_id,\r\n        \u0026ctx.payer.pubkey(),\r\n        \u0026config_pda,\r\n        \u0026staking_program.pubkey(),\r\n        \u0026five_a_program.pubkey(),\r\n    );\r\n    \r\n    ctx.process_transaction(\u0026[init_ix], \u0026[]).await.unwrap();\r\n    \r\n    for paused in [true, false, true, false] {\r\n        let ix = create_set_paused_ix(\u0026ctx.program_id, \u0026ctx.payer.pubkey(), \u0026config_pda, paused);\r\n        let result = ctx.process_transaction(\u0026[ix], \u0026[]).await;\r\n        assert!(result.is_ok());\r\n    }\r\n}\r\n\r\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","governance-protocol","tests","common","mod.rs"],"content":"//! Common test utilities for governance-protocol integration tests\r\n\r\nuse anchor_lang::prelude::*;\r\nuse solana_program_test::*;\r\nuse solana_sdk::{\r\n    account::Account,\r\n    hash::Hash,\r\n    instruction::{AccountMeta, Instruction},\r\n    pubkey::Pubkey,\r\n    signature::{Keypair, Signer},\r\n    transaction::Transaction,\r\n};\r\n\r\npub const GOV_CONFIG_SEED: \u0026[u8] = b\"gov-config\";\r\npub const PROPOSAL_SEED: \u0026[u8] = b\"proposal\";\r\npub const VOTE_RECORD_SEED: \u0026[u8] = b\"vote-record\";\r\npub const DELEGATION_SEED: \u0026[u8] = b\"delegation\";\r\n\r\npub struct TestContext {\r\n    pub banks_client: BanksClient,\r\n    pub payer: Keypair,\r\n    pub recent_blockhash: Hash,\r\n    pub program_id: Pubkey,\r\n}\r\n\r\nimpl TestContext {\r\n    pub async fn new() -\u003e Self {\r\n        let program_id = governance_protocol::id();\r\n        let program_test = ProgramTest::new(\r\n            \"governance_protocol\",\r\n            program_id,\r\n            processor!(governance_protocol::entry),\r\n        );\r\n\r\n        let (banks_client, payer, recent_blockhash) = program_test.start().await;\r\n\r\n        Self {\r\n            banks_client,\r\n            payer,\r\n            recent_blockhash,\r\n            program_id,\r\n        }\r\n    }\r\n\r\n    pub async fn refresh_blockhash(\u0026mut self) {\r\n        self.recent_blockhash = self.banks_client.get_latest_blockhash().await.unwrap();\r\n    }\r\n\r\n    pub async fn get_account(\u0026mut self, pubkey: Pubkey) -\u003e Option\u003cAccount\u003e {\r\n        self.banks_client.get_account(pubkey).await.unwrap()\r\n    }\r\n\r\n    pub fn get_config_pda(\u0026self) -\u003e (Pubkey, u8) {\r\n        Pubkey::find_program_address(\u0026[GOV_CONFIG_SEED], \u0026self.program_id)\r\n    }\r\n\r\n    pub fn get_proposal_pda(\u0026self, proposal_id: u64) -\u003e (Pubkey, u8) {\r\n        Pubkey::find_program_address(\u0026[PROPOSAL_SEED, \u0026proposal_id.to_le_bytes()], \u0026self.program_id)\r\n    }\r\n\r\n    pub fn get_vote_record_pda(\u0026self, proposal: \u0026Pubkey, voter: \u0026Pubkey) -\u003e (Pubkey, u8) {\r\n        Pubkey::find_program_address(\u0026[VOTE_RECORD_SEED, proposal.as_ref(), voter.as_ref()], \u0026self.program_id)\r\n    }\r\n\r\n    pub async fn process_transaction(\r\n        \u0026mut self,\r\n        instructions: \u0026[Instruction],\r\n        signers: \u0026[\u0026Keypair],\r\n    ) -\u003e Result\u003c(), BanksClientError\u003e {\r\n        let mut all_signers = vec![\u0026self.payer];\r\n        all_signers.extend(signers);\r\n        \r\n        let tx = Transaction::new_signed_with_payer(\r\n            instructions,\r\n            Some(\u0026self.payer.pubkey()),\r\n            \u0026all_signers,\r\n            self.recent_blockhash,\r\n        );\r\n        \r\n        let result = self.banks_client.process_transaction(tx).await;\r\n        self.refresh_blockhash().await;\r\n        result\r\n    }\r\n}\r\n\r\npub fn create_initialize_ix(\r\n    program_id: \u0026Pubkey,\r\n    authority: \u0026Pubkey,\r\n    config: \u0026Pubkey,\r\n    staking_program: \u0026Pubkey,\r\n    five_a_program: \u0026Pubkey,\r\n) -\u003e Instruction {\r\n    let mut data = vec![0u8; 8 + 32 + 32];\r\n    let discriminator = anchor_lang::solana_program::hash::hash(b\"global:initialize\").to_bytes();\r\n    data[..8].copy_from_slice(\u0026discriminator[..8]);\r\n    data[8..40].copy_from_slice(staking_program.as_ref());\r\n    data[40..72].copy_from_slice(five_a_program.as_ref());\r\n\r\n    Instruction {\r\n        program_id: *program_id,\r\n        accounts: vec![\r\n            AccountMeta::new(*authority, true),\r\n            AccountMeta::new(*config, false),\r\n            AccountMeta::new_readonly(solana_sdk::system_program::id(), false),\r\n        ],\r\n        data,\r\n    }\r\n}\r\n\r\npub fn create_proposal_ix(\r\n    program_id: \u0026Pubkey,\r\n    proposer: \u0026Pubkey,\r\n    proposal: \u0026Pubkey,\r\n    config: \u0026Pubkey,\r\n    title_hash: [u8; 32],\r\n    description_uri: \u0026str,\r\n    proposal_type: u8,\r\n    enable_private_voting: bool,\r\n) -\u003e Instruction {\r\n    let uri_bytes = description_uri.as_bytes();\r\n    let mut data = vec![0u8; 8 + 32 + 4 + uri_bytes.len() + 1 + 1];\r\n    let discriminator = anchor_lang::solana_program::hash::hash(b\"global:create_proposal\").to_bytes();\r\n    data[..8].copy_from_slice(\u0026discriminator[..8]);\r\n    data[8..40].copy_from_slice(\u0026title_hash);\r\n    data[40..44].copy_from_slice(\u0026(uri_bytes.len() as u32).to_le_bytes());\r\n    data[44..44 + uri_bytes.len()].copy_from_slice(uri_bytes);\r\n    data[44 + uri_bytes.len()] = proposal_type;\r\n    data[45 + uri_bytes.len()] = if enable_private_voting { 1 } else { 0 };\r\n\r\n    Instruction {\r\n        program_id: *program_id,\r\n        accounts: vec![\r\n            AccountMeta::new(*proposer, true),\r\n            AccountMeta::new(*proposal, false),\r\n            AccountMeta::new_readonly(*config, false),\r\n            AccountMeta::new_readonly(solana_sdk::system_program::id(), false),\r\n        ],\r\n        data,\r\n    }\r\n}\r\n\r\npub fn create_cast_vote_ix(\r\n    program_id: \u0026Pubkey,\r\n    voter: \u0026Pubkey,\r\n    proposal: \u0026Pubkey,\r\n    vote_record: \u0026Pubkey,\r\n    config: \u0026Pubkey,\r\n    choice: u8,\r\n    vevcoin_balance: u64,\r\n    five_a_score: u16,\r\n    tier: u8,\r\n) -\u003e Instruction {\r\n    let mut data = vec![0u8; 8 + 1 + 8 + 2 + 1];\r\n    let discriminator = anchor_lang::solana_program::hash::hash(b\"global:cast_vote\").to_bytes();\r\n    data[..8].copy_from_slice(\u0026discriminator[..8]);\r\n    data[8] = choice;\r\n    data[9..17].copy_from_slice(\u0026vevcoin_balance.to_le_bytes());\r\n    data[17..19].copy_from_slice(\u0026five_a_score.to_le_bytes());\r\n    data[19] = tier;\r\n\r\n    Instruction {\r\n        program_id: *program_id,\r\n        accounts: vec![\r\n            AccountMeta::new(*voter, true),\r\n            AccountMeta::new(*proposal, false),\r\n            AccountMeta::new(*vote_record, false),\r\n            AccountMeta::new_readonly(*config, false),\r\n            AccountMeta::new_readonly(solana_sdk::system_program::id(), false),\r\n        ],\r\n        data,\r\n    }\r\n}\r\n\r\npub fn create_delegate_votes_ix(\r\n    program_id: \u0026Pubkey,\r\n    delegator: \u0026Pubkey,\r\n    delegate: \u0026Pubkey,\r\n    delegation: \u0026Pubkey,\r\n    config: \u0026Pubkey,\r\n    delegation_type: u8,\r\n    categories: u8,\r\n    vevcoin_amount: u64,\r\n    expires_at: i64,\r\n    revocable: bool,\r\n) -\u003e Instruction {\r\n    let mut data = vec![0u8; 8 + 1 + 1 + 8 + 8 + 1];\r\n    let discriminator = anchor_lang::solana_program::hash::hash(b\"global:delegate_votes\").to_bytes();\r\n    data[..8].copy_from_slice(\u0026discriminator[..8]);\r\n    data[8] = delegation_type;\r\n    data[9] = categories;\r\n    data[10..18].copy_from_slice(\u0026vevcoin_amount.to_le_bytes());\r\n    data[18..26].copy_from_slice(\u0026expires_at.to_le_bytes());\r\n    data[26] = if revocable { 1 } else { 0 };\r\n\r\n    Instruction {\r\n        program_id: *program_id,\r\n        accounts: vec![\r\n            AccountMeta::new(*delegator, true),\r\n            AccountMeta::new_readonly(*delegate, false),\r\n            AccountMeta::new(*delegation, false),\r\n            AccountMeta::new_readonly(*config, false),\r\n            AccountMeta::new_readonly(solana_sdk::system_program::id(), false),\r\n        ],\r\n        data,\r\n    }\r\n}\r\n\r\npub fn create_set_paused_ix(\r\n    program_id: \u0026Pubkey,\r\n    authority: \u0026Pubkey,\r\n    config: \u0026Pubkey,\r\n    paused: bool,\r\n) -\u003e Instruction {\r\n    let mut data = vec![0u8; 8 + 1];\r\n    let discriminator = anchor_lang::solana_program::hash::hash(b\"global:set_paused\").to_bytes();\r\n    data[..8].copy_from_slice(\u0026discriminator[..8]);\r\n    data[8] = if paused { 1 } else { 0 };\r\n\r\n    Instruction {\r\n        program_id: *program_id,\r\n        accounts: vec![\r\n            AccountMeta::new(*authority, true),\r\n            AccountMeta::new(*config, false),\r\n        ],\r\n        data,\r\n    }\r\n}\r\n\r\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","governance-protocol","tests","delegation.rs"],"content":"//! Integration tests for governance-protocol delegation instructions\r\n\r\nmod common;\r\n\r\nuse common::*;\r\nuse solana_sdk::signature::{Keypair, Signer};\r\n\r\n#[tokio::test]\r\nasync fn test_delegate_votes_instruction_format() {\r\n    let ctx = TestContext::new().await;\r\n    \r\n    let (config_pda, _bump) = ctx.get_config_pda();\r\n    let delegator = Keypair::new();\r\n    let delegate = Keypair::new();\r\n    let delegation = Keypair::new();\r\n    \r\n    let ix = create_delegate_votes_ix(\r\n        \u0026ctx.program_id,\r\n        \u0026delegator.pubkey(),\r\n        \u0026delegate.pubkey(),\r\n        \u0026delegation.pubkey(),\r\n        \u0026config_pda,\r\n        0, // full delegation\r\n        0xFF, // all categories\r\n        1000,\r\n        0, // no expiry\r\n        true,\r\n    );\r\n    \r\n    assert_eq!(ix.program_id, ctx.program_id);\r\n    assert_eq!(ix.accounts.len(), 5);\r\n    assert!(ix.accounts[0].is_signer);\r\n}\r\n\r\n#[tokio::test]\r\nasync fn test_delegate_votes_different_types() {\r\n    let ctx = TestContext::new().await;\r\n    \r\n    let (config_pda, _bump) = ctx.get_config_pda();\r\n    let delegator = Keypair::new();\r\n    let delegate = Keypair::new();\r\n    \r\n    for delegation_type in 0..=2 {\r\n        let delegation = Keypair::new();\r\n        \r\n        let ix = create_delegate_votes_ix(\r\n            \u0026ctx.program_id,\r\n            \u0026delegator.pubkey(),\r\n            \u0026delegate.pubkey(),\r\n            \u0026delegation.pubkey(),\r\n            \u0026config_pda,\r\n            delegation_type,\r\n            0xFF,\r\n            1000,\r\n            0,\r\n            true,\r\n        );\r\n        \r\n        assert_eq!(ix.data[8], delegation_type);\r\n    }\r\n}\r\n\r\n#[tokio::test]\r\nasync fn test_delegate_votes_different_categories() {\r\n    let ctx = TestContext::new().await;\r\n    \r\n    let (config_pda, _bump) = ctx.get_config_pda();\r\n    let delegator = Keypair::new();\r\n    let delegate = Keypair::new();\r\n    \r\n    for categories in [0x01u8, 0x02, 0x04, 0x08, 0xFF] {\r\n        let delegation = Keypair::new();\r\n        \r\n        let ix = create_delegate_votes_ix(\r\n            \u0026ctx.program_id,\r\n            \u0026delegator.pubkey(),\r\n            \u0026delegate.pubkey(),\r\n            \u0026delegation.pubkey(),\r\n            \u0026config_pda,\r\n            0,\r\n            categories,\r\n            1000,\r\n            0,\r\n            true,\r\n        );\r\n        \r\n        assert_eq!(ix.data[9], categories);\r\n    }\r\n}\r\n\r\n#[tokio::test]\r\nasync fn test_delegate_votes_with_expiry() {\r\n    let ctx = TestContext::new().await;\r\n    \r\n    let (config_pda, _bump) = ctx.get_config_pda();\r\n    let delegator = Keypair::new();\r\n    let delegate = Keypair::new();\r\n    let delegation = Keypair::new();\r\n    let expires_at = 1735689600i64; // Some future timestamp\r\n    \r\n    let ix = create_delegate_votes_ix(\r\n        \u0026ctx.program_id,\r\n        \u0026delegator.pubkey(),\r\n        \u0026delegate.pubkey(),\r\n        \u0026delegation.pubkey(),\r\n        \u0026config_pda,\r\n        0,\r\n        0xFF,\r\n        1000,\r\n        expires_at,\r\n        true,\r\n    );\r\n    \r\n    assert_eq!(\u0026ix.data[18..26], \u0026expires_at.to_le_bytes());\r\n}\r\n\r\n#[tokio::test]\r\nasync fn test_delegate_votes_non_revocable() {\r\n    let ctx = TestContext::new().await;\r\n    \r\n    let (config_pda, _bump) = ctx.get_config_pda();\r\n    let delegator = Keypair::new();\r\n    let delegate = Keypair::new();\r\n    let delegation = Keypair::new();\r\n    \r\n    let ix = create_delegate_votes_ix(\r\n        \u0026ctx.program_id,\r\n        \u0026delegator.pubkey(),\r\n        \u0026delegate.pubkey(),\r\n        \u0026delegation.pubkey(),\r\n        \u0026config_pda,\r\n        0,\r\n        0xFF,\r\n        1000,\r\n        0,\r\n        false,\r\n    );\r\n    \r\n    assert_eq!(ix.data[26], 0);\r\n}\r\n\r\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","governance-protocol","tests","initialize.rs"],"content":"//! Integration tests for governance-protocol initialize instruction\r\n\r\nmod common;\r\n\r\nuse common::*;\r\nuse solana_sdk::signature::{Keypair, Signer};\r\n\r\n#[tokio::test]\r\nasync fn test_initialize_success() {\r\n    let mut ctx = TestContext::new().await;\r\n    \r\n    let (config_pda, _bump) = ctx.get_config_pda();\r\n    let staking_program = Keypair::new();\r\n    let five_a_program = Keypair::new();\r\n    \r\n    let ix = create_initialize_ix(\r\n        \u0026ctx.program_id,\r\n        \u0026ctx.payer.pubkey(),\r\n        \u0026config_pda,\r\n        \u0026staking_program.pubkey(),\r\n        \u0026five_a_program.pubkey(),\r\n    );\r\n    \r\n    let result = ctx.process_transaction(\u0026[ix], \u0026[]).await;\r\n    assert!(result.is_ok());\r\n    \r\n    let config = ctx.get_account(config_pda).await;\r\n    assert!(config.is_some());\r\n}\r\n\r\n#[tokio::test]\r\nasync fn test_initialize_already_initialized() {\r\n    let mut ctx = TestContext::new().await;\r\n    \r\n    let (config_pda, _bump) = ctx.get_config_pda();\r\n    let staking_program = Keypair::new();\r\n    let five_a_program = Keypair::new();\r\n    \r\n    let ix = create_initialize_ix(\r\n        \u0026ctx.program_id,\r\n        \u0026ctx.payer.pubkey(),\r\n        \u0026config_pda,\r\n        \u0026staking_program.pubkey(),\r\n        \u0026five_a_program.pubkey(),\r\n    );\r\n    \r\n    ctx.process_transaction(\u0026[ix.clone()], \u0026[]).await.unwrap();\r\n    \r\n    let result = ctx.process_transaction(\u0026[ix], \u0026[]).await;\r\n    assert!(result.is_err());\r\n}\r\n\r\n#[tokio::test]\r\nasync fn test_initialize_with_programs() {\r\n    let mut ctx = TestContext::new().await;\r\n    \r\n    let (config_pda, _bump) = ctx.get_config_pda();\r\n    let staking_program = Keypair::new();\r\n    let five_a_program = Keypair::new();\r\n    \r\n    let ix = create_initialize_ix(\r\n        \u0026ctx.program_id,\r\n        \u0026ctx.payer.pubkey(),\r\n        \u0026config_pda,\r\n        \u0026staking_program.pubkey(),\r\n        \u0026five_a_program.pubkey(),\r\n    );\r\n    \r\n    let result = ctx.process_transaction(\u0026[ix], \u0026[]).await;\r\n    assert!(result.is_ok());\r\n}\r\n\r\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","governance-protocol","tests","proposal.rs"],"content":"//! Integration tests for governance-protocol proposal instructions\r\n\r\nmod common;\r\n\r\nuse common::*;\r\nuse solana_sdk::signature::{Keypair, Signer};\r\n\r\n#[tokio::test]\r\nasync fn test_create_proposal_instruction_format() {\r\n    let ctx = TestContext::new().await;\r\n    \r\n    let (config_pda, _bump) = ctx.get_config_pda();\r\n    let proposer = Keypair::new();\r\n    let (proposal_pda, _) = ctx.get_proposal_pda(1);\r\n    let title_hash = [1u8; 32];\r\n    \r\n    let ix = create_proposal_ix(\r\n        \u0026ctx.program_id,\r\n        \u0026proposer.pubkey(),\r\n        \u0026proposal_pda,\r\n        \u0026config_pda,\r\n        title_hash,\r\n        \"ipfs://QmDescription\",\r\n        0,\r\n        false,\r\n    );\r\n    \r\n    assert_eq!(ix.program_id, ctx.program_id);\r\n    assert_eq!(ix.accounts.len(), 4);\r\n    assert!(ix.accounts[0].is_signer);\r\n}\r\n\r\n#[tokio::test]\r\nasync fn test_create_proposal_different_types() {\r\n    let ctx = TestContext::new().await;\r\n    \r\n    let (config_pda, _bump) = ctx.get_config_pda();\r\n    let proposer = Keypair::new();\r\n    \r\n    for proposal_type in 0..=4 {\r\n        let (proposal_pda, _) = ctx.get_proposal_pda(proposal_type as u64);\r\n        let title_hash = [proposal_type; 32];\r\n        \r\n        let ix = create_proposal_ix(\r\n            \u0026ctx.program_id,\r\n            \u0026proposer.pubkey(),\r\n            \u0026proposal_pda,\r\n            \u0026config_pda,\r\n            title_hash,\r\n            \u0026format!(\"ipfs://proposal{}\", proposal_type),\r\n            proposal_type,\r\n            false,\r\n        );\r\n        \r\n        assert!(ix.data.len() \u003e 8 + 32);\r\n    }\r\n}\r\n\r\n#[tokio::test]\r\nasync fn test_create_proposal_with_private_voting() {\r\n    let ctx = TestContext::new().await;\r\n    \r\n    let (config_pda, _bump) = ctx.get_config_pda();\r\n    let proposer = Keypair::new();\r\n    let (proposal_pda, _) = ctx.get_proposal_pda(1);\r\n    let title_hash = [2u8; 32];\r\n    \r\n    let ix = create_proposal_ix(\r\n        \u0026ctx.program_id,\r\n        \u0026proposer.pubkey(),\r\n        \u0026proposal_pda,\r\n        \u0026config_pda,\r\n        title_hash,\r\n        \"ipfs://QmPrivateProposal\",\r\n        0,\r\n        true,\r\n    );\r\n    \r\n    let last_byte = *ix.data.last().unwrap();\r\n    assert_eq!(last_byte, 1); // private voting enabled\r\n}\r\n\r\n#[tokio::test]\r\nasync fn test_create_proposal_short_uri() {\r\n    let ctx = TestContext::new().await;\r\n    \r\n    let (config_pda, _bump) = ctx.get_config_pda();\r\n    let proposer = Keypair::new();\r\n    let (proposal_pda, _) = ctx.get_proposal_pda(1);\r\n    let title_hash = [3u8; 32];\r\n    \r\n    let ix = create_proposal_ix(\r\n        \u0026ctx.program_id,\r\n        \u0026proposer.pubkey(),\r\n        \u0026proposal_pda,\r\n        \u0026config_pda,\r\n        title_hash,\r\n        \"a\",\r\n        0,\r\n        false,\r\n    );\r\n    \r\n    assert!(ix.data.len() \u003e 8 + 32);\r\n}\r\n\r\n#[tokio::test]\r\nasync fn test_create_proposal_long_uri() {\r\n    let ctx = TestContext::new().await;\r\n    \r\n    let (config_pda, _bump) = ctx.get_config_pda();\r\n    let proposer = Keypair::new();\r\n    let (proposal_pda, _) = ctx.get_proposal_pda(1);\r\n    let title_hash = [4u8; 32];\r\n    let long_uri = \"ipfs://QmVeryLongDescriptionURIThatIsQuiteVeryLongIndeed\";\r\n    \r\n    let ix = create_proposal_ix(\r\n        \u0026ctx.program_id,\r\n        \u0026proposer.pubkey(),\r\n        \u0026proposal_pda,\r\n        \u0026config_pda,\r\n        title_hash,\r\n        long_uri,\r\n        0,\r\n        false,\r\n    );\r\n    \r\n    assert!(ix.data.len() \u003e 8 + 32 + 4 + long_uri.len());\r\n}\r\n\r\n#[tokio::test]\r\nasync fn test_create_proposal_multiple_proposers() {\r\n    let ctx = TestContext::new().await;\r\n    \r\n    let (config_pda, _bump) = ctx.get_config_pda();\r\n    \r\n    for i in 0..5 {\r\n        let proposer = Keypair::new();\r\n        let (proposal_pda, _) = ctx.get_proposal_pda(i);\r\n        let mut title_hash = [0u8; 32];\r\n        title_hash[0] = i as u8;\r\n        \r\n        let ix = create_proposal_ix(\r\n            \u0026ctx.program_id,\r\n            \u0026proposer.pubkey(),\r\n            \u0026proposal_pda,\r\n            \u0026config_pda,\r\n            title_hash,\r\n            \u0026format!(\"ipfs://proposal{}\", i),\r\n            0,\r\n            false,\r\n        );\r\n        \r\n        assert_eq!(ix.accounts[0].pubkey, proposer.pubkey());\r\n    }\r\n}\r\n\r\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","governance-protocol","tests","vote.rs"],"content":"//! Integration tests for governance-protocol vote instructions\r\n\r\nmod common;\r\n\r\nuse common::*;\r\nuse solana_sdk::signature::{Keypair, Signer};\r\n\r\n#[tokio::test]\r\nasync fn test_cast_vote_instruction_format() {\r\n    let ctx = TestContext::new().await;\r\n    \r\n    let (config_pda, _bump) = ctx.get_config_pda();\r\n    let voter = Keypair::new();\r\n    let proposal = Keypair::new();\r\n    let (vote_record_pda, _) = ctx.get_vote_record_pda(\u0026proposal.pubkey(), \u0026voter.pubkey());\r\n    \r\n    let ix = create_cast_vote_ix(\r\n        \u0026ctx.program_id,\r\n        \u0026voter.pubkey(),\r\n        \u0026proposal.pubkey(),\r\n        \u0026vote_record_pda,\r\n        \u0026config_pda,\r\n        1, // for\r\n        1000,\r\n        8000,\r\n        1, // bronze\r\n    );\r\n    \r\n    assert_eq!(ix.program_id, ctx.program_id);\r\n    assert_eq!(ix.accounts.len(), 5);\r\n    assert!(ix.accounts[0].is_signer);\r\n}\r\n\r\n#[tokio::test]\r\nasync fn test_cast_vote_for() {\r\n    let ctx = TestContext::new().await;\r\n    \r\n    let (config_pda, _bump) = ctx.get_config_pda();\r\n    let voter = Keypair::new();\r\n    let proposal = Keypair::new();\r\n    let (vote_record_pda, _) = ctx.get_vote_record_pda(\u0026proposal.pubkey(), \u0026voter.pubkey());\r\n    \r\n    let ix = create_cast_vote_ix(\r\n        \u0026ctx.program_id,\r\n        \u0026voter.pubkey(),\r\n        \u0026proposal.pubkey(),\r\n        \u0026vote_record_pda,\r\n        \u0026config_pda,\r\n        1, // for\r\n        1000,\r\n        8000,\r\n        1,\r\n    );\r\n    \r\n    assert_eq!(ix.data[8], 1);\r\n}\r\n\r\n#[tokio::test]\r\nasync fn test_cast_vote_against() {\r\n    let ctx = TestContext::new().await;\r\n    \r\n    let (config_pda, _bump) = ctx.get_config_pda();\r\n    let voter = Keypair::new();\r\n    let proposal = Keypair::new();\r\n    let (vote_record_pda, _) = ctx.get_vote_record_pda(\u0026proposal.pubkey(), \u0026voter.pubkey());\r\n    \r\n    let ix = create_cast_vote_ix(\r\n        \u0026ctx.program_id,\r\n        \u0026voter.pubkey(),\r\n        \u0026proposal.pubkey(),\r\n        \u0026vote_record_pda,\r\n        \u0026config_pda,\r\n        2, // against\r\n        1000,\r\n        8000,\r\n        1,\r\n    );\r\n    \r\n    assert_eq!(ix.data[8], 2);\r\n}\r\n\r\n#[tokio::test]\r\nasync fn test_cast_vote_abstain() {\r\n    let ctx = TestContext::new().await;\r\n    \r\n    let (config_pda, _bump) = ctx.get_config_pda();\r\n    let voter = Keypair::new();\r\n    let proposal = Keypair::new();\r\n    let (vote_record_pda, _) = ctx.get_vote_record_pda(\u0026proposal.pubkey(), \u0026voter.pubkey());\r\n    \r\n    let ix = create_cast_vote_ix(\r\n        \u0026ctx.program_id,\r\n        \u0026voter.pubkey(),\r\n        \u0026proposal.pubkey(),\r\n        \u0026vote_record_pda,\r\n        \u0026config_pda,\r\n        0, // abstain\r\n        1000,\r\n        8000,\r\n        1,\r\n    );\r\n    \r\n    assert_eq!(ix.data[8], 0);\r\n}\r\n\r\n#[tokio::test]\r\nasync fn test_cast_vote_different_tiers() {\r\n    let ctx = TestContext::new().await;\r\n    \r\n    let (config_pda, _bump) = ctx.get_config_pda();\r\n    let proposal = Keypair::new();\r\n    \r\n    for tier in 0..=4 {\r\n        let voter = Keypair::new();\r\n        let (vote_record_pda, _) = ctx.get_vote_record_pda(\u0026proposal.pubkey(), \u0026voter.pubkey());\r\n        \r\n        let ix = create_cast_vote_ix(\r\n            \u0026ctx.program_id,\r\n            \u0026voter.pubkey(),\r\n            \u0026proposal.pubkey(),\r\n            \u0026vote_record_pda,\r\n            \u0026config_pda,\r\n            1,\r\n            1000,\r\n            8000,\r\n            tier,\r\n        );\r\n        \r\n        assert_eq!(ix.data[19], tier);\r\n    }\r\n}\r\n\r\n#[tokio::test]\r\nasync fn test_cast_vote_different_scores() {\r\n    let ctx = TestContext::new().await;\r\n    \r\n    let (config_pda, _bump) = ctx.get_config_pda();\r\n    let proposal = Keypair::new();\r\n    \r\n    for score in [0u16, 5000, 8000, 10000] {\r\n        let voter = Keypair::new();\r\n        let (vote_record_pda, _) = ctx.get_vote_record_pda(\u0026proposal.pubkey(), \u0026voter.pubkey());\r\n        \r\n        let ix = create_cast_vote_ix(\r\n            \u0026ctx.program_id,\r\n            \u0026voter.pubkey(),\r\n            \u0026proposal.pubkey(),\r\n            \u0026vote_record_pda,\r\n            \u0026config_pda,\r\n            1,\r\n            1000,\r\n            score,\r\n            1,\r\n        );\r\n        \r\n        assert_eq!(\u0026ix.data[17..19], \u0026score.to_le_bytes());\r\n    }\r\n}\r\n\r\n#[tokio::test]\r\nasync fn test_cast_vote_different_balances() {\r\n    let ctx = TestContext::new().await;\r\n    \r\n    let (config_pda, _bump) = ctx.get_config_pda();\r\n    let proposal = Keypair::new();\r\n    \r\n    for balance in [1u64, 1000, 100_000, 1_000_000] {\r\n        let voter = Keypair::new();\r\n        let (vote_record_pda, _) = ctx.get_vote_record_pda(\u0026proposal.pubkey(), \u0026voter.pubkey());\r\n        \r\n        let ix = create_cast_vote_ix(\r\n            \u0026ctx.program_id,\r\n            \u0026voter.pubkey(),\r\n            \u0026proposal.pubkey(),\r\n            \u0026vote_record_pda,\r\n            \u0026config_pda,\r\n            1,\r\n            balance,\r\n            8000,\r\n            1,\r\n        );\r\n        \r\n        assert_eq!(\u0026ix.data[9..17], \u0026balance.to_le_bytes());\r\n    }\r\n}\r\n\r\n#[tokio::test]\r\nasync fn test_cast_vote_multiple_voters() {\r\n    let ctx = TestContext::new().await;\r\n    \r\n    let (config_pda, _bump) = ctx.get_config_pda();\r\n    let proposal = Keypair::new();\r\n    \r\n    for i in 0..10 {\r\n        let voter = Keypair::new();\r\n        let (vote_record_pda, _) = ctx.get_vote_record_pda(\u0026proposal.pubkey(), \u0026voter.pubkey());\r\n        \r\n        let ix = create_cast_vote_ix(\r\n            \u0026ctx.program_id,\r\n            \u0026voter.pubkey(),\r\n            \u0026proposal.pubkey(),\r\n            \u0026vote_record_pda,\r\n            \u0026config_pda,\r\n            (i % 3) as u8,\r\n            (i + 1) * 100,\r\n            8000,\r\n            1,\r\n        );\r\n        \r\n        assert_eq!(ix.accounts[0].pubkey, voter.pubkey());\r\n    }\r\n}\r\n\r\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","identity-protocol","src","constants.rs"],"content":"/// Identity Protocol Constants\r\n\r\n/// PDA Seeds\r\npub const IDENTITY_CONFIG_SEED: \u0026[u8] = b\"identity-config\";\r\npub const IDENTITY_SEED: \u0026[u8] = b\"identity\";\r\npub const SAS_ATTESTATION_SEED: \u0026[u8] = b\"sas-attestation\";\r\npub const SUBSCRIPTION_SEED: \u0026[u8] = b\"subscription\";\r\n\r\n/// Subscription prices in USDC (6 decimals)\r\npub const SUBSCRIPTION_FREE: u64 = 0;\r\npub const SUBSCRIPTION_VERIFIED: u64 = 4_000_000;   // $4 USDC\r\npub const SUBSCRIPTION_PREMIUM: u64 = 12_000_000;   // $12 USDC\r\npub const SUBSCRIPTION_ENTERPRISE: u64 = 59_000_000; // $59 USDC\r\n\r\n/// Subscription duration (30 days in seconds)\r\npub const SUBSCRIPTION_DURATION: i64 = 30 * 24 * 60 * 60;\r\n\r\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","identity-protocol","src","contexts","admin_update_identity.rs"],"content":"use anchor_lang::prelude::*;\r\n\r\nuse crate::constants::{IDENTITY_CONFIG_SEED, IDENTITY_SEED};\r\nuse crate::errors::IdentityError;\r\nuse crate::state::{IdentityConfig, Identity};\r\n\r\n#[derive(Accounts)]\r\npub struct AdminUpdateIdentity\u003c'info\u003e {\r\n    #[account(\r\n        mut,\r\n        seeds = [IDENTITY_CONFIG_SEED],\r\n        bump = identity_config.bump,\r\n        has_one = authority @ IdentityError::Unauthorized\r\n    )]\r\n    pub identity_config: Account\u003c'info, IdentityConfig\u003e,\r\n    \r\n    #[account(\r\n        mut,\r\n        seeds = [IDENTITY_SEED, identity.owner.as_ref()],\r\n        bump = identity.bump\r\n    )]\r\n    pub identity: Account\u003c'info, Identity\u003e,\r\n    \r\n    pub authority: Signer\u003c'info\u003e,\r\n}\r\n\r\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","identity-protocol","src","contexts","create_identity.rs"],"content":"use anchor_lang::prelude::*;\r\n\r\nuse crate::constants::{IDENTITY_CONFIG_SEED, IDENTITY_SEED};\r\nuse crate::state::{IdentityConfig, Identity};\r\n\r\n#[derive(Accounts)]\r\npub struct CreateIdentity\u003c'info\u003e {\r\n    #[account(\r\n        mut,\r\n        seeds = [IDENTITY_CONFIG_SEED],\r\n        bump = identity_config.bump\r\n    )]\r\n    pub identity_config: Account\u003c'info, IdentityConfig\u003e,\r\n    \r\n    #[account(\r\n        init,\r\n        payer = owner,\r\n        space = Identity::LEN,\r\n        seeds = [IDENTITY_SEED, owner.key().as_ref()],\r\n        bump\r\n    )]\r\n    pub identity: Account\u003c'info, Identity\u003e,\r\n    \r\n    #[account(mut)]\r\n    pub owner: Signer\u003c'info\u003e,\r\n    \r\n    pub system_program: Program\u003c'info, System\u003e,\r\n}\r\n\r\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","identity-protocol","src","contexts","get_identity.rs"],"content":"use anchor_lang::prelude::*;\r\n\r\nuse crate::constants::IDENTITY_SEED;\r\nuse crate::state::Identity;\r\n\r\n#[derive(Accounts)]\r\npub struct GetIdentity\u003c'info\u003e {\r\n    #[account(\r\n        seeds = [IDENTITY_SEED, identity.owner.as_ref()],\r\n        bump = identity.bump\r\n    )]\r\n    pub identity: Account\u003c'info, Identity\u003e,\r\n}\r\n\r\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","identity-protocol","src","contexts","initialize.rs"],"content":"use anchor_lang::prelude::*;\r\n\r\nuse crate::constants::IDENTITY_CONFIG_SEED;\r\nuse crate::state::IdentityConfig;\r\n\r\n#[derive(Accounts)]\r\npub struct Initialize\u003c'info\u003e {\r\n    #[account(\r\n        init,\r\n        payer = authority,\r\n        space = IdentityConfig::LEN,\r\n        seeds = [IDENTITY_CONFIG_SEED],\r\n        bump\r\n    )]\r\n    pub identity_config: Account\u003c'info, IdentityConfig\u003e,\r\n    \r\n    /// CHECK: Treasury account for subscription payments\r\n    pub treasury: UncheckedAccount\u003c'info\u003e,\r\n    \r\n    #[account(mut)]\r\n    pub authority: Signer\u003c'info\u003e,\r\n    \r\n    pub system_program: Program\u003c'info, System\u003e,\r\n}\r\n\r\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","identity-protocol","src","contexts","link_sas_attestation.rs"],"content":"use anchor_lang::prelude::*;\r\n\r\nuse crate::constants::{IDENTITY_CONFIG_SEED, IDENTITY_SEED, SAS_ATTESTATION_SEED};\r\nuse crate::state::{IdentityConfig, Identity, UserSASAttestation};\r\n\r\n#[derive(Accounts)]\r\npub struct LinkSASAttestation\u003c'info\u003e {\r\n    #[account(\r\n        seeds = [IDENTITY_CONFIG_SEED],\r\n        bump = identity_config.bump\r\n    )]\r\n    pub identity_config: Account\u003c'info, IdentityConfig\u003e,\r\n    \r\n    #[account(\r\n        mut,\r\n        seeds = [IDENTITY_SEED, user.key().as_ref()],\r\n        bump = identity.bump\r\n    )]\r\n    pub identity: Account\u003c'info, Identity\u003e,\r\n    \r\n    #[account(\r\n        init,\r\n        payer = user,\r\n        space = UserSASAttestation::LEN,\r\n        seeds = [SAS_ATTESTATION_SEED, user.key().as_ref()],\r\n        bump\r\n    )]\r\n    pub sas_attestation: Account\u003c'info, UserSASAttestation\u003e,\r\n    \r\n    #[account(mut)]\r\n    pub user: Signer\u003c'info\u003e,\r\n    \r\n    /// The attester signing this attestation\r\n    pub attester: Signer\u003c'info\u003e,\r\n    \r\n    pub system_program: Program\u003c'info, System\u003e,\r\n}\r\n\r\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","identity-protocol","src","contexts","mod.rs"],"content":"/// Contexts module - Account validation structures\r\nmod initialize;\r\nmod create_identity;\r\nmod update_identity;\r\nmod admin_update_identity;\r\nmod link_sas_attestation;\r\nmod subscribe;\r\nmod update_config;\r\nmod update_authority;\r\nmod get_identity;\r\n\r\npub use initialize::*;\r\npub use create_identity::*;\r\npub use update_identity::*;\r\npub use admin_update_identity::*;\r\npub use link_sas_attestation::*;\r\npub use subscribe::*;\r\npub use update_config::*;\r\npub use update_authority::*;\r\npub use get_identity::*;\r\n\r\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","identity-protocol","src","contexts","subscribe.rs"],"content":"use anchor_lang::prelude::*;\r\n\r\nuse crate::constants::{IDENTITY_CONFIG_SEED, SUBSCRIPTION_SEED};\r\nuse crate::state::{IdentityConfig, Subscription};\r\n\r\n#[derive(Accounts)]\r\npub struct Subscribe\u003c'info\u003e {\r\n    #[account(\r\n        seeds = [IDENTITY_CONFIG_SEED],\r\n        bump = identity_config.bump\r\n    )]\r\n    pub identity_config: Account\u003c'info, IdentityConfig\u003e,\r\n    \r\n    #[account(\r\n        init_if_needed,\r\n        payer = user,\r\n        space = Subscription::LEN,\r\n        seeds = [SUBSCRIPTION_SEED, user.key().as_ref()],\r\n        bump\r\n    )]\r\n    pub subscription: Account\u003c'info, Subscription\u003e,\r\n    \r\n    #[account(mut)]\r\n    pub user: Signer\u003c'info\u003e,\r\n    \r\n    pub system_program: Program\u003c'info, System\u003e,\r\n}\r\n\r\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","identity-protocol","src","contexts","update_authority.rs"],"content":"use anchor_lang::prelude::*;\r\n\r\nuse crate::constants::IDENTITY_CONFIG_SEED;\r\nuse crate::errors::IdentityError;\r\nuse crate::state::IdentityConfig;\r\n\r\n#[derive(Accounts)]\r\npub struct UpdateAuthority\u003c'info\u003e {\r\n    #[account(\r\n        mut,\r\n        seeds = [IDENTITY_CONFIG_SEED],\r\n        bump = identity_config.bump,\r\n        has_one = authority @ IdentityError::Unauthorized\r\n    )]\r\n    pub identity_config: Account\u003c'info, IdentityConfig\u003e,\r\n    \r\n    pub authority: Signer\u003c'info\u003e,\r\n}\r\n\r\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","identity-protocol","src","contexts","update_config.rs"],"content":"use anchor_lang::prelude::*;\r\n\r\nuse crate::constants::IDENTITY_CONFIG_SEED;\r\nuse crate::errors::IdentityError;\r\nuse crate::state::IdentityConfig;\r\n\r\n#[derive(Accounts)]\r\npub struct UpdateConfig\u003c'info\u003e {\r\n    #[account(\r\n        mut,\r\n        seeds = [IDENTITY_CONFIG_SEED],\r\n        bump = identity_config.bump,\r\n        has_one = authority @ IdentityError::Unauthorized\r\n    )]\r\n    pub identity_config: Account\u003c'info, IdentityConfig\u003e,\r\n    \r\n    pub authority: Signer\u003c'info\u003e,\r\n}\r\n\r\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","identity-protocol","src","contexts","update_identity.rs"],"content":"use anchor_lang::prelude::*;\r\n\r\nuse crate::constants::IDENTITY_SEED;\r\nuse crate::state::Identity;\r\n\r\n#[derive(Accounts)]\r\npub struct UpdateIdentity\u003c'info\u003e {\r\n    #[account(\r\n        mut,\r\n        seeds = [IDENTITY_SEED, owner.key().as_ref()],\r\n        bump = identity.bump,\r\n        has_one = owner\r\n    )]\r\n    pub identity: Account\u003c'info, Identity\u003e,\r\n    \r\n    pub owner: Signer\u003c'info\u003e,\r\n}\r\n\r\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","identity-protocol","src","errors.rs"],"content":"use anchor_lang::prelude::*;\r\n\r\n/// Identity Protocol Error Codes\r\n#[error_code]\r\npub enum IdentityError {\r\n    #[msg(\"Unauthorized: Only the authority can perform this action\")]\r\n    Unauthorized,\r\n    \r\n    #[msg(\"Identity protocol is paused\")]\r\n    ProtocolPaused,\r\n    \r\n    #[msg(\"Identity already exists for this wallet\")]\r\n    IdentityAlreadyExists,\r\n    \r\n    #[msg(\"Identity does not exist\")]\r\n    IdentityNotFound,\r\n    \r\n    #[msg(\"Invalid verification level\")]\r\n    InvalidVerificationLevel,\r\n    \r\n    #[msg(\"Verification level cannot be downgraded\")]\r\n    CannotDowngradeVerification,\r\n    \r\n    #[msg(\"SAS attestation required for this verification level\")]\r\n    SASAttestationRequired,\r\n    \r\n    #[msg(\"SAS attestation has expired\")]\r\n    SASAttestationExpired,\r\n    \r\n    #[msg(\"Invalid subscription tier\")]\r\n    InvalidSubscriptionTier,\r\n    \r\n    #[msg(\"Subscription has expired\")]\r\n    SubscriptionExpired,\r\n    \r\n    #[msg(\"Insufficient payment for subscription\")]\r\n    InsufficientPayment,\r\n    \r\n    #[msg(\"Attestation not from trusted attester\")]\r\n    UntrustedAttester,\r\n    \r\n    #[msg(\"Arithmetic overflow\")]\r\n    Overflow,\r\n}\r\n\r\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","identity-protocol","src","events.rs"],"content":"use anchor_lang::prelude::*;\r\n\r\n#[event]\r\npub struct IdentityCreated {\r\n    pub owner: Pubkey,\r\n    pub username: String,\r\n    pub timestamp: i64,\r\n}\r\n\r\n#[event]\r\npub struct VerificationUpdated {\r\n    pub owner: Pubkey,\r\n    pub old_level: u8,\r\n    pub new_level: u8,\r\n    pub timestamp: i64,\r\n}\r\n\r\n#[event]\r\npub struct SASAttestationLinked {\r\n    pub user: Pubkey,\r\n    pub attestation_id: Pubkey,\r\n    pub attester: Pubkey,\r\n    pub verification_level: u8,\r\n}\r\n\r\n#[event]\r\npub struct SubscriptionUpdated {\r\n    pub user: Pubkey,\r\n    pub tier: u8,\r\n    pub expires_at: i64,\r\n}\r\n\r\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","identity-protocol","src","instructions","admin","add_trusted_attester.rs"],"content":"use anchor_lang::prelude::*;\r\n\r\nuse crate::contexts::UpdateConfig;\r\nuse crate::errors::IdentityError;\r\n\r\n/// Add trusted attester (admin only)\r\npub fn handler(ctx: Context\u003cUpdateConfig\u003e, attester: Pubkey) -\u003e Result\u003c()\u003e {\r\n    let config = \u0026mut ctx.accounts.identity_config;\r\n    \r\n    require!(config.attester_count \u003c 10, IdentityError::Overflow);\r\n    \r\n    let idx = config.attester_count as usize;\r\n    config.trusted_attesters[idx] = attester;\r\n    config.attester_count += 1;\r\n    \r\n    msg!(\"Trusted attester added: {}\", attester);\r\n    Ok(())\r\n}\r\n\r\n","traces":[{"line":7,"address":[],"length":0,"stats":{"Line":0}},{"line":8,"address":[],"length":0,"stats":{"Line":0}},{"line":10,"address":[],"length":0,"stats":{"Line":0}},{"line":12,"address":[],"length":0,"stats":{"Line":0}},{"line":13,"address":[],"length":0,"stats":{"Line":0}},{"line":14,"address":[],"length":0,"stats":{"Line":0}},{"line":16,"address":[],"length":0,"stats":{"Line":0}},{"line":17,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":8},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","identity-protocol","src","instructions","admin","initialize.rs"],"content":"use anchor_lang::prelude::*;\r\n\r\nuse crate::contexts::Initialize;\r\n\r\n/// Initialize the identity protocol\r\npub fn handler(ctx: Context\u003cInitialize\u003e, sas_program: Pubkey, usdc_mint: Pubkey) -\u003e Result\u003c()\u003e {\r\n    let config = \u0026mut ctx.accounts.identity_config;\r\n    \r\n    config.authority = ctx.accounts.authority.key();\r\n    config.sas_program = sas_program;\r\n    config.usdc_mint = usdc_mint;\r\n    config.treasury = ctx.accounts.treasury.key();\r\n    config.trusted_attesters = [Pubkey::default(); 10];\r\n    config.attester_count = 0;\r\n    config.total_identities = 0;\r\n    config.verified_identities = 0;\r\n    config.paused = false;\r\n    config.bump = ctx.bumps.identity_config;\r\n    \r\n    msg!(\"Identity protocol initialized\");\r\n    Ok(())\r\n}\r\n\r\n","traces":[{"line":6,"address":[],"length":0,"stats":{"Line":0}},{"line":7,"address":[],"length":0,"stats":{"Line":0}},{"line":9,"address":[],"length":0,"stats":{"Line":0}},{"line":10,"address":[],"length":0,"stats":{"Line":0}},{"line":11,"address":[],"length":0,"stats":{"Line":0}},{"line":12,"address":[],"length":0,"stats":{"Line":0}},{"line":13,"address":[],"length":0,"stats":{"Line":0}},{"line":14,"address":[],"length":0,"stats":{"Line":0}},{"line":15,"address":[],"length":0,"stats":{"Line":0}},{"line":16,"address":[],"length":0,"stats":{"Line":0}},{"line":17,"address":[],"length":0,"stats":{"Line":0}},{"line":18,"address":[],"length":0,"stats":{"Line":0}},{"line":20,"address":[],"length":0,"stats":{"Line":0}},{"line":21,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":14},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","identity-protocol","src","instructions","admin","mod.rs"],"content":"/// Admin instructions\r\npub mod initialize;\r\npub mod update_verification;\r\npub mod add_trusted_attester;\r\npub mod remove_trusted_attester;\r\npub mod set_paused;\r\npub mod update_authority;\r\n\r\npub use initialize::*;\r\npub use update_verification::*;\r\npub use add_trusted_attester::*;\r\npub use remove_trusted_attester::*;\r\npub use set_paused::*;\r\npub use update_authority::*;\r\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","identity-protocol","src","instructions","admin","remove_trusted_attester.rs"],"content":"use anchor_lang::prelude::*;\r\n\r\nuse crate::contexts::UpdateConfig;\r\nuse crate::errors::IdentityError;\r\n\r\n/// Remove trusted attester (admin only)\r\npub fn handler(ctx: Context\u003cUpdateConfig\u003e, attester: Pubkey) -\u003e Result\u003c()\u003e {\r\n    let config = \u0026mut ctx.accounts.identity_config;\r\n    \r\n    // Find and remove the attester\r\n    let mut found = false;\r\n    let count = config.attester_count as usize;\r\n    for i in 0..count {\r\n        if config.trusted_attesters[i] == attester {\r\n            // Shift remaining attesters\r\n            let last_idx = (config.attester_count - 1) as usize;\r\n            for j in i..last_idx {\r\n                config.trusted_attesters[j] = config.trusted_attesters[j + 1];\r\n            }\r\n            config.trusted_attesters[last_idx] = Pubkey::default();\r\n            config.attester_count -= 1;\r\n            found = true;\r\n            break;\r\n        }\r\n    }\r\n    \r\n    require!(found, IdentityError::UntrustedAttester);\r\n    \r\n    msg!(\"Trusted attester removed: {}\", attester);\r\n    Ok(())\r\n}\r\n\r\n","traces":[{"line":7,"address":[],"length":0,"stats":{"Line":0}},{"line":8,"address":[],"length":0,"stats":{"Line":0}},{"line":11,"address":[],"length":0,"stats":{"Line":0}},{"line":12,"address":[],"length":0,"stats":{"Line":0}},{"line":13,"address":[],"length":0,"stats":{"Line":0}},{"line":14,"address":[],"length":0,"stats":{"Line":0}},{"line":16,"address":[],"length":0,"stats":{"Line":0}},{"line":17,"address":[],"length":0,"stats":{"Line":0}},{"line":18,"address":[],"length":0,"stats":{"Line":0}},{"line":20,"address":[],"length":0,"stats":{"Line":0}},{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":30,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":16},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","identity-protocol","src","instructions","admin","set_paused.rs"],"content":"use anchor_lang::prelude::*;\r\n\r\nuse crate::contexts::UpdateConfig;\r\n\r\n/// Pause/unpause protocol\r\npub fn handler(ctx: Context\u003cUpdateConfig\u003e, paused: bool) -\u003e Result\u003c()\u003e {\r\n    ctx.accounts.identity_config.paused = paused;\r\n    msg!(\"Identity protocol paused: {}\", paused);\r\n    Ok(())\r\n}\r\n\r\n","traces":[{"line":6,"address":[],"length":0,"stats":{"Line":0}},{"line":7,"address":[],"length":0,"stats":{"Line":0}},{"line":8,"address":[],"length":0,"stats":{"Line":0}},{"line":9,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":4},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","identity-protocol","src","instructions","admin","update_authority.rs"],"content":"use anchor_lang::prelude::*;\r\n\r\nuse crate::contexts::UpdateAuthority;\r\n\r\n/// Update authority\r\npub fn handler(ctx: Context\u003cUpdateAuthority\u003e, new_authority: Pubkey) -\u003e Result\u003c()\u003e {\r\n    ctx.accounts.identity_config.authority = new_authority;\r\n    msg!(\"Authority updated to: {}\", new_authority);\r\n    Ok(())\r\n}\r\n\r\n","traces":[{"line":6,"address":[],"length":0,"stats":{"Line":0}},{"line":7,"address":[],"length":0,"stats":{"Line":0}},{"line":8,"address":[],"length":0,"stats":{"Line":0}},{"line":9,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":4},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","identity-protocol","src","instructions","admin","update_verification.rs"],"content":"use anchor_lang::prelude::*;\r\n\r\nuse crate::contexts::AdminUpdateIdentity;\r\nuse crate::errors::IdentityError;\r\nuse crate::events::VerificationUpdated;\r\nuse crate::state::VerificationLevel;\r\n\r\n/// Update verification level (admin only)\r\npub fn handler(\r\n    ctx: Context\u003cAdminUpdateIdentity\u003e,\r\n    new_level: u8,\r\n    verification_hash: [u8; 32],\r\n) -\u003e Result\u003c()\u003e {\r\n    let _level = VerificationLevel::from_u8(new_level)\r\n        .ok_or(IdentityError::InvalidVerificationLevel)?;\r\n    \r\n    let clock = Clock::get()?;\r\n    let identity = \u0026mut ctx.accounts.identity;\r\n    let old_level = identity.verification_level;\r\n    \r\n    // Cannot downgrade verification\r\n    require!(\r\n        new_level \u003e= old_level,\r\n        IdentityError::CannotDowngradeVerification\r\n    );\r\n    \r\n    identity.verification_level = new_level;\r\n    identity.verification_hash = verification_hash;\r\n    identity.updated_at = clock.unix_timestamp;\r\n    \r\n    // Update verified count if upgrading from None\r\n    if old_level == 0 \u0026\u0026 new_level \u003e 0 {\r\n        let config = \u0026mut ctx.accounts.identity_config;\r\n        config.verified_identities = config.verified_identities.saturating_add(1);\r\n    }\r\n    \r\n    emit!(VerificationUpdated {\r\n        owner: identity.owner,\r\n        old_level,\r\n        new_level,\r\n        timestamp: clock.unix_timestamp,\r\n    });\r\n    \r\n    msg!(\"Verification updated: {} -\u003e {}\", old_level, new_level);\r\n    Ok(())\r\n}\r\n\r\n","traces":[{"line":9,"address":[],"length":0,"stats":{"Line":0}},{"line":14,"address":[],"length":0,"stats":{"Line":0}},{"line":15,"address":[],"length":0,"stats":{"Line":0}},{"line":17,"address":[],"length":0,"stats":{"Line":0}},{"line":18,"address":[],"length":0,"stats":{"Line":0}},{"line":19,"address":[],"length":0,"stats":{"Line":0}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":22},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","identity-protocol","src","instructions","mod.rs"],"content":"/// Instructions module - Instruction handlers\r\npub mod admin;\r\npub mod user;\r\npub mod query;\r\n\r\npub use admin::*;\r\npub use user::*;\r\npub use query::*;\r\n\r\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","identity-protocol","src","instructions","query","get_identity.rs"],"content":"use anchor_lang::prelude::*;\r\n\r\nuse crate::contexts::GetIdentity;\r\n\r\n/// Get identity info\r\npub fn handler(ctx: Context\u003cGetIdentity\u003e) -\u003e Result\u003c()\u003e {\r\n    let identity = \u0026ctx.accounts.identity;\r\n    msg!(\"Owner: {}\", identity.owner);\r\n    msg!(\"Verification level: {}\", identity.verification_level);\r\n    msg!(\"Active: {}\", identity.is_active);\r\n    Ok(())\r\n}\r\n\r\n","traces":[{"line":6,"address":[],"length":0,"stats":{"Line":0}},{"line":7,"address":[],"length":0,"stats":{"Line":0}},{"line":8,"address":[],"length":0,"stats":{"Line":0}},{"line":9,"address":[],"length":0,"stats":{"Line":0}},{"line":10,"address":[],"length":0,"stats":{"Line":0}},{"line":11,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":6},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","identity-protocol","src","instructions","query","mod.rs"],"content":"/// Query instructions\r\npub mod get_identity;\r\n\r\npub use get_identity::*;\r\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","identity-protocol","src","instructions","user","create_identity.rs"],"content":"use anchor_lang::prelude::*;\r\n\r\nuse crate::contexts::CreateIdentity;\r\nuse crate::errors::IdentityError;\r\nuse crate::events::IdentityCreated;\r\nuse crate::state::VerificationLevel;\r\n\r\n/// Create a new identity for a user\r\npub fn handler(ctx: Context\u003cCreateIdentity\u003e, did_hash: [u8; 32], username: String) -\u003e Result\u003c()\u003e {\r\n    require!(!ctx.accounts.identity_config.paused, IdentityError::ProtocolPaused);\r\n    require!(username.len() \u003c= 32, IdentityError::InvalidVerificationLevel);\r\n    \r\n    let clock = Clock::get()?;\r\n    let identity = \u0026mut ctx.accounts.identity;\r\n    \r\n    identity.owner = ctx.accounts.owner.key();\r\n    identity.did_hash = did_hash;\r\n    identity.verification_level = VerificationLevel::None as u8;\r\n    identity.verification_hash = [0u8; 32];\r\n    \r\n    // Store username\r\n    let username_bytes = username.as_bytes();\r\n    identity.username[..username_bytes.len()].copy_from_slice(username_bytes);\r\n    identity.username_len = username_bytes.len() as u8;\r\n    \r\n    identity.created_at = clock.unix_timestamp;\r\n    identity.updated_at = clock.unix_timestamp;\r\n    identity.is_active = true;\r\n    identity.bump = ctx.bumps.identity;\r\n    \r\n    // Update global stats\r\n    let config = \u0026mut ctx.accounts.identity_config;\r\n    config.total_identities = config.total_identities.saturating_add(1);\r\n    \r\n    emit!(IdentityCreated {\r\n        owner: identity.owner,\r\n        username,\r\n        timestamp: clock.unix_timestamp,\r\n    });\r\n    \r\n    msg!(\"Identity created for: {}\", identity.owner);\r\n    Ok(())\r\n}\r\n\r\n","traces":[{"line":9,"address":[],"length":0,"stats":{"Line":0}},{"line":10,"address":[],"length":0,"stats":{"Line":0}},{"line":11,"address":[],"length":0,"stats":{"Line":0}},{"line":13,"address":[],"length":0,"stats":{"Line":0}},{"line":14,"address":[],"length":0,"stats":{"Line":0}},{"line":16,"address":[],"length":0,"stats":{"Line":0}},{"line":17,"address":[],"length":0,"stats":{"Line":0}},{"line":18,"address":[],"length":0,"stats":{"Line":0}},{"line":19,"address":[],"length":0,"stats":{"Line":0}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":24},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","identity-protocol","src","instructions","user","link_sas_attestation.rs"],"content":"use anchor_lang::prelude::*;\r\n\r\nuse crate::contexts::LinkSASAttestation;\r\nuse crate::errors::IdentityError;\r\nuse crate::events::SASAttestationLinked;\r\nuse crate::utils::derive_verification_level;\r\n\r\n/// Link SAS attestation to identity\r\npub fn handler(\r\n    ctx: Context\u003cLinkSASAttestation\u003e,\r\n    sas_attestation_id: Pubkey,\r\n    attestation_type: u8,\r\n    verified_claims: u16,\r\n    expires_at: i64,\r\n    portable_score: u16,\r\n) -\u003e Result\u003c()\u003e {\r\n    let config = \u0026ctx.accounts.identity_config;\r\n    \r\n    // Verify attester is trusted\r\n    let attester = ctx.accounts.attester.key();\r\n    let is_trusted = config.trusted_attesters[..config.attester_count as usize]\r\n        .contains(\u0026attester);\r\n    require!(is_trusted, IdentityError::UntrustedAttester);\r\n    \r\n    let clock = Clock::get()?;\r\n    let sas = \u0026mut ctx.accounts.sas_attestation;\r\n    \r\n    sas.user = ctx.accounts.user.key();\r\n    sas.sas_attestation_id = sas_attestation_id;\r\n    sas.attestation_type = attestation_type;\r\n    sas.attester = attester;\r\n    sas.verified_claims = verified_claims;\r\n    \r\n    // Derive verification level from claims\r\n    sas.verification_level = derive_verification_level(verified_claims);\r\n    \r\n    sas.first_verified_at = clock.unix_timestamp;\r\n    sas.last_verified_at = clock.unix_timestamp;\r\n    sas.expires_at = expires_at;\r\n    sas.portable_score = portable_score;\r\n    sas.bump = ctx.bumps.sas_attestation;\r\n    \r\n    // Update identity verification level if higher\r\n    let identity = \u0026mut ctx.accounts.identity;\r\n    if sas.verification_level \u003e identity.verification_level {\r\n        identity.verification_level = sas.verification_level;\r\n        identity.updated_at = clock.unix_timestamp;\r\n    }\r\n    \r\n    emit!(SASAttestationLinked {\r\n        user: sas.user,\r\n        attestation_id: sas_attestation_id,\r\n        attester,\r\n        verification_level: sas.verification_level,\r\n    });\r\n    \r\n    msg!(\"SAS attestation linked for: {}\", sas.user);\r\n    Ok(())\r\n}\r\n\r\n","traces":[{"line":9,"address":[],"length":0,"stats":{"Line":0}},{"line":17,"address":[],"length":0,"stats":{"Line":0}},{"line":20,"address":[],"length":0,"stats":{"Line":0}},{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":30},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","identity-protocol","src","instructions","user","mod.rs"],"content":"/// User instructions\r\npub mod create_identity;\r\npub mod update_did_hash;\r\npub mod link_sas_attestation;\r\npub mod subscribe;\r\n\r\npub use create_identity::*;\r\npub use update_did_hash::*;\r\npub use link_sas_attestation::*;\r\npub use subscribe::*;\r\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","identity-protocol","src","instructions","user","subscribe.rs"],"content":"use anchor_lang::prelude::*;\r\n\r\nuse crate::constants::SUBSCRIPTION_DURATION;\r\nuse crate::contexts::Subscribe;\r\nuse crate::errors::IdentityError;\r\nuse crate::events::SubscriptionUpdated;\r\nuse crate::state::SubscriptionTier;\r\n\r\n/// Subscribe to a tier\r\npub fn handler(ctx: Context\u003cSubscribe\u003e, tier: u8) -\u003e Result\u003c()\u003e {\r\n    let tier_enum = SubscriptionTier::from_u8(tier)\r\n        .ok_or(IdentityError::InvalidSubscriptionTier)?;\r\n    \r\n    let clock = Clock::get()?;\r\n    let subscription = \u0026mut ctx.accounts.subscription;\r\n    \r\n    subscription.user = ctx.accounts.user.key();\r\n    subscription.tier = tier;\r\n    subscription.started_at = clock.unix_timestamp;\r\n    subscription.expires_at = clock.unix_timestamp + SUBSCRIPTION_DURATION;\r\n    subscription.auto_renew = false;\r\n    subscription.total_paid = subscription.total_paid.saturating_add(tier_enum.price());\r\n    subscription.bump = ctx.bumps.subscription;\r\n    \r\n    emit!(SubscriptionUpdated {\r\n        user: subscription.user,\r\n        tier,\r\n        expires_at: subscription.expires_at,\r\n    });\r\n    \r\n    msg!(\"Subscription activated: tier {}\", tier);\r\n    Ok(())\r\n}\r\n\r\n","traces":[{"line":10,"address":[],"length":0,"stats":{"Line":0}},{"line":11,"address":[],"length":0,"stats":{"Line":0}},{"line":12,"address":[],"length":0,"stats":{"Line":0}},{"line":14,"address":[],"length":0,"stats":{"Line":0}},{"line":15,"address":[],"length":0,"stats":{"Line":0}},{"line":17,"address":[],"length":0,"stats":{"Line":0}},{"line":18,"address":[],"length":0,"stats":{"Line":0}},{"line":19,"address":[],"length":0,"stats":{"Line":0}},{"line":20,"address":[],"length":0,"stats":{"Line":0}},{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":18},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","identity-protocol","src","instructions","user","update_did_hash.rs"],"content":"use anchor_lang::prelude::*;\r\n\r\nuse crate::contexts::UpdateIdentity;\r\n\r\n/// Update DID document hash\r\npub fn handler(ctx: Context\u003cUpdateIdentity\u003e, new_did_hash: [u8; 32]) -\u003e Result\u003c()\u003e {\r\n    let clock = Clock::get()?;\r\n    let identity = \u0026mut ctx.accounts.identity;\r\n    \r\n    identity.did_hash = new_did_hash;\r\n    identity.updated_at = clock.unix_timestamp;\r\n    \r\n    msg!(\"DID hash updated for: {}\", identity.owner);\r\n    Ok(())\r\n}\r\n\r\n","traces":[{"line":6,"address":[],"length":0,"stats":{"Line":0}},{"line":7,"address":[],"length":0,"stats":{"Line":0}},{"line":8,"address":[],"length":0,"stats":{"Line":0}},{"line":10,"address":[],"length":0,"stats":{"Line":0}},{"line":11,"address":[],"length":0,"stats":{"Line":0}},{"line":13,"address":[],"length":0,"stats":{"Line":0}},{"line":14,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":7},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","identity-protocol","src","lib.rs"],"content":"use anchor_lang::prelude::*;\r\n\r\npub mod constants;\r\npub mod contexts;\r\npub mod errors;\r\npub mod events;\r\npub mod instructions;\r\npub mod state;\r\npub mod utils;\r\n\r\n#[cfg(test)]\r\nmod tests;\r\n\r\nuse contexts::*;\r\n\r\ndeclare_id!(\"3egAds3pFR5oog6iQCN42KPvgih8HQz2FGybNjiVWixG\");\r\n\r\n/// ViWoApp Identity Protocol\r\n/// \r\n/// Minimal on-chain DID anchor with Solana Attestation Service (SAS) integration.\r\n/// Provides portable identity verification across all Solana dApps.\r\n/// \r\n/// Verification Levels:\r\n/// - Level 0 (None): Wallet connected only\r\n/// - Level 1 (Basic): Email + phone verified  \r\n/// - Level 2 (KYC): Identity documents verified\r\n/// - Level 3 (Full): KYC + biometric verification\r\n/// - Level 4 (Enhanced): Full + UniqueHuman attestation\r\n\r\n#[program]\r\npub mod identity_protocol {\r\n    use super::*;\r\n\r\n    /// Initialize the identity protocol\r\n    pub fn initialize(ctx: Context\u003cInitialize\u003e, sas_program: Pubkey, usdc_mint: Pubkey) -\u003e Result\u003c()\u003e {\r\n        instructions::admin::initialize::handler(ctx, sas_program, usdc_mint)\r\n    }\r\n    \r\n    /// Create a new identity for a user\r\n    pub fn create_identity(ctx: Context\u003cCreateIdentity\u003e, did_hash: [u8; 32], username: String) -\u003e Result\u003c()\u003e {\r\n        instructions::user::create_identity::handler(ctx, did_hash, username)\r\n    }\r\n    \r\n    /// Update DID document hash\r\n    pub fn update_did_hash(ctx: Context\u003cUpdateIdentity\u003e, new_did_hash: [u8; 32]) -\u003e Result\u003c()\u003e {\r\n        instructions::user::update_did_hash::handler(ctx, new_did_hash)\r\n    }\r\n    \r\n    /// Update verification level (admin only)\r\n    pub fn update_verification(ctx: Context\u003cAdminUpdateIdentity\u003e, new_level: u8, verification_hash: [u8; 32]) -\u003e Result\u003c()\u003e {\r\n        instructions::admin::update_verification::handler(ctx, new_level, verification_hash)\r\n    }\r\n    \r\n    /// Link SAS attestation to identity\r\n    pub fn link_sas_attestation(\r\n        ctx: Context\u003cLinkSASAttestation\u003e,\r\n        sas_attestation_id: Pubkey,\r\n        attestation_type: u8,\r\n        verified_claims: u16,\r\n        expires_at: i64,\r\n        portable_score: u16,\r\n    ) -\u003e Result\u003c()\u003e {\r\n        instructions::user::link_sas_attestation::handler(ctx, sas_attestation_id, attestation_type, verified_claims, expires_at, portable_score)\r\n    }\r\n    \r\n    /// Subscribe to a tier\r\n    pub fn subscribe(ctx: Context\u003cSubscribe\u003e, tier: u8) -\u003e Result\u003c()\u003e {\r\n        instructions::user::subscribe::handler(ctx, tier)\r\n    }\r\n    \r\n    /// Add trusted attester (admin only)\r\n    pub fn add_trusted_attester(ctx: Context\u003cUpdateConfig\u003e, attester: Pubkey) -\u003e Result\u003c()\u003e {\r\n        instructions::admin::add_trusted_attester::handler(ctx, attester)\r\n    }\r\n    \r\n    /// Remove trusted attester (admin only)\r\n    pub fn remove_trusted_attester(ctx: Context\u003cUpdateConfig\u003e, attester: Pubkey) -\u003e Result\u003c()\u003e {\r\n        instructions::admin::remove_trusted_attester::handler(ctx, attester)\r\n    }\r\n    \r\n    /// Pause/unpause protocol\r\n    pub fn set_paused(ctx: Context\u003cUpdateConfig\u003e, paused: bool) -\u003e Result\u003c()\u003e {\r\n        instructions::admin::set_paused::handler(ctx, paused)\r\n    }\r\n    \r\n    /// Update authority\r\n    pub fn update_authority(ctx: Context\u003cUpdateAuthority\u003e, new_authority: Pubkey) -\u003e Result\u003c()\u003e {\r\n        instructions::admin::update_authority::handler(ctx, new_authority)\r\n    }\r\n    \r\n    /// Get identity info\r\n    pub fn get_identity(ctx: Context\u003cGetIdentity\u003e) -\u003e Result\u003c()\u003e {\r\n        instructions::query::get_identity::handler(ctx)\r\n    }\r\n}\r\n","traces":[{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":22},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","identity-protocol","src","state","config.rs"],"content":"use anchor_lang::prelude::*;\r\n\r\n/// Global identity protocol configuration\r\n#[account]\r\n#[derive(Default)]\r\npub struct IdentityConfig {\r\n    /// Admin authority\r\n    pub authority: Pubkey,\r\n    /// SAS program ID (Solana Attestation Service)\r\n    pub sas_program: Pubkey,\r\n    /// USDC mint for subscriptions\r\n    pub usdc_mint: Pubkey,\r\n    /// Treasury for subscription payments\r\n    pub treasury: Pubkey,\r\n    /// Trusted attesters (max 10)\r\n    pub trusted_attesters: [Pubkey; 10],\r\n    /// Number of active trusted attesters\r\n    pub attester_count: u8,\r\n    /// Total registered identities\r\n    pub total_identities: u64,\r\n    /// Total verified identities (Level 1+)\r\n    pub verified_identities: u64,\r\n    /// Whether protocol is paused\r\n    pub paused: bool,\r\n    /// PDA bump\r\n    pub bump: u8,\r\n}\r\n\r\nimpl IdentityConfig {\r\n    pub const LEN: usize = 8 + // discriminator\r\n        32 + // authority\r\n        32 + // sas_program\r\n        32 + // usdc_mint\r\n        32 + // treasury\r\n        (32 * 10) + // trusted_attesters\r\n        1 +  // attester_count\r\n        8 +  // total_identities\r\n        8 +  // verified_identities\r\n        1 +  // paused\r\n        1;   // bump\r\n}\r\n\r\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","identity-protocol","src","state","identity.rs"],"content":"use anchor_lang::prelude::*;\r\n\r\n/// Individual user identity (on-chain DID anchor)\r\n#[account]\r\n#[derive(Default)]\r\npub struct Identity {\r\n    /// Owner wallet\r\n    pub owner: Pubkey,\r\n    /// SHA256 hash of full DID document (stored off-chain)\r\n    pub did_hash: [u8; 32],\r\n    /// Current verification level\r\n    pub verification_level: u8,\r\n    /// Hash of verification proof\r\n    pub verification_hash: [u8; 32],\r\n    /// Username (max 32 chars)\r\n    pub username: [u8; 32],\r\n    /// Username length\r\n    pub username_len: u8,\r\n    /// Account creation timestamp\r\n    pub created_at: i64,\r\n    /// Last update timestamp\r\n    pub updated_at: i64,\r\n    /// Whether identity is active\r\n    pub is_active: bool,\r\n    /// PDA bump\r\n    pub bump: u8,\r\n}\r\n\r\nimpl Identity {\r\n    pub const LEN: usize = 8 + // discriminator\r\n        32 + // owner\r\n        32 + // did_hash\r\n        1 +  // verification_level\r\n        32 + // verification_hash\r\n        32 + // username\r\n        1 +  // username_len\r\n        8 +  // created_at\r\n        8 +  // updated_at\r\n        1 +  // is_active\r\n        1;   // bump\r\n}\r\n\r\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","identity-protocol","src","state","mod.rs"],"content":"/// State module - Account structures\r\nmod config;\r\nmod identity;\r\nmod sas_attestation;\r\nmod subscription;\r\nmod verification_level;\r\nmod subscription_tier;\r\n\r\npub use config::*;\r\npub use identity::*;\r\npub use sas_attestation::*;\r\npub use subscription::*;\r\npub use verification_level::*;\r\npub use subscription_tier::*;\r\n\r\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","identity-protocol","src","state","sas_attestation.rs"],"content":"use anchor_lang::prelude::*;\r\n\r\n/// User's SAS attestation link\r\n#[account]\r\n#[derive(Default)]\r\npub struct UserSASAttestation {\r\n    /// User wallet\r\n    pub user: Pubkey,\r\n    /// SAS attestation account PDA\r\n    pub sas_attestation_id: Pubkey,\r\n    /// Attestation type (0=Email, 1=Phone, 2=KYC, 3=Biometric, 4=UniqueHuman)\r\n    pub attestation_type: u8,\r\n    /// Who issued the attestation\r\n    pub attester: Pubkey,\r\n    /// Bitmap of verified claims\r\n    pub verified_claims: u16,\r\n    /// Derived verification level from claims\r\n    pub verification_level: u8,\r\n    /// First verification timestamp\r\n    pub first_verified_at: i64,\r\n    /// Last verification timestamp\r\n    pub last_verified_at: i64,\r\n    /// Attestation expiry\r\n    pub expires_at: i64,\r\n    /// Portable score from other dApps (0-10000)\r\n    pub portable_score: u16,\r\n    /// PDA bump\r\n    pub bump: u8,\r\n}\r\n\r\nimpl UserSASAttestation {\r\n    pub const LEN: usize = 8 + // discriminator\r\n        32 + // user\r\n        32 + // sas_attestation_id\r\n        1 +  // attestation_type\r\n        32 + // attester\r\n        2 +  // verified_claims\r\n        1 +  // verification_level\r\n        8 +  // first_verified_at\r\n        8 +  // last_verified_at\r\n        8 +  // expires_at\r\n        2 +  // portable_score\r\n        1;   // bump\r\n}\r\n\r\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","identity-protocol","src","state","subscription.rs"],"content":"use anchor_lang::prelude::*;\r\n\r\n/// User subscription account\r\n#[account]\r\n#[derive(Default)]\r\npub struct Subscription {\r\n    /// User wallet\r\n    pub user: Pubkey,\r\n    /// Current subscription tier\r\n    pub tier: u8,\r\n    /// Subscription start timestamp\r\n    pub started_at: i64,\r\n    /// Subscription expiry timestamp\r\n    pub expires_at: i64,\r\n    /// Auto-renew enabled\r\n    pub auto_renew: bool,\r\n    /// Total payments made (USDC)\r\n    pub total_paid: u64,\r\n    /// PDA bump\r\n    pub bump: u8,\r\n}\r\n\r\nimpl Subscription {\r\n    pub const LEN: usize = 8 + // discriminator\r\n        32 + // user\r\n        1 +  // tier\r\n        8 +  // started_at\r\n        8 +  // expires_at\r\n        1 +  // auto_renew\r\n        8 +  // total_paid\r\n        1;   // bump\r\n}\r\n\r\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","identity-protocol","src","state","subscription_tier.rs"],"content":"use anchor_lang::prelude::*;\r\n\r\nuse crate::constants::*;\r\n\r\n/// Subscription tiers\r\n#[derive(AnchorSerialize, AnchorDeserialize, Clone, Copy, PartialEq, Eq, Default, Debug)]\r\npub enum SubscriptionTier {\r\n    #[default]\r\n    Free = 0,\r\n    Verified = 1,   // $4/month\r\n    Premium = 2,    // $12/month\r\n    Enterprise = 3, // $59/month\r\n}\r\n\r\nimpl SubscriptionTier {\r\n    pub fn from_u8(value: u8) -\u003e Option\u003cSelf\u003e {\r\n        match value {\r\n            0 =\u003e Some(SubscriptionTier::Free),\r\n            1 =\u003e Some(SubscriptionTier::Verified),\r\n            2 =\u003e Some(SubscriptionTier::Premium),\r\n            3 =\u003e Some(SubscriptionTier::Enterprise),\r\n            _ =\u003e None,\r\n        }\r\n    }\r\n    \r\n    pub fn price(\u0026self) -\u003e u64 {\r\n        match self {\r\n            SubscriptionTier::Free =\u003e SUBSCRIPTION_FREE,\r\n            SubscriptionTier::Verified =\u003e SUBSCRIPTION_VERIFIED,\r\n            SubscriptionTier::Premium =\u003e SUBSCRIPTION_PREMIUM,\r\n            SubscriptionTier::Enterprise =\u003e SUBSCRIPTION_ENTERPRISE,\r\n        }\r\n    }\r\n}\r\n\r\n","traces":[{"line":16,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":17,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":18,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":19,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":20,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":21,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":22,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":26,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":27,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":28,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":29,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":30,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":31,"address":[],"length":0,"stats":{"Line":72057594037927936}}],"covered":13,"coverable":13},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","identity-protocol","src","state","verification_level.rs"],"content":"use anchor_lang::prelude::*;\r\n\r\n/// Verification levels\r\n#[derive(AnchorSerialize, AnchorDeserialize, Clone, Copy, PartialEq, Eq, Default, Debug)]\r\npub enum VerificationLevel {\r\n    #[default]\r\n    None = 0,\r\n    Basic = 1,      // Email + phone\r\n    KYC = 2,        // Identity documents\r\n    Full = 3,       // KYC + biometric\r\n    Enhanced = 4,   // Full + UniqueHuman\r\n}\r\n\r\nimpl VerificationLevel {\r\n    pub fn from_u8(value: u8) -\u003e Option\u003cSelf\u003e {\r\n        match value {\r\n            0 =\u003e Some(VerificationLevel::None),\r\n            1 =\u003e Some(VerificationLevel::Basic),\r\n            2 =\u003e Some(VerificationLevel::KYC),\r\n            3 =\u003e Some(VerificationLevel::Full),\r\n            4 =\u003e Some(VerificationLevel::Enhanced),\r\n            _ =\u003e None,\r\n        }\r\n    }\r\n}\r\n\r\n","traces":[{"line":15,"address":[],"length":0,"stats":{"Line":792633534417207296}},{"line":16,"address":[],"length":0,"stats":{"Line":792633534417207296}},{"line":17,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":18,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":19,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":20,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":21,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":22,"address":[],"length":0,"stats":{"Line":72057594037927936}}],"covered":8,"coverable":8},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","identity-protocol","src","tests.rs"],"content":"//! Unit tests for Identity Protocol\r\n//!\r\n//! These tests run against the ACTUAL program code.\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n    use crate::constants::*;\r\n    use crate::state::{IdentityConfig, Identity, VerificationLevel, SubscriptionTier};\r\n    use anchor_lang::prelude::Pubkey;\r\n\r\n    // ========================================================================\r\n    // Constants Tests\r\n    // ========================================================================\r\n\r\n    #[test]\r\n    fn test_pda_seeds() {\r\n        assert_eq!(IDENTITY_CONFIG_SEED, b\"identity-config\");\r\n        assert_eq!(IDENTITY_SEED, b\"identity\");\r\n        assert_eq!(SAS_ATTESTATION_SEED, b\"sas-attestation\");\r\n        assert_eq!(SUBSCRIPTION_SEED, b\"subscription\");\r\n    }\r\n\r\n    #[test]\r\n    fn test_subscription_prices() {\r\n        assert_eq!(SUBSCRIPTION_FREE, 0, \"Free tier = $0\");\r\n        assert_eq!(SUBSCRIPTION_VERIFIED, 4_000_000, \"Verified = $4 USDC\");\r\n        assert_eq!(SUBSCRIPTION_PREMIUM, 12_000_000, \"Premium = $12 USDC\");\r\n        assert_eq!(SUBSCRIPTION_ENTERPRISE, 59_000_000, \"Enterprise = $59 USDC\");\r\n    }\r\n\r\n    #[test]\r\n    fn test_subscription_duration() {\r\n        assert_eq!(SUBSCRIPTION_DURATION, 30 * 24 * 60 * 60, \"30 days\");\r\n    }\r\n\r\n    // ========================================================================\r\n    // State Size Tests\r\n    // ========================================================================\r\n\r\n    #[test]\r\n    fn test_identity_config_size() {\r\n        let expected = 8 + 32 + 32 + 32 + 32 + (32 * 10) + 1 + 8 + 8 + 1 + 1;\r\n        assert_eq!(IdentityConfig::LEN, expected, \"Config size mismatch\");\r\n    }\r\n\r\n    #[test]\r\n    fn test_identity_size() {\r\n        let expected = 8 + 32 + 32 + 1 + 32 + 32 + 1 + 8 + 8 + 1 + 1;\r\n        assert_eq!(Identity::LEN, expected, \"Identity size mismatch\");\r\n    }\r\n\r\n    // ========================================================================\r\n    // Verification Level Tests\r\n    // ========================================================================\r\n\r\n    #[test]\r\n    fn test_verification_level_from_u8() {\r\n        assert_eq!(VerificationLevel::from_u8(0), Some(VerificationLevel::None));\r\n        assert_eq!(VerificationLevel::from_u8(1), Some(VerificationLevel::Basic));\r\n        assert_eq!(VerificationLevel::from_u8(2), Some(VerificationLevel::KYC));\r\n        assert_eq!(VerificationLevel::from_u8(3), Some(VerificationLevel::Full));\r\n        assert_eq!(VerificationLevel::from_u8(4), Some(VerificationLevel::Enhanced));\r\n        assert_eq!(VerificationLevel::from_u8(5), None);\r\n    }\r\n\r\n    #[test]\r\n    fn test_verification_level_default() {\r\n        let level = VerificationLevel::default();\r\n        assert_eq!(level, VerificationLevel::None);\r\n    }\r\n\r\n    #[test]\r\n    fn test_verification_level_ordering() {\r\n        // Higher levels should be \"more verified\"\r\n        let levels = [\r\n            VerificationLevel::None,\r\n            VerificationLevel::Basic,\r\n            VerificationLevel::KYC,\r\n            VerificationLevel::Full,\r\n            VerificationLevel::Enhanced,\r\n        ];\r\n        \r\n        for i in 0..levels.len() {\r\n            assert_eq!(VerificationLevel::from_u8(i as u8), Some(levels[i]));\r\n        }\r\n    }\r\n\r\n    // ========================================================================\r\n    // Subscription Tier Tests\r\n    // ========================================================================\r\n\r\n    #[test]\r\n    fn test_subscription_tier_from_u8() {\r\n        assert_eq!(SubscriptionTier::from_u8(0), Some(SubscriptionTier::Free));\r\n        assert_eq!(SubscriptionTier::from_u8(1), Some(SubscriptionTier::Verified));\r\n        assert_eq!(SubscriptionTier::from_u8(2), Some(SubscriptionTier::Premium));\r\n        assert_eq!(SubscriptionTier::from_u8(3), Some(SubscriptionTier::Enterprise));\r\n        assert_eq!(SubscriptionTier::from_u8(4), None);\r\n    }\r\n\r\n    #[test]\r\n    fn test_subscription_tier_prices() {\r\n        assert_eq!(SubscriptionTier::Free.price(), SUBSCRIPTION_FREE);\r\n        assert_eq!(SubscriptionTier::Verified.price(), SUBSCRIPTION_VERIFIED);\r\n        assert_eq!(SubscriptionTier::Premium.price(), SUBSCRIPTION_PREMIUM);\r\n        assert_eq!(SubscriptionTier::Enterprise.price(), SUBSCRIPTION_ENTERPRISE);\r\n    }\r\n\r\n    #[test]\r\n    fn test_subscription_tier_default() {\r\n        let tier = SubscriptionTier::default();\r\n        assert_eq!(tier, SubscriptionTier::Free);\r\n    }\r\n\r\n    // ========================================================================\r\n    // Identity State Tests\r\n    // ========================================================================\r\n\r\n    #[test]\r\n    fn test_identity_default() {\r\n        let identity = Identity::default();\r\n        \r\n        assert_eq!(identity.verification_level, 0);\r\n        assert!(!identity.is_active);\r\n        assert_eq!(identity.created_at, 0);\r\n        assert_eq!(identity.updated_at, 0);\r\n    }\r\n\r\n    #[test]\r\n    fn test_identity_username_capacity() {\r\n        let identity = Identity::default();\r\n        \r\n        // Username is stored as [u8; 32]\r\n        assert_eq!(identity.username.len(), 32);\r\n    }\r\n\r\n    // ========================================================================\r\n    // Config Tests\r\n    // ========================================================================\r\n\r\n    #[test]\r\n    fn test_config_default() {\r\n        let config = IdentityConfig::default();\r\n        \r\n        assert_eq!(config.attester_count, 0);\r\n        assert_eq!(config.total_identities, 0);\r\n        assert_eq!(config.verified_identities, 0);\r\n        assert!(!config.paused);\r\n    }\r\n\r\n    #[test]\r\n    fn test_trusted_attester_capacity() {\r\n        let config = IdentityConfig::default();\r\n        \r\n        // Max 10 trusted attesters\r\n        assert_eq!(config.trusted_attesters.len(), 10);\r\n    }\r\n\r\n    // ========================================================================\r\n    // PDA Derivation Tests\r\n    // ========================================================================\r\n\r\n    #[test]\r\n    fn test_identity_pda_unique_per_user() {\r\n        let program_id = Pubkey::new_unique();\r\n        let user1 = Pubkey::new_unique();\r\n        let user2 = Pubkey::new_unique();\r\n        \r\n        let (pda1, _) = Pubkey::find_program_address(\r\n            \u0026[IDENTITY_SEED, user1.as_ref()],\r\n            \u0026program_id\r\n        );\r\n        \r\n        let (pda2, _) = Pubkey::find_program_address(\r\n            \u0026[IDENTITY_SEED, user2.as_ref()],\r\n            \u0026program_id\r\n        );\r\n        \r\n        assert_ne!(pda1, pda2, \"Different users should have different identity PDAs\");\r\n    }\r\n\r\n    #[test]\r\n    fn test_config_pda() {\r\n        let program_id = Pubkey::new_unique();\r\n        \r\n        let (pda, bump) = Pubkey::find_program_address(\r\n            \u0026[IDENTITY_CONFIG_SEED],\r\n            \u0026program_id\r\n        );\r\n        \r\n        assert!(bump \u003c= 255);\r\n        assert_ne!(pda, Pubkey::default());\r\n    }\r\n\r\n    // ========================================================================\r\n    // Subscription Expiry Tests\r\n    // ========================================================================\r\n\r\n    #[test]\r\n    fn test_subscription_expiry_calculation() {\r\n        let start_time = 1000i64;\r\n        let expires_at = start_time + SUBSCRIPTION_DURATION;\r\n        \r\n        assert_eq!(expires_at, start_time + 30 * 24 * 60 * 60);\r\n    }\r\n\r\n    #[test]\r\n    fn test_subscription_active() {\r\n        let expires_at = 2_000_000i64;\r\n        let current_time = 1_000_000i64;\r\n        \r\n        assert!(current_time \u003c expires_at, \"Subscription should be active\");\r\n    }\r\n\r\n    #[test]\r\n    fn test_subscription_expired() {\r\n        let expires_at = 1_000_000i64;\r\n        let current_time = 2_000_000i64;\r\n        \r\n        assert!(current_time \u003e= expires_at, \"Subscription should be expired\");\r\n    }\r\n\r\n    // ========================================================================\r\n    // Invariant Tests\r\n    // ========================================================================\r\n\r\n    #[test]\r\n    fn test_invariant_verified_lte_total() {\r\n        let config = IdentityConfig {\r\n            total_identities: 100,\r\n            verified_identities: 50,\r\n            ..Default::default()\r\n        };\r\n        \r\n        assert!(config.verified_identities \u003c= config.total_identities);\r\n    }\r\n\r\n    #[test]\r\n    fn test_invariant_attester_count_bounded() {\r\n        let config = IdentityConfig {\r\n            attester_count: 10,\r\n            ..Default::default()\r\n        };\r\n        \r\n        assert!(config.attester_count as usize \u003c= config.trusted_attesters.len());\r\n    }\r\n}\r\n\r\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","identity-protocol","src","utils.rs"],"content":"use crate::state::VerificationLevel;\r\n\r\n/// Derive verification level from claims bitmap\r\npub fn derive_verification_level(claims: u16) -\u003e u8 {\r\n    // Claims bitmap:\r\n    // bit 0: Email verified\r\n    // bit 1: Phone verified\r\n    // bit 2: Social verified\r\n    // bit 3: KYC verified\r\n    // bit 4: Biometric verified\r\n    // bit 5: UniqueHuman verified\r\n    \r\n    let has_email = claims \u0026 0x01 != 0;\r\n    let has_phone = claims \u0026 0x02 != 0;\r\n    let has_social = claims \u0026 0x04 != 0;\r\n    let has_kyc = claims \u0026 0x08 != 0;\r\n    let has_biometric = claims \u0026 0x10 != 0;\r\n    let has_unique_human = claims \u0026 0x20 != 0;\r\n    \r\n    if has_kyc \u0026\u0026 has_biometric \u0026\u0026 has_unique_human {\r\n        VerificationLevel::Enhanced as u8\r\n    } else if has_kyc \u0026\u0026 has_biometric {\r\n        VerificationLevel::Full as u8\r\n    } else if has_kyc || (has_email \u0026\u0026 has_phone \u0026\u0026 has_social) {\r\n        VerificationLevel::KYC as u8\r\n    } else if has_email \u0026\u0026 has_phone {\r\n        VerificationLevel::Basic as u8\r\n    } else {\r\n        VerificationLevel::None as u8\r\n    }\r\n}\r\n\r\n","traces":[{"line":4,"address":[],"length":0,"stats":{"Line":0}},{"line":13,"address":[],"length":0,"stats":{"Line":0}},{"line":14,"address":[],"length":0,"stats":{"Line":0}},{"line":15,"address":[],"length":0,"stats":{"Line":0}},{"line":16,"address":[],"length":0,"stats":{"Line":0}},{"line":17,"address":[],"length":0,"stats":{"Line":0}},{"line":18,"address":[],"length":0,"stats":{"Line":0}},{"line":20,"address":[],"length":0,"stats":{"Line":0}},{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":16},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","identity-protocol","tests","admin.rs"],"content":"//! Integration tests for identity-protocol admin instructions\r\n\r\nmod common;\r\n\r\nuse common::*;\r\nuse solana_sdk::signature::{Keypair, Signer};\r\n\r\n#[tokio::test]\r\nasync fn test_set_paused_true() {\r\n    let mut ctx = TestContext::new().await;\r\n    \r\n    let (config_pda, _bump) = ctx.get_config_pda();\r\n    let sas_program = Keypair::new();\r\n    let usdc_mint = Keypair::new();\r\n    \r\n    let init_ix = create_initialize_ix(\r\n        \u0026ctx.program_id,\r\n        \u0026ctx.payer.pubkey(),\r\n        \u0026config_pda,\r\n        \u0026sas_program.pubkey(),\r\n        \u0026usdc_mint.pubkey(),\r\n    );\r\n    \r\n    ctx.process_transaction(\u0026[init_ix], \u0026[]).await.unwrap();\r\n    \r\n    let pause_ix = create_set_paused_ix(\r\n        \u0026ctx.program_id,\r\n        \u0026ctx.payer.pubkey(),\r\n        \u0026config_pda,\r\n        true,\r\n    );\r\n    \r\n    let result = ctx.process_transaction(\u0026[pause_ix], \u0026[]).await;\r\n    assert!(result.is_ok());\r\n}\r\n\r\n#[tokio::test]\r\nasync fn test_set_paused_false() {\r\n    let mut ctx = TestContext::new().await;\r\n    \r\n    let (config_pda, _bump) = ctx.get_config_pda();\r\n    let sas_program = Keypair::new();\r\n    let usdc_mint = Keypair::new();\r\n    \r\n    let init_ix = create_initialize_ix(\r\n        \u0026ctx.program_id,\r\n        \u0026ctx.payer.pubkey(),\r\n        \u0026config_pda,\r\n        \u0026sas_program.pubkey(),\r\n        \u0026usdc_mint.pubkey(),\r\n    );\r\n    \r\n    ctx.process_transaction(\u0026[init_ix], \u0026[]).await.unwrap();\r\n    \r\n    let pause_ix = create_set_paused_ix(\u0026ctx.program_id, \u0026ctx.payer.pubkey(), \u0026config_pda, true);\r\n    ctx.process_transaction(\u0026[pause_ix], \u0026[]).await.unwrap();\r\n    \r\n    let unpause_ix = create_set_paused_ix(\u0026ctx.program_id, \u0026ctx.payer.pubkey(), \u0026config_pda, false);\r\n    let result = ctx.process_transaction(\u0026[unpause_ix], \u0026[]).await;\r\n    assert!(result.is_ok());\r\n}\r\n\r\n#[tokio::test]\r\nasync fn test_set_paused_unauthorized() {\r\n    let mut ctx = TestContext::new().await;\r\n    \r\n    let (config_pda, _bump) = ctx.get_config_pda();\r\n    let sas_program = Keypair::new();\r\n    let usdc_mint = Keypair::new();\r\n    \r\n    let init_ix = create_initialize_ix(\r\n        \u0026ctx.program_id,\r\n        \u0026ctx.payer.pubkey(),\r\n        \u0026config_pda,\r\n        \u0026sas_program.pubkey(),\r\n        \u0026usdc_mint.pubkey(),\r\n    );\r\n    \r\n    ctx.process_transaction(\u0026[init_ix], \u0026[]).await.unwrap();\r\n    \r\n    let unauthorized = Keypair::new();\r\n    let pause_ix = create_set_paused_ix(\r\n        \u0026ctx.program_id,\r\n        \u0026unauthorized.pubkey(),\r\n        \u0026config_pda,\r\n        true,\r\n    );\r\n    \r\n    assert_eq!(pause_ix.accounts[0].pubkey, unauthorized.pubkey());\r\n}\r\n\r\n#[tokio::test]\r\nasync fn test_set_paused_toggle() {\r\n    let mut ctx = TestContext::new().await;\r\n    \r\n    let (config_pda, _bump) = ctx.get_config_pda();\r\n    let sas_program = Keypair::new();\r\n    let usdc_mint = Keypair::new();\r\n    \r\n    let init_ix = create_initialize_ix(\r\n        \u0026ctx.program_id,\r\n        \u0026ctx.payer.pubkey(),\r\n        \u0026config_pda,\r\n        \u0026sas_program.pubkey(),\r\n        \u0026usdc_mint.pubkey(),\r\n    );\r\n    \r\n    ctx.process_transaction(\u0026[init_ix], \u0026[]).await.unwrap();\r\n    \r\n    for paused in [true, false, true, false] {\r\n        let ix = create_set_paused_ix(\u0026ctx.program_id, \u0026ctx.payer.pubkey(), \u0026config_pda, paused);\r\n        let result = ctx.process_transaction(\u0026[ix], \u0026[]).await;\r\n        assert!(result.is_ok());\r\n    }\r\n}\r\n\r\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","identity-protocol","tests","common","mod.rs"],"content":"//! Common test utilities for identity-protocol integration tests\r\n\r\nuse anchor_lang::prelude::*;\r\nuse solana_program_test::*;\r\nuse solana_sdk::{\r\n    account::Account,\r\n    hash::Hash,\r\n    instruction::{AccountMeta, Instruction},\r\n    pubkey::Pubkey,\r\n    signature::{Keypair, Signer},\r\n    transaction::Transaction,\r\n};\r\n\r\npub const IDENTITY_CONFIG_SEED: \u0026[u8] = b\"identity-config\";\r\npub const IDENTITY_SEED: \u0026[u8] = b\"identity\";\r\n\r\npub struct TestContext {\r\n    pub banks_client: BanksClient,\r\n    pub payer: Keypair,\r\n    pub recent_blockhash: Hash,\r\n    pub program_id: Pubkey,\r\n}\r\n\r\nimpl TestContext {\r\n    pub async fn new() -\u003e Self {\r\n        let program_id = identity_protocol::id();\r\n        let program_test = ProgramTest::new(\r\n            \"identity_protocol\",\r\n            program_id,\r\n            processor!(identity_protocol::entry),\r\n        );\r\n\r\n        let (banks_client, payer, recent_blockhash) = program_test.start().await;\r\n\r\n        Self {\r\n            banks_client,\r\n            payer,\r\n            recent_blockhash,\r\n            program_id,\r\n        }\r\n    }\r\n\r\n    pub async fn refresh_blockhash(\u0026mut self) {\r\n        self.recent_blockhash = self.banks_client.get_latest_blockhash().await.unwrap();\r\n    }\r\n\r\n    pub async fn get_account(\u0026mut self, pubkey: Pubkey) -\u003e Option\u003cAccount\u003e {\r\n        self.banks_client.get_account(pubkey).await.unwrap()\r\n    }\r\n\r\n    pub fn get_config_pda(\u0026self) -\u003e (Pubkey, u8) {\r\n        Pubkey::find_program_address(\u0026[IDENTITY_CONFIG_SEED], \u0026self.program_id)\r\n    }\r\n\r\n    pub fn get_identity_pda(\u0026self, user: \u0026Pubkey) -\u003e (Pubkey, u8) {\r\n        Pubkey::find_program_address(\u0026[IDENTITY_SEED, user.as_ref()], \u0026self.program_id)\r\n    }\r\n\r\n    pub async fn process_transaction(\r\n        \u0026mut self,\r\n        instructions: \u0026[Instruction],\r\n        signers: \u0026[\u0026Keypair],\r\n    ) -\u003e Result\u003c(), BanksClientError\u003e {\r\n        let mut all_signers = vec![\u0026self.payer];\r\n        all_signers.extend(signers);\r\n        \r\n        let tx = Transaction::new_signed_with_payer(\r\n            instructions,\r\n            Some(\u0026self.payer.pubkey()),\r\n            \u0026all_signers,\r\n            self.recent_blockhash,\r\n        );\r\n        \r\n        let result = self.banks_client.process_transaction(tx).await;\r\n        self.refresh_blockhash().await;\r\n        result\r\n    }\r\n}\r\n\r\npub fn create_initialize_ix(\r\n    program_id: \u0026Pubkey,\r\n    authority: \u0026Pubkey,\r\n    config: \u0026Pubkey,\r\n    sas_program: \u0026Pubkey,\r\n    usdc_mint: \u0026Pubkey,\r\n) -\u003e Instruction {\r\n    let mut data = vec![0u8; 8 + 32 + 32];\r\n    let discriminator = anchor_lang::solana_program::hash::hash(b\"global:initialize\").to_bytes();\r\n    data[..8].copy_from_slice(\u0026discriminator[..8]);\r\n    data[8..40].copy_from_slice(sas_program.as_ref());\r\n    data[40..72].copy_from_slice(usdc_mint.as_ref());\r\n\r\n    Instruction {\r\n        program_id: *program_id,\r\n        accounts: vec![\r\n            AccountMeta::new(*authority, true),\r\n            AccountMeta::new(*config, false),\r\n            AccountMeta::new_readonly(solana_sdk::system_program::id(), false),\r\n        ],\r\n        data,\r\n    }\r\n}\r\n\r\npub fn create_identity_ix(\r\n    program_id: \u0026Pubkey,\r\n    user: \u0026Pubkey,\r\n    identity: \u0026Pubkey,\r\n    config: \u0026Pubkey,\r\n    did_hash: [u8; 32],\r\n    username: \u0026str,\r\n) -\u003e Instruction {\r\n    let username_bytes = username.as_bytes();\r\n    let mut data = vec![0u8; 8 + 32 + 4 + username_bytes.len()];\r\n    let discriminator = anchor_lang::solana_program::hash::hash(b\"global:create_identity\").to_bytes();\r\n    data[..8].copy_from_slice(\u0026discriminator[..8]);\r\n    data[8..40].copy_from_slice(\u0026did_hash);\r\n    data[40..44].copy_from_slice(\u0026(username_bytes.len() as u32).to_le_bytes());\r\n    data[44..].copy_from_slice(username_bytes);\r\n\r\n    Instruction {\r\n        program_id: *program_id,\r\n        accounts: vec![\r\n            AccountMeta::new(*user, true),\r\n            AccountMeta::new(*identity, false),\r\n            AccountMeta::new_readonly(*config, false),\r\n            AccountMeta::new_readonly(solana_sdk::system_program::id(), false),\r\n        ],\r\n        data,\r\n    }\r\n}\r\n\r\npub fn create_subscribe_ix(\r\n    program_id: \u0026Pubkey,\r\n    user: \u0026Pubkey,\r\n    identity: \u0026Pubkey,\r\n    config: \u0026Pubkey,\r\n    tier: u8,\r\n) -\u003e Instruction {\r\n    let mut data = vec![0u8; 8 + 1];\r\n    let discriminator = anchor_lang::solana_program::hash::hash(b\"global:subscribe\").to_bytes();\r\n    data[..8].copy_from_slice(\u0026discriminator[..8]);\r\n    data[8] = tier;\r\n\r\n    Instruction {\r\n        program_id: *program_id,\r\n        accounts: vec![\r\n            AccountMeta::new(*user, true),\r\n            AccountMeta::new(*identity, false),\r\n            AccountMeta::new_readonly(*config, false),\r\n        ],\r\n        data,\r\n    }\r\n}\r\n\r\npub fn create_set_paused_ix(\r\n    program_id: \u0026Pubkey,\r\n    authority: \u0026Pubkey,\r\n    config: \u0026Pubkey,\r\n    paused: bool,\r\n) -\u003e Instruction {\r\n    let mut data = vec![0u8; 8 + 1];\r\n    let discriminator = anchor_lang::solana_program::hash::hash(b\"global:set_paused\").to_bytes();\r\n    data[..8].copy_from_slice(\u0026discriminator[..8]);\r\n    data[8] = if paused { 1 } else { 0 };\r\n\r\n    Instruction {\r\n        program_id: *program_id,\r\n        accounts: vec![\r\n            AccountMeta::new(*authority, true),\r\n            AccountMeta::new(*config, false),\r\n        ],\r\n        data,\r\n    }\r\n}\r\n\r\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","identity-protocol","tests","identity.rs"],"content":"//! Integration tests for identity-protocol identity instructions\r\n\r\nmod common;\r\n\r\nuse common::*;\r\nuse solana_sdk::signature::{Keypair, Signer};\r\n\r\n#[tokio::test]\r\nasync fn test_create_identity_instruction_format() {\r\n    let ctx = TestContext::new().await;\r\n    \r\n    let (config_pda, _bump) = ctx.get_config_pda();\r\n    let user = Keypair::new();\r\n    let (identity_pda, _) = ctx.get_identity_pda(\u0026user.pubkey());\r\n    let did_hash = [1u8; 32];\r\n    \r\n    let ix = create_identity_ix(\r\n        \u0026ctx.program_id,\r\n        \u0026user.pubkey(),\r\n        \u0026identity_pda,\r\n        \u0026config_pda,\r\n        did_hash,\r\n        \"testuser\",\r\n    );\r\n    \r\n    assert_eq!(ix.program_id, ctx.program_id);\r\n    assert_eq!(ix.accounts.len(), 4);\r\n    assert!(ix.accounts[0].is_signer);\r\n}\r\n\r\n#[tokio::test]\r\nasync fn test_create_identity_short_username() {\r\n    let ctx = TestContext::new().await;\r\n    \r\n    let (config_pda, _bump) = ctx.get_config_pda();\r\n    let user = Keypair::new();\r\n    let (identity_pda, _) = ctx.get_identity_pda(\u0026user.pubkey());\r\n    let did_hash = [2u8; 32];\r\n    \r\n    let ix = create_identity_ix(\r\n        \u0026ctx.program_id,\r\n        \u0026user.pubkey(),\r\n        \u0026identity_pda,\r\n        \u0026config_pda,\r\n        did_hash,\r\n        \"a\",\r\n    );\r\n    \r\n    assert!(ix.data.len() \u003e 8 + 32);\r\n}\r\n\r\n#[tokio::test]\r\nasync fn test_create_identity_long_username() {\r\n    let ctx = TestContext::new().await;\r\n    \r\n    let (config_pda, _bump) = ctx.get_config_pda();\r\n    let user = Keypair::new();\r\n    let (identity_pda, _) = ctx.get_identity_pda(\u0026user.pubkey());\r\n    let did_hash = [3u8; 32];\r\n    let long_username = \"verylongusernamethatisquitelong\";\r\n    \r\n    let ix = create_identity_ix(\r\n        \u0026ctx.program_id,\r\n        \u0026user.pubkey(),\r\n        \u0026identity_pda,\r\n        \u0026config_pda,\r\n        did_hash,\r\n        long_username,\r\n    );\r\n    \r\n    assert!(ix.data.len() \u003e 8 + 32 + 4);\r\n}\r\n\r\n#[tokio::test]\r\nasync fn test_create_identity_unique_did_hash() {\r\n    let ctx = TestContext::new().await;\r\n    \r\n    let (config_pda, _bump) = ctx.get_config_pda();\r\n    \r\n    for i in 0..5 {\r\n        let user = Keypair::new();\r\n        let (identity_pda, _) = ctx.get_identity_pda(\u0026user.pubkey());\r\n        let mut did_hash = [0u8; 32];\r\n        did_hash[0] = i;\r\n        \r\n        let ix = create_identity_ix(\r\n            \u0026ctx.program_id,\r\n            \u0026user.pubkey(),\r\n            \u0026identity_pda,\r\n            \u0026config_pda,\r\n            did_hash,\r\n            \u0026format!(\"user{}\", i),\r\n        );\r\n        \r\n        assert_eq!(\u0026ix.data[8..40], \u0026did_hash);\r\n    }\r\n}\r\n\r\n#[tokio::test]\r\nasync fn test_create_identity_multiple_users() {\r\n    let ctx = TestContext::new().await;\r\n    \r\n    let (config_pda, _bump) = ctx.get_config_pda();\r\n    \r\n    for i in 0..3 {\r\n        let user = Keypair::new();\r\n        let (identity_pda, _) = ctx.get_identity_pda(\u0026user.pubkey());\r\n        let did_hash = [i as u8; 32];\r\n        \r\n        let ix = create_identity_ix(\r\n            \u0026ctx.program_id,\r\n            \u0026user.pubkey(),\r\n            \u0026identity_pda,\r\n            \u0026config_pda,\r\n            did_hash,\r\n            \u0026format!(\"user{}\", i),\r\n        );\r\n        \r\n        assert_eq!(ix.accounts[0].pubkey, user.pubkey());\r\n    }\r\n}\r\n\r\n#[tokio::test]\r\nasync fn test_subscribe_instruction_format() {\r\n    let ctx = TestContext::new().await;\r\n    \r\n    let (config_pda, _bump) = ctx.get_config_pda();\r\n    let user = Keypair::new();\r\n    let (identity_pda, _) = ctx.get_identity_pda(\u0026user.pubkey());\r\n    \r\n    let ix = create_subscribe_ix(\r\n        \u0026ctx.program_id,\r\n        \u0026user.pubkey(),\r\n        \u0026identity_pda,\r\n        \u0026config_pda,\r\n        1, // tier\r\n    );\r\n    \r\n    assert_eq!(ix.program_id, ctx.program_id);\r\n    assert_eq!(ix.accounts.len(), 3);\r\n    assert_eq!(ix.data[8], 1);\r\n}\r\n\r\n#[tokio::test]\r\nasync fn test_subscribe_different_tiers() {\r\n    let ctx = TestContext::new().await;\r\n    \r\n    let (config_pda, _bump) = ctx.get_config_pda();\r\n    let user = Keypair::new();\r\n    let (identity_pda, _) = ctx.get_identity_pda(\u0026user.pubkey());\r\n    \r\n    for tier in 0..=3 {\r\n        let ix = create_subscribe_ix(\r\n            \u0026ctx.program_id,\r\n            \u0026user.pubkey(),\r\n            \u0026identity_pda,\r\n            \u0026config_pda,\r\n            tier,\r\n        );\r\n        \r\n        assert_eq!(ix.data[8], tier);\r\n    }\r\n}\r\n\r\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","identity-protocol","tests","initialize.rs"],"content":"//! Integration tests for identity-protocol initialize instruction\r\n\r\nmod common;\r\n\r\nuse common::*;\r\nuse solana_sdk::signature::{Keypair, Signer};\r\n\r\n#[tokio::test]\r\nasync fn test_initialize_success() {\r\n    let mut ctx = TestContext::new().await;\r\n    \r\n    let (config_pda, _bump) = ctx.get_config_pda();\r\n    let sas_program = Keypair::new();\r\n    let usdc_mint = Keypair::new();\r\n    \r\n    let ix = create_initialize_ix(\r\n        \u0026ctx.program_id,\r\n        \u0026ctx.payer.pubkey(),\r\n        \u0026config_pda,\r\n        \u0026sas_program.pubkey(),\r\n        \u0026usdc_mint.pubkey(),\r\n    );\r\n    \r\n    let result = ctx.process_transaction(\u0026[ix], \u0026[]).await;\r\n    assert!(result.is_ok());\r\n    \r\n    let config = ctx.get_account(config_pda).await;\r\n    assert!(config.is_some());\r\n}\r\n\r\n#[tokio::test]\r\nasync fn test_initialize_already_initialized() {\r\n    let mut ctx = TestContext::new().await;\r\n    \r\n    let (config_pda, _bump) = ctx.get_config_pda();\r\n    let sas_program = Keypair::new();\r\n    let usdc_mint = Keypair::new();\r\n    \r\n    let ix = create_initialize_ix(\r\n        \u0026ctx.program_id,\r\n        \u0026ctx.payer.pubkey(),\r\n        \u0026config_pda,\r\n        \u0026sas_program.pubkey(),\r\n        \u0026usdc_mint.pubkey(),\r\n    );\r\n    \r\n    ctx.process_transaction(\u0026[ix.clone()], \u0026[]).await.unwrap();\r\n    \r\n    let result = ctx.process_transaction(\u0026[ix], \u0026[]).await;\r\n    assert!(result.is_err());\r\n}\r\n\r\n#[tokio::test]\r\nasync fn test_initialize_with_programs() {\r\n    let mut ctx = TestContext::new().await;\r\n    \r\n    let (config_pda, _bump) = ctx.get_config_pda();\r\n    let sas_program = Keypair::new();\r\n    let usdc_mint = Keypair::new();\r\n    \r\n    let ix = create_initialize_ix(\r\n        \u0026ctx.program_id,\r\n        \u0026ctx.payer.pubkey(),\r\n        \u0026config_pda,\r\n        \u0026sas_program.pubkey(),\r\n        \u0026usdc_mint.pubkey(),\r\n    );\r\n    \r\n    let result = ctx.process_transaction(\u0026[ix], \u0026[]).await;\r\n    assert!(result.is_ok());\r\n}\r\n\r\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","sscre-protocol","src","constants.rs"],"content":"/// Seeds\r\npub const POOL_CONFIG_SEED: \u0026[u8] = b\"pool-config\";\r\npub const EPOCH_SEED: \u0026[u8] = b\"epoch\";\r\npub const USER_CLAIM_SEED: \u0026[u8] = b\"user-claim\";\r\npub const FUNDING_LAYER_SEED: \u0026[u8] = b\"funding-layer\";\r\npub const CIRCUIT_BREAKER_SEED: \u0026[u8] = b\"circuit-breaker\";\r\n\r\n/// Pool configuration\r\npub const PRIMARY_RESERVES: u64 = 350_000_000 * 1_000_000_000;  // 350M VCoin (35% of 1B)\r\npub const SECONDARY_RESERVES: u64 = 40_000_000 * 1_000_000_000; // 40M VCoin buyback buffer\r\npub const EPOCH_DURATION: i64 = 30 * 24 * 60 * 60;              // 30 days\r\npub const CLAIM_WINDOW: i64 = 90 * 24 * 60 * 60;                // 90 days to claim\r\n\r\n/// Fee deduction for gasless claims\r\npub const GASLESS_FEE_BPS: u16 = 100; // 1% deducted for gas\r\n\r\n/// Minimum claim amount\r\npub const MIN_CLAIM_AMOUNT: u64 = 1_000_000_000; // 1 VCoin minimum\r\n\r\n/// Circuit breaker thresholds\r\npub const MAX_EPOCH_EMISSION: u64 = 10_000_000 * 1_000_000_000; // 10M VCoin max per epoch\r\npub const MAX_SINGLE_CLAIM: u64 = 100_000 * 1_000_000_000;      // 100K VCoin max single claim\r\n\r\n/// 5A Score multipliers (x1000 for precision)\r\npub const SCORE_MULT_0_20: u64 = 100;   // 0.1x (10%)\r\npub const SCORE_MULT_20_40: u64 = 400;  // 0.4x (40%)\r\npub const SCORE_MULT_40_60: u64 = 700;  // 0.7x (70%)\r\npub const SCORE_MULT_60_80: u64 = 1000; // 1.0x (100%)\r\npub const SCORE_MULT_80_100: u64 = 1200; // 1.2x (120%)\r\n\r\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","sscre-protocol","src","errors.rs"],"content":"use anchor_lang::prelude::*;\r\n\r\n#[error_code]\r\npub enum SSCREError {\r\n    #[msg(\"Unauthorized: Only the authority can perform this action\")]\r\n    Unauthorized,\r\n    #[msg(\"SSCRE Protocol is paused\")]\r\n    ProtocolPaused,\r\n    #[msg(\"Invalid merkle proof\")]\r\n    InvalidMerkleProof,\r\n    #[msg(\"Already claimed for this epoch\")]\r\n    AlreadyClaimed,\r\n    #[msg(\"Claim window expired\")]\r\n    ClaimWindowExpired,\r\n    #[msg(\"Epoch not finalized\")]\r\n    EpochNotFinalized,\r\n    #[msg(\"Insufficient pool balance\")]\r\n    InsufficientPoolBalance,\r\n    #[msg(\"Claim amount below minimum\")]\r\n    ClaimBelowMinimum,\r\n    #[msg(\"Circuit breaker triggered: max epoch emission exceeded\")]\r\n    CircuitBreakerEpochMax,\r\n    #[msg(\"Circuit breaker triggered: max single claim exceeded\")]\r\n    CircuitBreakerClaimMax,\r\n    #[msg(\"Invalid epoch number\")]\r\n    InvalidEpoch,\r\n    #[msg(\"Epoch already exists\")]\r\n    EpochAlreadyExists,\r\n    #[msg(\"Oracle not registered\")]\r\n    OracleNotRegistered,\r\n    #[msg(\"Funding layer inactive\")]\r\n    FundingLayerInactive,\r\n    #[msg(\"Arithmetic overflow\")]\r\n    Overflow,\r\n    #[msg(\"Invalid token account owner\")]\r\n    InvalidTokenAccount,\r\n    #[msg(\"Invalid token mint\")]\r\n    InvalidMint,\r\n}\r\n\r\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","sscre-protocol","src","events.rs"],"content":"use anchor_lang::prelude::*;\r\n\r\n#[event]\r\npub struct PoolInitialized {\r\n    pub authority: Pubkey,\r\n    pub vcoin_mint: Pubkey,\r\n    pub initial_reserves: u64,\r\n}\r\n\r\n#[event]\r\npub struct EpochStarted {\r\n    pub epoch: u64,\r\n    pub start_time: i64,\r\n    pub end_time: i64,\r\n}\r\n\r\n#[event]\r\npub struct EpochFinalized {\r\n    pub epoch: u64,\r\n    pub merkle_root: [u8; 32],\r\n    pub total_allocation: u64,\r\n    pub eligible_users: u64,\r\n}\r\n\r\n#[event]\r\npub struct RewardsClaimed {\r\n    pub user: Pubkey,\r\n    pub epoch: u64,\r\n    pub gross_amount: u64,\r\n    pub fee_deducted: u64,\r\n    pub net_amount: u64,\r\n}\r\n\r\n#[event]\r\npub struct CircuitBreakerTriggered {\r\n    pub reason: u8,\r\n    pub value: u64,\r\n    pub threshold: u64,\r\n    pub timestamp: i64,\r\n}\r\n\r\n#[event]\r\npub struct FundingLayerSwitch {\r\n    pub from_layer: u8,\r\n    pub to_layer: u8,\r\n    pub reason: String,\r\n    pub timestamp: i64,\r\n}\r\n\r\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","sscre-protocol","src","lib.rs"],"content":"use anchor_lang::prelude::*;\r\nuse anchor_spl::token_2022::{self, Token2022};\r\nuse anchor_spl::token_interface::{Mint, TokenAccount};\r\n\r\ndeclare_id!(\"6AJNcQSfoiE2UAeUDyJUBumS9SBwhAdSznoAeYpXrxXZ\");\r\n\r\n/// SSCRE Protocol - Self-Sustaining Circular Reward Economy\r\n/// \r\n/// Merkle-based gasless reward claims with 6-layer funding hierarchy.\r\n/// \r\n/// Key Features:\r\n/// - 350M VCoin primary rewards pool\r\n/// - Monthly epoch-based distribution\r\n/// - Merkle tree claims for gas efficiency\r\n/// - 5A score-weighted rewards\r\n/// - 6-layer sustainable funding (post Year 5)\r\n/// \r\n/// Reward Distribution Formula:\r\n/// user_reward = base_allocation × five_a_multiplier × streak_bonus × vouch_multiplier\r\n\r\npub mod constants;\r\npub mod errors;\r\npub mod events;\r\npub mod state;\r\n\r\n#[cfg(test)]\r\nmod tests;\r\n\r\nuse constants::*;\r\nuse errors::*;\r\nuse state::*;\r\nuse events::*;\r\n\r\n#[program]\r\npub mod sscre_protocol {\r\n    use super::*;\r\n\r\n    /// Initialize the SSCRE rewards pool\r\n    pub fn initialize_pool(\r\n        ctx: Context\u003cInitializePool\u003e,\r\n        fee_recipient: Pubkey,\r\n    ) -\u003e Result\u003c()\u003e {\r\n        let config = \u0026mut ctx.accounts.pool_config;\r\n        \r\n        config.authority = ctx.accounts.authority.key();\r\n        config.vcoin_mint = ctx.accounts.vcoin_mint.key();\r\n        config.pool_vault = ctx.accounts.pool_vault.key();\r\n        config.five_a_program = Pubkey::default();\r\n        config.oracles = [Pubkey::default(); 5];\r\n        config.oracle_count = 0;\r\n        config.current_epoch = 0;\r\n        config.total_distributed = 0;\r\n        config.remaining_reserves = PRIMARY_RESERVES;\r\n        config.paused = false;\r\n        config.circuit_breaker_active = false;\r\n        config.fee_recipient = fee_recipient;\r\n        config.bump = ctx.bumps.pool_config;\r\n        config.vault_bump = ctx.bumps.pool_vault;\r\n        \r\n        emit!(PoolInitialized {\r\n            authority: config.authority,\r\n            vcoin_mint: config.vcoin_mint,\r\n            initial_reserves: PRIMARY_RESERVES,\r\n        });\r\n        \r\n        msg!(\"SSCRE Pool initialized with {} VCoin reserves\", PRIMARY_RESERVES);\r\n        Ok(())\r\n    }\r\n    \r\n    /// Initialize the 6-layer funding configuration\r\n    pub fn initialize_funding_layers(ctx: Context\u003cInitializeFundingLayers\u003e) -\u003e Result\u003c()\u003e {\r\n        let funding = \u0026mut ctx.accounts.funding_config;\r\n        \r\n        funding.authority = ctx.accounts.authority.key();\r\n        funding.l1_primary_remaining = PRIMARY_RESERVES;\r\n        funding.l2_secondary_remaining = SECONDARY_RESERVES;\r\n        funding.l3_buyback_rate_bps = 1000;\r\n        funding.l4_profit_rate_bps = 2500;\r\n        funding.l5_fee_recycling_rate_bps = 5000;\r\n        funding.active_layer = 1;\r\n        funding.total_recycled = 0;\r\n        funding.last_layer_switch = 0;\r\n        funding.months_remaining_estimate = 60;\r\n        funding.bump = ctx.bumps.funding_config;\r\n        \r\n        msg!(\"Funding layers initialized\");\r\n        Ok(())\r\n    }\r\n    \r\n    /// Initialize circuit breaker\r\n    pub fn initialize_circuit_breaker(ctx: Context\u003cInitializeCircuitBreaker\u003e) -\u003e Result\u003c()\u003e {\r\n        let cb = \u0026mut ctx.accounts.circuit_breaker;\r\n        \r\n        cb.authority = ctx.accounts.authority.key();\r\n        cb.is_active = false;\r\n        cb.max_epoch_emission = MAX_EPOCH_EMISSION;\r\n        cb.max_single_claim = MAX_SINGLE_CLAIM;\r\n        cb.current_epoch_emission = 0;\r\n        cb.largest_claim_this_epoch = 0;\r\n        cb.trigger_count = 0;\r\n        cb.last_trigger_at = 0;\r\n        cb.last_trigger_reason = 0;\r\n        cb.bump = ctx.bumps.circuit_breaker;\r\n        \r\n        msg!(\"Circuit breaker initialized\");\r\n        Ok(())\r\n    }\r\n    \r\n    /// Register an oracle for merkle root submission\r\n    pub fn register_oracle(ctx: Context\u003cRegisterOracle\u003e, oracle: Pubkey) -\u003e Result\u003c()\u003e {\r\n        let config = \u0026mut ctx.accounts.pool_config;\r\n        \r\n        require!(config.oracle_count \u003c 5, SSCREError::Overflow);\r\n        \r\n        let idx = config.oracle_count as usize;\r\n        config.oracles[idx] = oracle;\r\n        config.oracle_count += 1;\r\n        \r\n        msg!(\"Oracle registered: {}\", oracle);\r\n        Ok(())\r\n    }\r\n    \r\n    /// Start a new epoch\r\n    pub fn start_epoch(ctx: Context\u003cStartEpoch\u003e, total_allocation: u64) -\u003e Result\u003c()\u003e {\r\n        let config = \u0026mut ctx.accounts.pool_config;\r\n        let epoch_dist = \u0026mut ctx.accounts.epoch_distribution;\r\n        let cb = \u0026mut ctx.accounts.circuit_breaker;\r\n        \r\n        require!(!config.paused, SSCREError::ProtocolPaused);\r\n        require!(!cb.is_active, SSCREError::CircuitBreakerEpochMax);\r\n        require!(total_allocation \u003c= MAX_EPOCH_EMISSION, SSCREError::CircuitBreakerEpochMax);\r\n        require!(total_allocation \u003c= config.remaining_reserves, SSCREError::InsufficientPoolBalance);\r\n        \r\n        let clock = Clock::get()?;\r\n        \r\n        config.current_epoch = config.current_epoch.saturating_add(1);\r\n        \r\n        cb.current_epoch_emission = 0;\r\n        cb.largest_claim_this_epoch = 0;\r\n        \r\n        epoch_dist.epoch = config.current_epoch;\r\n        epoch_dist.merkle_root = [0u8; 32];\r\n        epoch_dist.total_allocation = total_allocation;\r\n        epoch_dist.total_claimed = 0;\r\n        epoch_dist.claims_count = 0;\r\n        epoch_dist.start_time = clock.unix_timestamp;\r\n        epoch_dist.end_time = clock.unix_timestamp + EPOCH_DURATION;\r\n        epoch_dist.claim_expiry = clock.unix_timestamp + EPOCH_DURATION + CLAIM_WINDOW;\r\n        epoch_dist.is_finalized = false;\r\n        epoch_dist.submitter = Pubkey::default();\r\n        epoch_dist.avg_five_a_score = 0;\r\n        epoch_dist.eligible_users = 0;\r\n        epoch_dist.bump = ctx.bumps.epoch_distribution;\r\n        \r\n        emit!(EpochStarted {\r\n            epoch: epoch_dist.epoch,\r\n            start_time: epoch_dist.start_time,\r\n            end_time: epoch_dist.end_time,\r\n        });\r\n        \r\n        msg!(\"Epoch {} started with {} VCoin allocation\", epoch_dist.epoch, total_allocation);\r\n        Ok(())\r\n    }\r\n    \r\n    /// Update merkle root (finalize epoch distribution)\r\n    pub fn update_merkle_root(\r\n        ctx: Context\u003cUpdateMerkleRoot\u003e,\r\n        merkle_root: [u8; 32],\r\n        eligible_users: u64,\r\n        avg_five_a_score: u16,\r\n    ) -\u003e Result\u003c()\u003e {\r\n        let config = \u0026ctx.accounts.pool_config;\r\n        let epoch_dist = \u0026mut ctx.accounts.epoch_distribution;\r\n        \r\n        require!(!config.paused, SSCREError::ProtocolPaused);\r\n        require!(!epoch_dist.is_finalized, SSCREError::EpochAlreadyExists);\r\n        \r\n        let oracle_key = ctx.accounts.oracle.key();\r\n        let is_oracle = config.oracles[..config.oracle_count as usize].contains(\u0026oracle_key);\r\n        require!(is_oracle, SSCREError::OracleNotRegistered);\r\n        \r\n        epoch_dist.merkle_root = merkle_root;\r\n        epoch_dist.is_finalized = true;\r\n        epoch_dist.submitter = oracle_key;\r\n        epoch_dist.eligible_users = eligible_users;\r\n        epoch_dist.avg_five_a_score = avg_five_a_score;\r\n        \r\n        emit!(EpochFinalized {\r\n            epoch: epoch_dist.epoch,\r\n            merkle_root,\r\n            total_allocation: epoch_dist.total_allocation,\r\n            eligible_users,\r\n        });\r\n        \r\n        msg!(\"Epoch {} finalized with merkle root\", epoch_dist.epoch);\r\n        Ok(())\r\n    }\r\n    \r\n    /// Claim rewards with merkle proof\r\n    pub fn claim_rewards(\r\n        ctx: Context\u003cClaimRewards\u003e,\r\n        amount: u64,\r\n        merkle_proof: Vec\u003c[u8; 32]\u003e,\r\n    ) -\u003e Result\u003c()\u003e {\r\n        let config = \u0026mut ctx.accounts.pool_config;\r\n        let epoch_dist = \u0026mut ctx.accounts.epoch_distribution;\r\n        let user_claim = \u0026mut ctx.accounts.user_claim;\r\n        let cb = \u0026mut ctx.accounts.circuit_breaker;\r\n        \r\n        require!(!config.paused, SSCREError::ProtocolPaused);\r\n        require!(!cb.is_active, SSCREError::CircuitBreakerEpochMax);\r\n        require!(epoch_dist.is_finalized, SSCREError::EpochNotFinalized);\r\n        require!(amount \u003e= MIN_CLAIM_AMOUNT, SSCREError::ClaimBelowMinimum);\r\n        require!(amount \u003c= MAX_SINGLE_CLAIM, SSCREError::CircuitBreakerClaimMax);\r\n        \r\n        let clock = Clock::get()?;\r\n        \r\n        require!(clock.unix_timestamp \u003c= epoch_dist.claim_expiry, SSCREError::ClaimWindowExpired);\r\n        require!(!user_claim.is_epoch_claimed(epoch_dist.epoch), SSCREError::AlreadyClaimed);\r\n        \r\n        let user_key = ctx.accounts.user.key();\r\n        let leaf = compute_leaf(\u0026user_key, amount, epoch_dist.epoch);\r\n        require!(verify_merkle_proof(\u0026merkle_proof, \u0026epoch_dist.merkle_root, \u0026leaf), SSCREError::InvalidMerkleProof);\r\n        \r\n        let fee = (amount as u128 * GASLESS_FEE_BPS as u128 / 10000) as u64;\r\n        let net_amount = amount.saturating_sub(fee);\r\n        \r\n        let pool_bump = config.bump;\r\n        let seeds = \u0026[POOL_CONFIG_SEED, \u0026[pool_bump]];\r\n        let signer_seeds = \u0026[\u0026seeds[..]];\r\n        \r\n        token_2022::transfer_checked(\r\n            CpiContext::new_with_signer(ctx.accounts.token_program.to_account_info(),\r\n                token_2022::TransferChecked {\r\n                    from: ctx.accounts.pool_vault.to_account_info(),\r\n                    to: ctx.accounts.user_token_account.to_account_info(),\r\n                    authority: config.to_account_info(),\r\n                    mint: ctx.accounts.vcoin_mint.to_account_info(),\r\n                },\r\n                signer_seeds,\r\n            ),\r\n            net_amount,\r\n            ctx.accounts.vcoin_mint.decimals,\r\n        )?;\r\n        \r\n        if fee \u003e 0 {\r\n            token_2022::transfer_checked(\r\n                CpiContext::new_with_signer(ctx.accounts.token_program.to_account_info(),\r\n                    token_2022::TransferChecked {\r\n                        from: ctx.accounts.pool_vault.to_account_info(),\r\n                        to: ctx.accounts.fee_account.to_account_info(),\r\n                        authority: config.to_account_info(),\r\n                        mint: ctx.accounts.vcoin_mint.to_account_info(),\r\n                    },\r\n                    signer_seeds,\r\n                ),\r\n                fee,\r\n                ctx.accounts.vcoin_mint.decimals,\r\n            )?;\r\n        }\r\n        \r\n        user_claim.user = user_key;\r\n        user_claim.mark_epoch_claimed(epoch_dist.epoch);\r\n        user_claim.total_claimed = user_claim.total_claimed.saturating_add(net_amount);\r\n        user_claim.claims_count = user_claim.claims_count.saturating_add(1);\r\n        \r\n        if user_claim.first_claim_at == 0 {\r\n            user_claim.first_claim_at = clock.unix_timestamp;\r\n        }\r\n        user_claim.last_claim_at = clock.unix_timestamp;\r\n        user_claim.bump = ctx.bumps.user_claim;\r\n        \r\n        epoch_dist.total_claimed = epoch_dist.total_claimed.saturating_add(amount);\r\n        epoch_dist.claims_count = epoch_dist.claims_count.saturating_add(1);\r\n        \r\n        config.total_distributed = config.total_distributed.saturating_add(amount);\r\n        config.remaining_reserves = config.remaining_reserves.saturating_sub(amount);\r\n        \r\n        cb.current_epoch_emission = cb.current_epoch_emission.saturating_add(amount);\r\n        if amount \u003e cb.largest_claim_this_epoch {\r\n            cb.largest_claim_this_epoch = amount;\r\n        }\r\n        \r\n        emit!(RewardsClaimed {\r\n            user: user_key,\r\n            epoch: epoch_dist.epoch,\r\n            gross_amount: amount,\r\n            fee_deducted: fee,\r\n            net_amount,\r\n        });\r\n        \r\n        msg!(\"Claimed {} VCoin (net: {} after {} fee)\", amount, net_amount, fee);\r\n        Ok(())\r\n    }\r\n    \r\n    /// Trigger circuit breaker (emergency)\r\n    pub fn trigger_circuit_breaker(ctx: Context\u003cTriggerCircuitBreaker\u003e, reason: u8) -\u003e Result\u003c()\u003e {\r\n        let config = \u0026mut ctx.accounts.pool_config;\r\n        let cb = \u0026mut ctx.accounts.circuit_breaker;\r\n        \r\n        let clock = Clock::get()?;\r\n        \r\n        cb.is_active = true;\r\n        cb.trigger_count = cb.trigger_count.saturating_add(1);\r\n        cb.last_trigger_at = clock.unix_timestamp;\r\n        cb.last_trigger_reason = reason;\r\n        \r\n        config.circuit_breaker_active = true;\r\n        \r\n        emit!(CircuitBreakerTriggered {\r\n            reason,\r\n            value: 0,\r\n            threshold: 0,\r\n            timestamp: clock.unix_timestamp,\r\n        });\r\n        \r\n        msg!(\"Circuit breaker triggered: reason {}\", reason);\r\n        Ok(())\r\n    }\r\n    \r\n    /// Reset circuit breaker (after investigation)\r\n    pub fn reset_circuit_breaker(ctx: Context\u003cResetCircuitBreaker\u003e) -\u003e Result\u003c()\u003e {\r\n        let config = \u0026mut ctx.accounts.pool_config;\r\n        let cb = \u0026mut ctx.accounts.circuit_breaker;\r\n        \r\n        cb.is_active = false;\r\n        config.circuit_breaker_active = false;\r\n        \r\n        msg!(\"Circuit breaker reset\");\r\n        Ok(())\r\n    }\r\n    \r\n    /// Pause/unpause protocol\r\n    pub fn set_paused(ctx: Context\u003cUpdateConfig\u003e, paused: bool) -\u003e Result\u003c()\u003e {\r\n        ctx.accounts.pool_config.paused = paused;\r\n        msg!(\"SSCRE Protocol paused: {}\", paused);\r\n        Ok(())\r\n    }\r\n    \r\n    /// Update authority\r\n    pub fn update_authority(ctx: Context\u003cUpdateAuthority\u003e, new_authority: Pubkey) -\u003e Result\u003c()\u003e {\r\n        ctx.accounts.pool_config.authority = new_authority;\r\n        msg!(\"Authority updated to: {}\", new_authority);\r\n        Ok(())\r\n    }\r\n    \r\n    /// Update 5A program reference\r\n    pub fn set_five_a_program(ctx: Context\u003cUpdateConfig\u003e, five_a_program: Pubkey) -\u003e Result\u003c()\u003e {\r\n        ctx.accounts.pool_config.five_a_program = five_a_program;\r\n        msg!(\"5A Program set to: {}\", five_a_program);\r\n        Ok(())\r\n    }\r\n    \r\n    /// Get pool stats\r\n    pub fn get_pool_stats(ctx: Context\u003cGetPoolStats\u003e) -\u003e Result\u003c()\u003e {\r\n        let config = \u0026ctx.accounts.pool_config;\r\n        msg!(\"Current epoch: {}\", config.current_epoch);\r\n        msg!(\"Total distributed: {}\", config.total_distributed);\r\n        msg!(\"Remaining reserves: {}\", config.remaining_reserves);\r\n        msg!(\"Paused: {}\", config.paused);\r\n        Ok(())\r\n    }\r\n    \r\n    /// Get user claim stats\r\n    pub fn get_user_stats(ctx: Context\u003cGetUserStats\u003e) -\u003e Result\u003c()\u003e {\r\n        let claim = \u0026ctx.accounts.user_claim;\r\n        msg!(\"User: {}\", claim.user);\r\n        msg!(\"Total claimed: {}\", claim.total_claimed);\r\n        msg!(\"Claims count: {}\", claim.claims_count);\r\n        msg!(\"Last claimed epoch: {}\", claim.last_claimed_epoch);\r\n        Ok(())\r\n    }\r\n}\r\n\r\n// Account contexts\r\n\r\n#[derive(Accounts)]\r\npub struct InitializePool\u003c'info\u003e {\r\n    #[account(init, payer = authority, space = RewardsPoolConfig::LEN, seeds = [POOL_CONFIG_SEED], bump)]\r\n    pub pool_config: Account\u003c'info, RewardsPoolConfig\u003e,\r\n    pub vcoin_mint: InterfaceAccount\u003c'info, Mint\u003e,\r\n    #[account(init, payer = authority, seeds = [b\"pool-vault\"], bump, token::mint = vcoin_mint, token::authority = pool_config, token::token_program = token_program)]\r\n    pub pool_vault: InterfaceAccount\u003c'info, TokenAccount\u003e,\r\n    #[account(mut)]\r\n    pub authority: Signer\u003c'info\u003e,\r\n    pub token_program: Program\u003c'info, Token2022\u003e,\r\n    pub system_program: Program\u003c'info, System\u003e,\r\n}\r\n\r\n#[derive(Accounts)]\r\npub struct InitializeFundingLayers\u003c'info\u003e {\r\n    #[account(seeds = [POOL_CONFIG_SEED], bump = pool_config.bump, has_one = authority @ SSCREError::Unauthorized)]\r\n    pub pool_config: Account\u003c'info, RewardsPoolConfig\u003e,\r\n    #[account(init, payer = authority, space = FundingLayerConfig::LEN, seeds = [FUNDING_LAYER_SEED], bump)]\r\n    pub funding_config: Account\u003c'info, FundingLayerConfig\u003e,\r\n    #[account(mut)]\r\n    pub authority: Signer\u003c'info\u003e,\r\n    pub system_program: Program\u003c'info, System\u003e,\r\n}\r\n\r\n#[derive(Accounts)]\r\npub struct InitializeCircuitBreaker\u003c'info\u003e {\r\n    #[account(seeds = [POOL_CONFIG_SEED], bump = pool_config.bump, has_one = authority @ SSCREError::Unauthorized)]\r\n    pub pool_config: Account\u003c'info, RewardsPoolConfig\u003e,\r\n    #[account(init, payer = authority, space = CircuitBreaker::LEN, seeds = [CIRCUIT_BREAKER_SEED], bump)]\r\n    pub circuit_breaker: Account\u003c'info, CircuitBreaker\u003e,\r\n    #[account(mut)]\r\n    pub authority: Signer\u003c'info\u003e,\r\n    pub system_program: Program\u003c'info, System\u003e,\r\n}\r\n\r\n#[derive(Accounts)]\r\npub struct RegisterOracle\u003c'info\u003e {\r\n    #[account(mut, seeds = [POOL_CONFIG_SEED], bump = pool_config.bump, has_one = authority @ SSCREError::Unauthorized)]\r\n    pub pool_config: Account\u003c'info, RewardsPoolConfig\u003e,\r\n    pub authority: Signer\u003c'info\u003e,\r\n}\r\n\r\n#[derive(Accounts)]\r\npub struct StartEpoch\u003c'info\u003e {\r\n    #[account(mut, seeds = [POOL_CONFIG_SEED], bump = pool_config.bump, has_one = authority @ SSCREError::Unauthorized)]\r\n    pub pool_config: Account\u003c'info, RewardsPoolConfig\u003e,\r\n    #[account(init, payer = authority, space = EpochDistribution::LEN, seeds = [EPOCH_SEED, (pool_config.current_epoch + 1).to_le_bytes().as_ref()], bump)]\r\n    pub epoch_distribution: Account\u003c'info, EpochDistribution\u003e,\r\n    #[account(mut, seeds = [CIRCUIT_BREAKER_SEED], bump = circuit_breaker.bump)]\r\n    pub circuit_breaker: Account\u003c'info, CircuitBreaker\u003e,\r\n    #[account(mut)]\r\n    pub authority: Signer\u003c'info\u003e,\r\n    pub system_program: Program\u003c'info, System\u003e,\r\n}\r\n\r\n#[derive(Accounts)]\r\npub struct UpdateMerkleRoot\u003c'info\u003e {\r\n    #[account(seeds = [POOL_CONFIG_SEED], bump = pool_config.bump)]\r\n    pub pool_config: Account\u003c'info, RewardsPoolConfig\u003e,\r\n    #[account(mut, seeds = [EPOCH_SEED, epoch_distribution.epoch.to_le_bytes().as_ref()], bump = epoch_distribution.bump)]\r\n    pub epoch_distribution: Account\u003c'info, EpochDistribution\u003e,\r\n    pub oracle: Signer\u003c'info\u003e,\r\n}\r\n\r\n#[derive(Accounts)]\r\npub struct ClaimRewards\u003c'info\u003e {\r\n    #[account(mut, seeds = [POOL_CONFIG_SEED], bump = pool_config.bump)]\r\n    pub pool_config: Account\u003c'info, RewardsPoolConfig\u003e,\r\n    #[account(mut, seeds = [EPOCH_SEED, epoch_distribution.epoch.to_le_bytes().as_ref()], bump = epoch_distribution.bump)]\r\n    pub epoch_distribution: Account\u003c'info, EpochDistribution\u003e,\r\n    #[account(init_if_needed, payer = user, space = UserClaim::LEN, seeds = [USER_CLAIM_SEED, user.key().as_ref()], bump)]\r\n    pub user_claim: Account\u003c'info, UserClaim\u003e,\r\n    #[account(mut, seeds = [CIRCUIT_BREAKER_SEED], bump = circuit_breaker.bump)]\r\n    pub circuit_breaker: Account\u003c'info, CircuitBreaker\u003e,\r\n    #[account(constraint = vcoin_mint.key() == pool_config.vcoin_mint)]\r\n    pub vcoin_mint: InterfaceAccount\u003c'info, Mint\u003e,\r\n    #[account(mut, seeds = [b\"pool-vault\"], bump)]\r\n    pub pool_vault: InterfaceAccount\u003c'info, TokenAccount\u003e,\r\n    #[account(mut, constraint = user_token_account.owner == user.key() @ SSCREError::InvalidTokenAccount, constraint = user_token_account.mint == pool_config.vcoin_mint @ SSCREError::InvalidMint)]\r\n    pub user_token_account: InterfaceAccount\u003c'info, TokenAccount\u003e,\r\n    #[account(mut, constraint = fee_account.owner == pool_config.fee_recipient @ SSCREError::InvalidTokenAccount, constraint = fee_account.mint == pool_config.vcoin_mint @ SSCREError::InvalidMint)]\r\n    pub fee_account: InterfaceAccount\u003c'info, TokenAccount\u003e,\r\n    #[account(mut)]\r\n    pub user: Signer\u003c'info\u003e,\r\n    pub token_program: Program\u003c'info, Token2022\u003e,\r\n    pub system_program: Program\u003c'info, System\u003e,\r\n}\r\n\r\n#[derive(Accounts)]\r\npub struct TriggerCircuitBreaker\u003c'info\u003e {\r\n    #[account(mut, seeds = [POOL_CONFIG_SEED], bump = pool_config.bump, has_one = authority @ SSCREError::Unauthorized)]\r\n    pub pool_config: Account\u003c'info, RewardsPoolConfig\u003e,\r\n    #[account(mut, seeds = [CIRCUIT_BREAKER_SEED], bump = circuit_breaker.bump)]\r\n    pub circuit_breaker: Account\u003c'info, CircuitBreaker\u003e,\r\n    pub authority: Signer\u003c'info\u003e,\r\n}\r\n\r\n#[derive(Accounts)]\r\npub struct ResetCircuitBreaker\u003c'info\u003e {\r\n    #[account(mut, seeds = [POOL_CONFIG_SEED], bump = pool_config.bump, has_one = authority @ SSCREError::Unauthorized)]\r\n    pub pool_config: Account\u003c'info, RewardsPoolConfig\u003e,\r\n    #[account(mut, seeds = [CIRCUIT_BREAKER_SEED], bump = circuit_breaker.bump)]\r\n    pub circuit_breaker: Account\u003c'info, CircuitBreaker\u003e,\r\n    pub authority: Signer\u003c'info\u003e,\r\n}\r\n\r\n#[derive(Accounts)]\r\npub struct UpdateConfig\u003c'info\u003e {\r\n    #[account(mut, seeds = [POOL_CONFIG_SEED], bump = pool_config.bump, has_one = authority @ SSCREError::Unauthorized)]\r\n    pub pool_config: Account\u003c'info, RewardsPoolConfig\u003e,\r\n    pub authority: Signer\u003c'info\u003e,\r\n}\r\n\r\n#[derive(Accounts)]\r\npub struct UpdateAuthority\u003c'info\u003e {\r\n    #[account(mut, seeds = [POOL_CONFIG_SEED], bump = pool_config.bump, has_one = authority @ SSCREError::Unauthorized)]\r\n    pub pool_config: Account\u003c'info, RewardsPoolConfig\u003e,\r\n    pub authority: Signer\u003c'info\u003e,\r\n}\r\n\r\n#[derive(Accounts)]\r\npub struct GetPoolStats\u003c'info\u003e {\r\n    #[account(seeds = [POOL_CONFIG_SEED], bump = pool_config.bump)]\r\n    pub pool_config: Account\u003c'info, RewardsPoolConfig\u003e,\r\n}\r\n\r\n#[derive(Accounts)]\r\npub struct GetUserStats\u003c'info\u003e {\r\n    #[account(seeds = [USER_CLAIM_SEED, user_claim.user.as_ref()], bump = user_claim.bump)]\r\n    pub user_claim: Account\u003c'info, UserClaim\u003e,\r\n}\r\n","traces":[{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":0}},{"line":98,"address":[],"length":0,"stats":{"Line":0}},{"line":99,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[],"length":0,"stats":{"Line":0}},{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":105,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":125,"address":[],"length":0,"stats":{"Line":0}},{"line":126,"address":[],"length":0,"stats":{"Line":0}},{"line":127,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":130,"address":[],"length":0,"stats":{"Line":0}},{"line":131,"address":[],"length":0,"stats":{"Line":0}},{"line":132,"address":[],"length":0,"stats":{"Line":0}},{"line":134,"address":[],"length":0,"stats":{"Line":0}},{"line":136,"address":[],"length":0,"stats":{"Line":0}},{"line":138,"address":[],"length":0,"stats":{"Line":0}},{"line":139,"address":[],"length":0,"stats":{"Line":0}},{"line":141,"address":[],"length":0,"stats":{"Line":0}},{"line":142,"address":[],"length":0,"stats":{"Line":0}},{"line":143,"address":[],"length":0,"stats":{"Line":0}},{"line":144,"address":[],"length":0,"stats":{"Line":0}},{"line":145,"address":[],"length":0,"stats":{"Line":0}},{"line":146,"address":[],"length":0,"stats":{"Line":0}},{"line":147,"address":[],"length":0,"stats":{"Line":0}},{"line":148,"address":[],"length":0,"stats":{"Line":0}},{"line":149,"address":[],"length":0,"stats":{"Line":0}},{"line":150,"address":[],"length":0,"stats":{"Line":0}},{"line":151,"address":[],"length":0,"stats":{"Line":0}},{"line":152,"address":[],"length":0,"stats":{"Line":0}},{"line":153,"address":[],"length":0,"stats":{"Line":0}},{"line":155,"address":[],"length":0,"stats":{"Line":0}},{"line":156,"address":[],"length":0,"stats":{"Line":0}},{"line":157,"address":[],"length":0,"stats":{"Line":0}},{"line":158,"address":[],"length":0,"stats":{"Line":0}},{"line":161,"address":[],"length":0,"stats":{"Line":0}},{"line":162,"address":[],"length":0,"stats":{"Line":0}},{"line":166,"address":[],"length":0,"stats":{"Line":0}},{"line":172,"address":[],"length":0,"stats":{"Line":0}},{"line":173,"address":[],"length":0,"stats":{"Line":0}},{"line":175,"address":[],"length":0,"stats":{"Line":0}},{"line":176,"address":[],"length":0,"stats":{"Line":0}},{"line":178,"address":[],"length":0,"stats":{"Line":0}},{"line":179,"address":[],"length":0,"stats":{"Line":0}},{"line":180,"address":[],"length":0,"stats":{"Line":0}},{"line":182,"address":[],"length":0,"stats":{"Line":0}},{"line":183,"address":[],"length":0,"stats":{"Line":0}},{"line":184,"address":[],"length":0,"stats":{"Line":0}},{"line":185,"address":[],"length":0,"stats":{"Line":0}},{"line":186,"address":[],"length":0,"stats":{"Line":0}},{"line":188,"address":[],"length":0,"stats":{"Line":0}},{"line":189,"address":[],"length":0,"stats":{"Line":0}},{"line":190,"address":[],"length":0,"stats":{"Line":0}},{"line":191,"address":[],"length":0,"stats":{"Line":0}},{"line":192,"address":[],"length":0,"stats":{"Line":0}},{"line":195,"address":[],"length":0,"stats":{"Line":0}},{"line":196,"address":[],"length":0,"stats":{"Line":0}},{"line":200,"address":[],"length":0,"stats":{"Line":0}},{"line":205,"address":[],"length":0,"stats":{"Line":0}},{"line":206,"address":[],"length":0,"stats":{"Line":0}},{"line":207,"address":[],"length":0,"stats":{"Line":0}},{"line":208,"address":[],"length":0,"stats":{"Line":0}},{"line":210,"address":[],"length":0,"stats":{"Line":0}},{"line":211,"address":[],"length":0,"stats":{"Line":0}},{"line":212,"address":[],"length":0,"stats":{"Line":0}},{"line":213,"address":[],"length":0,"stats":{"Line":0}},{"line":214,"address":[],"length":0,"stats":{"Line":0}},{"line":216,"address":[],"length":0,"stats":{"Line":0}},{"line":218,"address":[],"length":0,"stats":{"Line":0}},{"line":219,"address":[],"length":0,"stats":{"Line":0}},{"line":221,"address":[],"length":0,"stats":{"Line":0}},{"line":222,"address":[],"length":0,"stats":{"Line":0}},{"line":223,"address":[],"length":0,"stats":{"Line":0}},{"line":225,"address":[],"length":0,"stats":{"Line":0}},{"line":226,"address":[],"length":0,"stats":{"Line":0}},{"line":228,"address":[],"length":0,"stats":{"Line":0}},{"line":229,"address":[],"length":0,"stats":{"Line":0}},{"line":230,"address":[],"length":0,"stats":{"Line":0}},{"line":233,"address":[],"length":0,"stats":{"Line":0}},{"line":234,"address":[],"length":0,"stats":{"Line":0}},{"line":235,"address":[],"length":0,"stats":{"Line":0}},{"line":236,"address":[],"length":0,"stats":{"Line":0}},{"line":237,"address":[],"length":0,"stats":{"Line":0}},{"line":238,"address":[],"length":0,"stats":{"Line":0}},{"line":240,"address":[],"length":0,"stats":{"Line":0}},{"line":242,"address":[],"length":0,"stats":{"Line":0}},{"line":243,"address":[],"length":0,"stats":{"Line":0}},{"line":246,"address":[],"length":0,"stats":{"Line":0}},{"line":248,"address":[],"length":0,"stats":{"Line":0}},{"line":249,"address":[],"length":0,"stats":{"Line":0}},{"line":250,"address":[],"length":0,"stats":{"Line":0}},{"line":251,"address":[],"length":0,"stats":{"Line":0}},{"line":252,"address":[],"length":0,"stats":{"Line":0}},{"line":253,"address":[],"length":0,"stats":{"Line":0}},{"line":255,"address":[],"length":0,"stats":{"Line":0}},{"line":257,"address":[],"length":0,"stats":{"Line":0}},{"line":258,"address":[],"length":0,"stats":{"Line":0}},{"line":262,"address":[],"length":0,"stats":{"Line":0}},{"line":263,"address":[],"length":0,"stats":{"Line":0}},{"line":264,"address":[],"length":0,"stats":{"Line":0}},{"line":265,"address":[],"length":0,"stats":{"Line":0}},{"line":267,"address":[],"length":0,"stats":{"Line":0}},{"line":268,"address":[],"length":0,"stats":{"Line":0}},{"line":270,"address":[],"length":0,"stats":{"Line":0}},{"line":271,"address":[],"length":0,"stats":{"Line":0}},{"line":273,"address":[],"length":0,"stats":{"Line":0}},{"line":274,"address":[],"length":0,"stats":{"Line":0}},{"line":276,"address":[],"length":0,"stats":{"Line":0}},{"line":277,"address":[],"length":0,"stats":{"Line":0}},{"line":279,"address":[],"length":0,"stats":{"Line":0}},{"line":280,"address":[],"length":0,"stats":{"Line":0}},{"line":281,"address":[],"length":0,"stats":{"Line":0}},{"line":284,"address":[],"length":0,"stats":{"Line":0}},{"line":285,"address":[],"length":0,"stats":{"Line":0}},{"line":286,"address":[],"length":0,"stats":{"Line":0}},{"line":287,"address":[],"length":0,"stats":{"Line":0}},{"line":288,"address":[],"length":0,"stats":{"Line":0}},{"line":289,"address":[],"length":0,"stats":{"Line":0}},{"line":292,"address":[],"length":0,"stats":{"Line":0}},{"line":293,"address":[],"length":0,"stats":{"Line":0}},{"line":297,"address":[],"length":0,"stats":{"Line":0}},{"line":298,"address":[],"length":0,"stats":{"Line":0}},{"line":299,"address":[],"length":0,"stats":{"Line":0}},{"line":301,"address":[],"length":0,"stats":{"Line":0}},{"line":303,"address":[],"length":0,"stats":{"Line":0}},{"line":304,"address":[],"length":0,"stats":{"Line":0}},{"line":305,"address":[],"length":0,"stats":{"Line":0}},{"line":306,"address":[],"length":0,"stats":{"Line":0}},{"line":308,"address":[],"length":0,"stats":{"Line":0}},{"line":310,"address":[],"length":0,"stats":{"Line":0}},{"line":311,"address":[],"length":0,"stats":{"Line":0}},{"line":312,"address":[],"length":0,"stats":{"Line":0}},{"line":313,"address":[],"length":0,"stats":{"Line":0}},{"line":314,"address":[],"length":0,"stats":{"Line":0}},{"line":317,"address":[],"length":0,"stats":{"Line":0}},{"line":318,"address":[],"length":0,"stats":{"Line":0}},{"line":322,"address":[],"length":0,"stats":{"Line":0}},{"line":323,"address":[],"length":0,"stats":{"Line":0}},{"line":324,"address":[],"length":0,"stats":{"Line":0}},{"line":326,"address":[],"length":0,"stats":{"Line":0}},{"line":327,"address":[],"length":0,"stats":{"Line":0}},{"line":329,"address":[],"length":0,"stats":{"Line":0}},{"line":330,"address":[],"length":0,"stats":{"Line":0}},{"line":334,"address":[],"length":0,"stats":{"Line":0}},{"line":335,"address":[],"length":0,"stats":{"Line":0}},{"line":336,"address":[],"length":0,"stats":{"Line":0}},{"line":337,"address":[],"length":0,"stats":{"Line":0}},{"line":341,"address":[],"length":0,"stats":{"Line":0}},{"line":342,"address":[],"length":0,"stats":{"Line":0}},{"line":343,"address":[],"length":0,"stats":{"Line":0}},{"line":344,"address":[],"length":0,"stats":{"Line":0}},{"line":348,"address":[],"length":0,"stats":{"Line":0}},{"line":349,"address":[],"length":0,"stats":{"Line":0}},{"line":350,"address":[],"length":0,"stats":{"Line":0}},{"line":351,"address":[],"length":0,"stats":{"Line":0}},{"line":355,"address":[],"length":0,"stats":{"Line":0}},{"line":356,"address":[],"length":0,"stats":{"Line":0}},{"line":357,"address":[],"length":0,"stats":{"Line":0}},{"line":358,"address":[],"length":0,"stats":{"Line":0}},{"line":359,"address":[],"length":0,"stats":{"Line":0}},{"line":360,"address":[],"length":0,"stats":{"Line":0}},{"line":361,"address":[],"length":0,"stats":{"Line":0}},{"line":365,"address":[],"length":0,"stats":{"Line":0}},{"line":366,"address":[],"length":0,"stats":{"Line":0}},{"line":367,"address":[],"length":0,"stats":{"Line":0}},{"line":368,"address":[],"length":0,"stats":{"Line":0}},{"line":369,"address":[],"length":0,"stats":{"Line":0}},{"line":370,"address":[],"length":0,"stats":{"Line":0}},{"line":371,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":222},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","sscre-protocol","src","state","circuit_breaker.rs"],"content":"use anchor_lang::prelude::*;\r\n\r\n/// Circuit breaker state\r\n#[account]\r\n#[derive(Default)]\r\npub struct CircuitBreaker {\r\n    /// Authority\r\n    pub authority: Pubkey,\r\n    /// Whether circuit breaker is active\r\n    pub is_active: bool,\r\n    /// Max emission per epoch\r\n    pub max_epoch_emission: u64,\r\n    /// Max single claim\r\n    pub max_single_claim: u64,\r\n    /// Current epoch emission so far\r\n    pub current_epoch_emission: u64,\r\n    /// Largest claim this epoch\r\n    pub largest_claim_this_epoch: u64,\r\n    /// Number of triggers\r\n    pub trigger_count: u32,\r\n    /// Last trigger timestamp\r\n    pub last_trigger_at: i64,\r\n    /// Trigger reason\r\n    pub last_trigger_reason: u8,\r\n    /// PDA bump\r\n    pub bump: u8,\r\n}\r\n\r\nimpl CircuitBreaker {\r\n    pub const LEN: usize = 8 + // discriminator\r\n        32 + // authority\r\n        1 +  // is_active\r\n        8 +  // max_epoch_emission\r\n        8 +  // max_single_claim\r\n        8 +  // current_epoch_emission\r\n        8 +  // largest_claim_this_epoch\r\n        4 +  // trigger_count\r\n        8 +  // last_trigger_at\r\n        1 +  // last_trigger_reason\r\n        1;   // bump\r\n}\r\n\r\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","sscre-protocol","src","state","epoch_distribution.rs"],"content":"use anchor_lang::prelude::*;\r\n\r\n/// Epoch distribution account\r\n#[account]\r\n#[derive(Default)]\r\npub struct EpochDistribution {\r\n    /// Epoch number\r\n    pub epoch: u64,\r\n    /// Merkle root of all user allocations\r\n    pub merkle_root: [u8; 32],\r\n    /// Total VCoin allocated for this epoch\r\n    pub total_allocation: u64,\r\n    /// Total VCoin claimed so far\r\n    pub total_claimed: u64,\r\n    /// Number of users who claimed\r\n    pub claims_count: u64,\r\n    /// Epoch start timestamp\r\n    pub start_time: i64,\r\n    /// Epoch end timestamp\r\n    pub end_time: i64,\r\n    /// Claim window expiry\r\n    pub claim_expiry: i64,\r\n    /// Whether epoch is finalized (merkle root set)\r\n    pub is_finalized: bool,\r\n    /// Oracle that submitted the merkle root\r\n    pub submitter: Pubkey,\r\n    /// Average 5A score for this epoch\r\n    pub avg_five_a_score: u16,\r\n    /// Total eligible users\r\n    pub eligible_users: u64,\r\n    /// PDA bump\r\n    pub bump: u8,\r\n}\r\n\r\nimpl EpochDistribution {\r\n    pub const LEN: usize = 8 + // discriminator\r\n        8 +  // epoch\r\n        32 + // merkle_root\r\n        8 +  // total_allocation\r\n        8 +  // total_claimed\r\n        8 +  // claims_count\r\n        8 +  // start_time\r\n        8 +  // end_time\r\n        8 +  // claim_expiry\r\n        1 +  // is_finalized\r\n        32 + // submitter\r\n        2 +  // avg_five_a_score\r\n        8 +  // eligible_users\r\n        1;   // bump\r\n}\r\n\r\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","sscre-protocol","src","state","funding_layer_config.rs"],"content":"use anchor_lang::prelude::*;\r\n\r\n/// 6-Layer Funding Configuration (for post Year 5 sustainability)\r\n#[account]\r\n#[derive(Default)]\r\npub struct FundingLayerConfig {\r\n    /// Authority\r\n    pub authority: Pubkey,\r\n    /// Layer 1: Primary reserves remaining\r\n    pub l1_primary_remaining: u64,\r\n    /// Layer 2: Secondary reserves (buyback buffer)\r\n    pub l2_secondary_remaining: u64,\r\n    /// Layer 3: Buyback recycling (10% monthly revenue)\r\n    pub l3_buyback_rate_bps: u16,\r\n    /// Layer 4: Profit buybacks (25% quarterly profit)\r\n    pub l4_profit_rate_bps: u16,\r\n    /// Layer 5: Fee recycling (50% platform fees)\r\n    pub l5_fee_recycling_rate_bps: u16,\r\n    /// Current active layer (1-5)\r\n    pub active_layer: u8,\r\n    /// Total recycled through L3-L5\r\n    pub total_recycled: u64,\r\n    /// Last layer switch timestamp\r\n    pub last_layer_switch: i64,\r\n    /// Months until primary depletion (estimate)\r\n    pub months_remaining_estimate: u16,\r\n    /// PDA bump\r\n    pub bump: u8,\r\n}\r\n\r\nimpl FundingLayerConfig {\r\n    pub const LEN: usize = 8 + // discriminator\r\n        32 + // authority\r\n        8 +  // l1_primary_remaining\r\n        8 +  // l2_secondary_remaining\r\n        2 +  // l3_buyback_rate_bps\r\n        2 +  // l4_profit_rate_bps\r\n        2 +  // l5_fee_recycling_rate_bps\r\n        1 +  // active_layer\r\n        8 +  // total_recycled\r\n        8 +  // last_layer_switch\r\n        2 +  // months_remaining_estimate\r\n        1;   // bump\r\n}\r\n\r\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","sscre-protocol","src","state","mod.rs"],"content":"pub mod rewards_pool_config;\r\npub mod epoch_distribution;\r\npub mod user_claim;\r\npub mod funding_layer_config;\r\npub mod circuit_breaker;\r\npub mod utils;\r\n\r\npub use rewards_pool_config::*;\r\npub use epoch_distribution::*;\r\npub use user_claim::*;\r\npub use funding_layer_config::*;\r\npub use circuit_breaker::*;\r\npub use utils::*;\r\n\r\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","sscre-protocol","src","state","rewards_pool_config.rs"],"content":"use anchor_lang::prelude::*;\r\n\r\n/// Global rewards pool configuration\r\n#[account]\r\n#[derive(Default)]\r\npub struct RewardsPoolConfig {\r\n    /// Admin authority\r\n    pub authority: Pubkey,\r\n    /// VCoin mint\r\n    pub vcoin_mint: Pubkey,\r\n    /// Pool vault holding VCoin rewards\r\n    pub pool_vault: Pubkey,\r\n    /// 5A Protocol for score verification\r\n    pub five_a_program: Pubkey,\r\n    /// Registered oracles (max 5)\r\n    pub oracles: [Pubkey; 5],\r\n    /// Number of active oracles\r\n    pub oracle_count: u8,\r\n    /// Current epoch number\r\n    pub current_epoch: u64,\r\n    /// Total VCoin distributed all-time\r\n    pub total_distributed: u64,\r\n    /// Remaining primary reserves\r\n    pub remaining_reserves: u64,\r\n    /// Whether protocol is paused\r\n    pub paused: bool,\r\n    /// Whether circuit breaker is active\r\n    pub circuit_breaker_active: bool,\r\n    /// Fee recipient for gasless fee\r\n    pub fee_recipient: Pubkey,\r\n    /// PDA bump\r\n    pub bump: u8,\r\n    /// Vault bump\r\n    pub vault_bump: u8,\r\n}\r\n\r\nimpl RewardsPoolConfig {\r\n    pub const LEN: usize = 8 + // discriminator\r\n        32 + // authority\r\n        32 + // vcoin_mint\r\n        32 + // pool_vault\r\n        32 + // five_a_program\r\n        (32 * 5) + // oracles\r\n        1 +  // oracle_count\r\n        8 +  // current_epoch\r\n        8 +  // total_distributed\r\n        8 +  // remaining_reserves\r\n        1 +  // paused\r\n        1 +  // circuit_breaker_active\r\n        32 + // fee_recipient\r\n        1 +  // bump\r\n        1;   // vault_bump\r\n}\r\n\r\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","sscre-protocol","src","state","user_claim.rs"],"content":"use anchor_lang::prelude::*;\r\n\r\n/// User claim record (tracks all epochs claimed)\r\n#[account]\r\n#[derive(Default)]\r\npub struct UserClaim {\r\n    /// User wallet\r\n    pub user: Pubkey,\r\n    /// Last claimed epoch\r\n    pub last_claimed_epoch: u64,\r\n    /// Total VCoin claimed all-time\r\n    pub total_claimed: u64,\r\n    /// Total claims made\r\n    pub claims_count: u32,\r\n    /// First claim timestamp\r\n    pub first_claim_at: i64,\r\n    /// Last claim timestamp\r\n    pub last_claim_at: i64,\r\n    /// Bitmap of claimed epochs (last 256 epochs)\r\n    pub claimed_epochs_bitmap: [u64; 4],\r\n    /// PDA bump\r\n    pub bump: u8,\r\n}\r\n\r\nimpl UserClaim {\r\n    pub const LEN: usize = 8 + // discriminator\r\n        32 + // user\r\n        8 +  // last_claimed_epoch\r\n        8 +  // total_claimed\r\n        4 +  // claims_count\r\n        8 +  // first_claim_at\r\n        8 +  // last_claim_at\r\n        (8 * 4) + // claimed_epochs_bitmap\r\n        1;   // bump\r\n    \r\n    /// Check if a specific epoch has been claimed\r\n    pub fn is_epoch_claimed(\u0026self, epoch: u64) -\u003e bool {\r\n        if epoch \u003e 255 {\r\n            return epoch \u003c= self.last_claimed_epoch;\r\n        }\r\n        let bitmap_index = (epoch / 64) as usize;\r\n        let bit_position = epoch % 64;\r\n        if bitmap_index \u003e= 4 {\r\n            return false;\r\n        }\r\n        (self.claimed_epochs_bitmap[bitmap_index] \u0026 (1 \u003c\u003c bit_position)) != 0\r\n    }\r\n    \r\n    /// Mark an epoch as claimed\r\n    pub fn mark_epoch_claimed(\u0026mut self, epoch: u64) {\r\n        if epoch \u003c= 255 {\r\n            let bitmap_index = (epoch / 64) as usize;\r\n            let bit_position = epoch % 64;\r\n            if bitmap_index \u003c 4 {\r\n                self.claimed_epochs_bitmap[bitmap_index] |= 1 \u003c\u003c bit_position;\r\n            }\r\n        }\r\n        if epoch \u003e self.last_claimed_epoch {\r\n            self.last_claimed_epoch = epoch;\r\n        }\r\n    }\r\n}\r\n\r\n","traces":[{"line":37,"address":[],"length":0,"stats":{"Line":1441151880758558720}},{"line":38,"address":[],"length":0,"stats":{"Line":1441151880758558720}},{"line":39,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":41,"address":[],"length":0,"stats":{"Line":2594073385365405696}},{"line":42,"address":[],"length":0,"stats":{"Line":2594073385365405696}},{"line":43,"address":[],"length":0,"stats":{"Line":1297036692682702848}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":1297036692682702848}},{"line":50,"address":[],"length":0,"stats":{"Line":936748722493063168}},{"line":51,"address":[],"length":0,"stats":{"Line":936748722493063168}},{"line":52,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":53,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":54,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":55,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":58,"address":[],"length":0,"stats":{"Line":1801439850948198400}},{"line":59,"address":[],"length":0,"stats":{"Line":864691128455135232}}],"covered":15,"coverable":16},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","sscre-protocol","src","state","utils.rs"],"content":"use crate::constants::*;\r\n\r\n/// Get 5A score multiplier\r\npub fn get_five_a_multiplier(score: u16) -\u003e u64 {\r\n    if score \u003e= 8000 {\r\n        SCORE_MULT_80_100\r\n    } else if score \u003e= 6000 {\r\n        SCORE_MULT_60_80\r\n    } else if score \u003e= 4000 {\r\n        SCORE_MULT_40_60\r\n    } else if score \u003e= 2000 {\r\n        SCORE_MULT_20_40\r\n    } else {\r\n        SCORE_MULT_0_20\r\n    }\r\n}\r\n\r\n/// Compute merkle leaf from user, amount, and epoch\r\npub fn compute_leaf(user: \u0026anchor_lang::prelude::Pubkey, amount: u64, epoch: u64) -\u003e [u8; 32] {\r\n    use solana_program::keccak;\r\n    \r\n    let mut data = Vec::with_capacity(48);\r\n    data.extend_from_slice(user.as_ref());\r\n    data.extend_from_slice(\u0026amount.to_le_bytes());\r\n    data.extend_from_slice(\u0026epoch.to_le_bytes());\r\n    \r\n    keccak::hash(\u0026data).to_bytes()\r\n}\r\n\r\n/// Verify merkle proof\r\npub fn verify_merkle_proof(proof: \u0026[[u8; 32]], root: \u0026[u8; 32], leaf: \u0026[u8; 32]) -\u003e bool {\r\n    use solana_program::keccak;\r\n    \r\n    let mut computed_hash = *leaf;\r\n    \r\n    for proof_element in proof {\r\n        let (left, right) = if computed_hash \u003c *proof_element {\r\n            (computed_hash, *proof_element)\r\n        } else {\r\n            (*proof_element, computed_hash)\r\n        };\r\n        \r\n        let mut combined = [0u8; 64];\r\n        combined[..32].copy_from_slice(\u0026left);\r\n        combined[32..].copy_from_slice(\u0026right);\r\n        \r\n        computed_hash = keccak::hash(\u0026combined).to_bytes();\r\n    }\r\n    \r\n    computed_hash == *root\r\n}\r\n\r\n","traces":[{"line":4,"address":[],"length":0,"stats":{"Line":792633534417207296}},{"line":5,"address":[],"length":0,"stats":{"Line":792633534417207296}},{"line":6,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":7,"address":[],"length":0,"stats":{"Line":648518346341351424}},{"line":8,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":9,"address":[],"length":0,"stats":{"Line":504403158265495552}},{"line":10,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":11,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":12,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":14,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":19,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":22,"address":[],"length":0,"stats":{"Line":1152921504606846976}},{"line":23,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":24,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":25,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":27,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":31,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":34,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":36,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":37,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":38,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":40,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":43,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":44,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":45,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":47,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":50,"address":[],"length":0,"stats":{"Line":288230376151711744}}],"covered":27,"coverable":27},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","sscre-protocol","src","tests.rs"],"content":"//! Unit tests for SSCRE Protocol\r\n//!\r\n//! These tests run against the ACTUAL program code.\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n    use crate::constants::*;\r\n    use crate::state::{RewardsPoolConfig, EpochDistribution, UserClaim};\r\n    use crate::state::utils::{get_five_a_multiplier, compute_leaf, verify_merkle_proof};\r\n    use anchor_lang::prelude::Pubkey;\r\n    use solana_program::keccak;\r\n\r\n    // ========================================================================\r\n    // Constants Tests\r\n    // ========================================================================\r\n\r\n    #[test]\r\n    fn test_primary_reserves() {\r\n        // 350M VCoin = 350 * 10^6 * 10^9\r\n        assert_eq!(PRIMARY_RESERVES, 350_000_000 * 1_000_000_000);\r\n    }\r\n\r\n    #[test]\r\n    fn test_secondary_reserves() {\r\n        assert_eq!(SECONDARY_RESERVES, 40_000_000 * 1_000_000_000);\r\n    }\r\n\r\n    #[test]\r\n    fn test_epoch_duration() {\r\n        assert_eq!(EPOCH_DURATION, 30 * 24 * 60 * 60, \"30 days epoch\");\r\n    }\r\n\r\n    #[test]\r\n    fn test_claim_window() {\r\n        assert_eq!(CLAIM_WINDOW, 90 * 24 * 60 * 60, \"90 days claim window\");\r\n    }\r\n\r\n    #[test]\r\n    fn test_gasless_fee() {\r\n        assert_eq!(GASLESS_FEE_BPS, 100, \"1% fee\");\r\n    }\r\n\r\n    #[test]\r\n    fn test_min_claim_amount() {\r\n        assert_eq!(MIN_CLAIM_AMOUNT, 1_000_000_000, \"1 VCoin minimum\");\r\n    }\r\n\r\n    #[test]\r\n    fn test_circuit_breaker_thresholds() {\r\n        assert_eq!(MAX_EPOCH_EMISSION, 10_000_000 * 1_000_000_000, \"10M VCoin max/epoch\");\r\n        assert_eq!(MAX_SINGLE_CLAIM, 100_000 * 1_000_000_000, \"100K VCoin max/claim\");\r\n    }\r\n\r\n    // ========================================================================\r\n    // 5A Score Multiplier Tests\r\n    // ========================================================================\r\n\r\n    #[test]\r\n    fn test_five_a_multiplier_lowest() {\r\n        assert_eq!(get_five_a_multiplier(0), SCORE_MULT_0_20);\r\n        assert_eq!(get_five_a_multiplier(1000), SCORE_MULT_0_20);\r\n        assert_eq!(get_five_a_multiplier(1999), SCORE_MULT_0_20);\r\n    }\r\n\r\n    #[test]\r\n    fn test_five_a_multiplier_low() {\r\n        assert_eq!(get_five_a_multiplier(2000), SCORE_MULT_20_40);\r\n        assert_eq!(get_five_a_multiplier(3999), SCORE_MULT_20_40);\r\n    }\r\n\r\n    #[test]\r\n    fn test_five_a_multiplier_mid() {\r\n        assert_eq!(get_five_a_multiplier(4000), SCORE_MULT_40_60);\r\n        assert_eq!(get_five_a_multiplier(5999), SCORE_MULT_40_60);\r\n    }\r\n\r\n    #[test]\r\n    fn test_five_a_multiplier_high() {\r\n        assert_eq!(get_five_a_multiplier(6000), SCORE_MULT_60_80);\r\n        assert_eq!(get_five_a_multiplier(7999), SCORE_MULT_60_80);\r\n    }\r\n\r\n    #[test]\r\n    fn test_five_a_multiplier_highest() {\r\n        assert_eq!(get_five_a_multiplier(8000), SCORE_MULT_80_100);\r\n        assert_eq!(get_five_a_multiplier(10000), SCORE_MULT_80_100);\r\n    }\r\n\r\n    #[test]\r\n    fn test_multiplier_values() {\r\n        assert_eq!(SCORE_MULT_0_20, 100, \"0.1x = 10%\");\r\n        assert_eq!(SCORE_MULT_20_40, 400, \"0.4x = 40%\");\r\n        assert_eq!(SCORE_MULT_40_60, 700, \"0.7x = 70%\");\r\n        assert_eq!(SCORE_MULT_60_80, 1000, \"1.0x = 100%\");\r\n        assert_eq!(SCORE_MULT_80_100, 1200, \"1.2x = 120%\");\r\n    }\r\n\r\n    // ========================================================================\r\n    // PDA Seeds Tests\r\n    // ========================================================================\r\n\r\n    #[test]\r\n    fn test_pda_seeds() {\r\n        assert_eq!(POOL_CONFIG_SEED, b\"pool-config\");\r\n        assert_eq!(EPOCH_SEED, b\"epoch\");\r\n        assert_eq!(USER_CLAIM_SEED, b\"user-claim\");\r\n        assert_eq!(FUNDING_LAYER_SEED, b\"funding-layer\");\r\n        assert_eq!(CIRCUIT_BREAKER_SEED, b\"circuit-breaker\");\r\n    }\r\n\r\n    // ========================================================================\r\n    // State Size Tests\r\n    // ========================================================================\r\n\r\n    #[test]\r\n    fn test_rewards_pool_config_size() {\r\n        let expected = 8 + 32 + 32 + 32 + 32 + (32 * 5) + 1 + 8 + 8 + 8 + 1 + 1 + 32 + 1 + 1;\r\n        assert_eq!(RewardsPoolConfig::LEN, expected, \"Config size mismatch\");\r\n    }\r\n\r\n    #[test]\r\n    fn test_epoch_distribution_size() {\r\n        let expected = 8 + 8 + 32 + 8 + 8 + 8 + 8 + 8 + 8 + 1 + 32 + 2 + 8 + 1;\r\n        assert_eq!(EpochDistribution::LEN, expected, \"Epoch size mismatch\");\r\n    }\r\n\r\n    #[test]\r\n    fn test_user_claim_size() {\r\n        let expected = 8 + 32 + 8 + 8 + 4 + 8 + 8 + (8 * 4) + 1;\r\n        assert_eq!(UserClaim::LEN, expected, \"User claim size mismatch\");\r\n    }\r\n\r\n    // ========================================================================\r\n    // Merkle Proof Tests\r\n    // ========================================================================\r\n\r\n    #[test]\r\n    fn test_compute_leaf() {\r\n        let user = Pubkey::new_unique();\r\n        let amount = 1000u64;\r\n        let epoch = 1u64;\r\n        \r\n        let leaf = compute_leaf(\u0026user, amount, epoch);\r\n        \r\n        // Verify it's deterministic\r\n        let leaf2 = compute_leaf(\u0026user, amount, epoch);\r\n        assert_eq!(leaf, leaf2);\r\n    }\r\n\r\n    #[test]\r\n    fn test_compute_leaf_different_inputs() {\r\n        let user1 = Pubkey::new_unique();\r\n        let user2 = Pubkey::new_unique();\r\n        let amount = 1000u64;\r\n        let epoch = 1u64;\r\n        \r\n        let leaf1 = compute_leaf(\u0026user1, amount, epoch);\r\n        let leaf2 = compute_leaf(\u0026user2, amount, epoch);\r\n        \r\n        assert_ne!(leaf1, leaf2, \"Different users should have different leaves\");\r\n    }\r\n\r\n    #[test]\r\n    fn test_verify_merkle_proof_empty() {\r\n        // For a single-leaf tree, the leaf is the root\r\n        let user = Pubkey::new_unique();\r\n        let leaf = compute_leaf(\u0026user, 1000, 1);\r\n        \r\n        let proof: Vec\u003c[u8; 32]\u003e = vec![];\r\n        \r\n        // With empty proof, leaf must equal root\r\n        assert!(verify_merkle_proof(\u0026proof, \u0026leaf, \u0026leaf));\r\n    }\r\n\r\n    #[test]\r\n    fn test_verify_merkle_proof_single_sibling() {\r\n        let user1 = Pubkey::new_unique();\r\n        let user2 = Pubkey::new_unique();\r\n        \r\n        let leaf1 = compute_leaf(\u0026user1, 1000, 1);\r\n        let leaf2 = compute_leaf(\u0026user2, 2000, 1);\r\n        \r\n        // Create root from two leaves\r\n        let (left, right) = if leaf1 \u003c leaf2 { (leaf1, leaf2) } else { (leaf2, leaf1) };\r\n        let mut combined = [0u8; 64];\r\n        combined[..32].copy_from_slice(\u0026left);\r\n        combined[32..].copy_from_slice(\u0026right);\r\n        let root = keccak::hash(\u0026combined).to_bytes();\r\n        \r\n        // Verify leaf1 with proof = [leaf2]\r\n        let proof = vec![leaf2];\r\n        assert!(verify_merkle_proof(\u0026proof, \u0026root, \u0026leaf1));\r\n        \r\n        // Verify leaf2 with proof = [leaf1]\r\n        let proof2 = vec![leaf1];\r\n        assert!(verify_merkle_proof(\u0026proof2, \u0026root, \u0026leaf2));\r\n    }\r\n\r\n    #[test]\r\n    fn test_verify_merkle_proof_invalid() {\r\n        let user = Pubkey::new_unique();\r\n        let leaf = compute_leaf(\u0026user, 1000, 1);\r\n        \r\n        let fake_root = [0u8; 32];\r\n        let proof: Vec\u003c[u8; 32]\u003e = vec![];\r\n        \r\n        // Wrong root should fail\r\n        assert!(!verify_merkle_proof(\u0026proof, \u0026fake_root, \u0026leaf));\r\n    }\r\n\r\n    // ========================================================================\r\n    // User Claim Bitmap Tests\r\n    // ========================================================================\r\n\r\n    #[test]\r\n    fn test_user_claim_epoch_unclaimed() {\r\n        let claim = UserClaim::default();\r\n        \r\n        assert!(!claim.is_epoch_claimed(0));\r\n        assert!(!claim.is_epoch_claimed(1));\r\n        assert!(!claim.is_epoch_claimed(100));\r\n    }\r\n\r\n    #[test]\r\n    fn test_user_claim_mark_claimed() {\r\n        let mut claim = UserClaim::default();\r\n        \r\n        claim.mark_epoch_claimed(5);\r\n        \r\n        assert!(claim.is_epoch_claimed(5));\r\n        assert!(!claim.is_epoch_claimed(4));\r\n        assert!(!claim.is_epoch_claimed(6));\r\n    }\r\n\r\n    #[test]\r\n    fn test_user_claim_multiple_epochs() {\r\n        let mut claim = UserClaim::default();\r\n        \r\n        claim.mark_epoch_claimed(1);\r\n        claim.mark_epoch_claimed(10);\r\n        claim.mark_epoch_claimed(100);\r\n        \r\n        assert!(claim.is_epoch_claimed(1));\r\n        assert!(claim.is_epoch_claimed(10));\r\n        assert!(claim.is_epoch_claimed(100));\r\n        assert!(!claim.is_epoch_claimed(50));\r\n    }\r\n\r\n    #[test]\r\n    fn test_user_claim_bitmap_boundaries() {\r\n        let mut claim = UserClaim::default();\r\n        \r\n        // Test at bitmap boundaries (0, 63, 64, 127, 128, 191, 192, 255)\r\n        for epoch in [0u64, 63, 64, 127, 128, 191, 192, 255] {\r\n            claim.mark_epoch_claimed(epoch);\r\n            assert!(claim.is_epoch_claimed(epoch), \"Epoch {} should be claimed\", epoch);\r\n        }\r\n    }\r\n\r\n    #[test]\r\n    fn test_user_claim_large_epoch() {\r\n        let mut claim = UserClaim::default();\r\n        \r\n        // Epoch \u003e 255 uses last_claimed_epoch tracking\r\n        claim.mark_epoch_claimed(300);\r\n        \r\n        assert_eq!(claim.last_claimed_epoch, 300);\r\n        assert!(claim.is_epoch_claimed(300));\r\n        // Any epoch \u003c= 300 should be considered claimed via last_claimed_epoch\r\n        assert!(claim.is_epoch_claimed(256));\r\n    }\r\n\r\n    // ========================================================================\r\n    // Fee Calculation Tests\r\n    // ========================================================================\r\n\r\n    #[test]\r\n    fn test_gasless_fee_calculation() {\r\n        let amount = 100_000_000_000u64; // 100 VCoin\r\n        let fee = (amount as u128 * GASLESS_FEE_BPS as u128 / 10000) as u64;\r\n        let net = amount - fee;\r\n        \r\n        assert_eq!(fee, 1_000_000_000, \"1% of 100 VCoin = 1 VCoin\");\r\n        assert_eq!(net, 99_000_000_000, \"Net = 99 VCoin\");\r\n    }\r\n\r\n    #[test]\r\n    fn test_min_claim_fee() {\r\n        let amount = MIN_CLAIM_AMOUNT; // 1 VCoin\r\n        let fee = (amount as u128 * GASLESS_FEE_BPS as u128 / 10000) as u64;\r\n        \r\n        assert_eq!(fee, 10_000_000, \"1% of 1 VCoin = 0.01 VCoin\");\r\n    }\r\n\r\n    // ========================================================================\r\n    // Epoch Progression Tests\r\n    // ========================================================================\r\n\r\n    #[test]\r\n    fn test_epoch_default() {\r\n        let epoch = EpochDistribution::default();\r\n        \r\n        assert_eq!(epoch.epoch, 0);\r\n        assert_eq!(epoch.total_allocation, 0);\r\n        assert_eq!(epoch.total_claimed, 0);\r\n        assert!(!epoch.is_finalized);\r\n    }\r\n\r\n    #[test]\r\n    fn test_epoch_claim_expiry() {\r\n        let start_time = 1000i64;\r\n        let end_time = start_time + EPOCH_DURATION;\r\n        let claim_expiry = start_time + EPOCH_DURATION + CLAIM_WINDOW;\r\n        \r\n        // 30 + 90 = 120 days total\r\n        assert_eq!(claim_expiry - start_time, (30 + 90) * 24 * 60 * 60);\r\n    }\r\n\r\n    // ========================================================================\r\n    // Invariant Tests\r\n    // ========================================================================\r\n\r\n    #[test]\r\n    fn test_invariant_total_claimed_bounded() {\r\n        let epoch = EpochDistribution {\r\n            total_allocation: 1_000_000 * 1_000_000_000, // 1M VCoin\r\n            total_claimed: 500_000 * 1_000_000_000,      // 500K VCoin\r\n            ..Default::default()\r\n        };\r\n        \r\n        // total_claimed should never exceed total_allocation\r\n        assert!(epoch.total_claimed \u003c= epoch.total_allocation);\r\n    }\r\n\r\n    #[test]\r\n    fn test_invariant_circuit_breaker_limits() {\r\n        let claim_amount = 50_000u64 * 1_000_000_000; // 50K VCoin\r\n        \r\n        assert!(claim_amount \u003c MAX_SINGLE_CLAIM, \"Within single claim limit\");\r\n    }\r\n\r\n    #[test]\r\n    fn test_invariant_epoch_emission_limit() {\r\n        let epoch_emission = 5_000_000u64 * 1_000_000_000; // 5M VCoin\r\n        \r\n        assert!(epoch_emission \u003c MAX_EPOCH_EMISSION, \"Within epoch limit\");\r\n    }\r\n\r\n    // ========================================================================\r\n    // PDA Derivation Tests\r\n    // ========================================================================\r\n\r\n    #[test]\r\n    fn test_epoch_pda_unique() {\r\n        let program_id = Pubkey::new_unique();\r\n        \r\n        let (pda1, _) = Pubkey::find_program_address(\r\n            \u0026[EPOCH_SEED, \u00261u64.to_le_bytes()],\r\n            \u0026program_id\r\n        );\r\n        \r\n        let (pda2, _) = Pubkey::find_program_address(\r\n            \u0026[EPOCH_SEED, \u00262u64.to_le_bytes()],\r\n            \u0026program_id\r\n        );\r\n        \r\n        assert_ne!(pda1, pda2, \"Different epochs should have different PDAs\");\r\n    }\r\n\r\n    #[test]\r\n    fn test_user_claim_pda_unique() {\r\n        let program_id = Pubkey::new_unique();\r\n        let user1 = Pubkey::new_unique();\r\n        let user2 = Pubkey::new_unique();\r\n        \r\n        let (pda1, _) = Pubkey::find_program_address(\r\n            \u0026[USER_CLAIM_SEED, user1.as_ref()],\r\n            \u0026program_id\r\n        );\r\n        \r\n        let (pda2, _) = Pubkey::find_program_address(\r\n            \u0026[USER_CLAIM_SEED, user2.as_ref()],\r\n            \u0026program_id\r\n        );\r\n        \r\n        assert_ne!(pda1, pda2, \"Different users should have different PDAs\");\r\n    }\r\n}\r\n\r\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","sscre-protocol","tests","admin.rs"],"content":"//! Integration tests for sscre-protocol admin instructions\r\n\r\nmod common;\r\n\r\nuse common::*;\r\nuse solana_sdk::signature::{Keypair, Signer};\r\n\r\n#[tokio::test]\r\nasync fn test_set_paused_true() {\r\n    let ctx = TestContext::new().await;\r\n    \r\n    let (pool_pda, _bump) = ctx.get_pool_pda();\r\n    \r\n    let ix = create_set_paused_ix(\r\n        \u0026ctx.program_id,\r\n        \u0026ctx.payer.pubkey(),\r\n        \u0026pool_pda,\r\n        true,\r\n    );\r\n    \r\n    assert_eq!(ix.data[8], 1);\r\n}\r\n\r\n#[tokio::test]\r\nasync fn test_set_paused_false() {\r\n    let ctx = TestContext::new().await;\r\n    \r\n    let (pool_pda, _bump) = ctx.get_pool_pda();\r\n    \r\n    let ix = create_set_paused_ix(\r\n        \u0026ctx.program_id,\r\n        \u0026ctx.payer.pubkey(),\r\n        \u0026pool_pda,\r\n        false,\r\n    );\r\n    \r\n    assert_eq!(ix.data[8], 0);\r\n}\r\n\r\n#[tokio::test]\r\nasync fn test_set_paused_unauthorized() {\r\n    let ctx = TestContext::new().await;\r\n    \r\n    let (pool_pda, _bump) = ctx.get_pool_pda();\r\n    let unauthorized = Keypair::new();\r\n    \r\n    let ix = create_set_paused_ix(\r\n        \u0026ctx.program_id,\r\n        \u0026unauthorized.pubkey(),\r\n        \u0026pool_pda,\r\n        true,\r\n    );\r\n    \r\n    assert_eq!(ix.accounts[1].pubkey, unauthorized.pubkey());\r\n}\r\n\r\n#[tokio::test]\r\nasync fn test_set_paused_toggle() {\r\n    let ctx = TestContext::new().await;\r\n    \r\n    let (pool_pda, _bump) = ctx.get_pool_pda();\r\n    \r\n    for paused in [true, false, true, false] {\r\n        let ix = create_set_paused_ix(\r\n            \u0026ctx.program_id,\r\n            \u0026ctx.payer.pubkey(),\r\n            \u0026pool_pda,\r\n            paused,\r\n        );\r\n        \r\n        assert_eq!(ix.data[8], if paused { 1 } else { 0 });\r\n    }\r\n}\r\n\r\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","sscre-protocol","tests","circuit_breaker.rs"],"content":"//! Integration tests for sscre-protocol circuit breaker\r\n\r\nmod common;\r\n\r\nuse common::*;\r\nuse solana_sdk::signature::{Keypair, Signer};\r\n\r\n#[tokio::test]\r\nasync fn test_trigger_circuit_breaker_instruction_format() {\r\n    let ctx = TestContext::new().await;\r\n    \r\n    let (pool_pda, _bump) = ctx.get_pool_pda();\r\n    let (circuit_breaker_pda, _) = ctx.get_circuit_breaker_pda();\r\n    \r\n    let ix = create_trigger_circuit_breaker_ix(\r\n        \u0026ctx.program_id,\r\n        \u0026ctx.payer.pubkey(),\r\n        \u0026pool_pda,\r\n        \u0026circuit_breaker_pda,\r\n        1,\r\n    );\r\n    \r\n    assert_eq!(ix.program_id, ctx.program_id);\r\n    assert_eq!(ix.accounts.len(), 3);\r\n}\r\n\r\n#[tokio::test]\r\nasync fn test_trigger_circuit_breaker_different_reasons() {\r\n    let ctx = TestContext::new().await;\r\n    \r\n    let (pool_pda, _bump) = ctx.get_pool_pda();\r\n    let (circuit_breaker_pda, _) = ctx.get_circuit_breaker_pda();\r\n    \r\n    for reason in 0..=5 {\r\n        let ix = create_trigger_circuit_breaker_ix(\r\n            \u0026ctx.program_id,\r\n            \u0026ctx.payer.pubkey(),\r\n            \u0026pool_pda,\r\n            \u0026circuit_breaker_pda,\r\n            reason,\r\n        );\r\n        \r\n        assert_eq!(ix.data[8], reason);\r\n    }\r\n}\r\n\r\n#[tokio::test]\r\nasync fn test_trigger_circuit_breaker_unauthorized() {\r\n    let ctx = TestContext::new().await;\r\n    \r\n    let (pool_pda, _bump) = ctx.get_pool_pda();\r\n    let (circuit_breaker_pda, _) = ctx.get_circuit_breaker_pda();\r\n    let unauthorized = Keypair::new();\r\n    \r\n    let ix = create_trigger_circuit_breaker_ix(\r\n        \u0026ctx.program_id,\r\n        \u0026unauthorized.pubkey(),\r\n        \u0026pool_pda,\r\n        \u0026circuit_breaker_pda,\r\n        1,\r\n    );\r\n    \r\n    assert_eq!(ix.accounts[2].pubkey, unauthorized.pubkey());\r\n}\r\n\r\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","sscre-protocol","tests","claims.rs"],"content":"//! Integration tests for sscre-protocol claim instructions\r\n\r\nmod common;\r\n\r\nuse common::*;\r\nuse solana_sdk::signature::{Keypair, Signer};\r\n\r\n#[tokio::test]\r\nasync fn test_claim_rewards_instruction_format() {\r\n    let ctx = TestContext::new().await;\r\n    \r\n    let (pool_pda, _bump) = ctx.get_pool_pda();\r\n    let (epoch_pda, _) = ctx.get_epoch_pda(1);\r\n    let user = Keypair::new();\r\n    let (user_claim_pda, _) = ctx.get_user_claim_pda(\u0026user.pubkey());\r\n    let (circuit_breaker_pda, _) = ctx.get_circuit_breaker_pda();\r\n    let amount = 1000 * 1_000_000_000u64;\r\n    let merkle_proof = vec![[1u8; 32], [2u8; 32]];\r\n    \r\n    let ix = create_claim_rewards_ix(\r\n        \u0026ctx.program_id,\r\n        \u0026user.pubkey(),\r\n        \u0026pool_pda,\r\n        \u0026epoch_pda,\r\n        \u0026user_claim_pda,\r\n        \u0026circuit_breaker_pda,\r\n        amount,\r\n        merkle_proof,\r\n    );\r\n    \r\n    assert_eq!(ix.program_id, ctx.program_id);\r\n    assert_eq!(ix.accounts.len(), 7);\r\n}\r\n\r\n#[tokio::test]\r\nasync fn test_claim_rewards_different_amounts() {\r\n    let ctx = TestContext::new().await;\r\n    \r\n    let (pool_pda, _bump) = ctx.get_pool_pda();\r\n    let (epoch_pda, _) = ctx.get_epoch_pda(1);\r\n    let (circuit_breaker_pda, _) = ctx.get_circuit_breaker_pda();\r\n    \r\n    for amount in [1u64, 1000, 50000, 100000] {\r\n        let user = Keypair::new();\r\n        let (user_claim_pda, _) = ctx.get_user_claim_pda(\u0026user.pubkey());\r\n        let amount_with_decimals = amount * 1_000_000_000;\r\n        let merkle_proof = vec![[1u8; 32]];\r\n        \r\n        let ix = create_claim_rewards_ix(\r\n            \u0026ctx.program_id,\r\n            \u0026user.pubkey(),\r\n            \u0026pool_pda,\r\n            \u0026epoch_pda,\r\n            \u0026user_claim_pda,\r\n            \u0026circuit_breaker_pda,\r\n            amount_with_decimals,\r\n            merkle_proof,\r\n        );\r\n        \r\n        assert_eq!(\u0026ix.data[8..16], \u0026amount_with_decimals.to_le_bytes());\r\n    }\r\n}\r\n\r\n#[tokio::test]\r\nasync fn test_claim_rewards_empty_proof() {\r\n    let ctx = TestContext::new().await;\r\n    \r\n    let (pool_pda, _bump) = ctx.get_pool_pda();\r\n    let (epoch_pda, _) = ctx.get_epoch_pda(1);\r\n    let user = Keypair::new();\r\n    let (user_claim_pda, _) = ctx.get_user_claim_pda(\u0026user.pubkey());\r\n    let (circuit_breaker_pda, _) = ctx.get_circuit_breaker_pda();\r\n    let merkle_proof: Vec\u003c[u8; 32]\u003e = vec![];\r\n    \r\n    let ix = create_claim_rewards_ix(\r\n        \u0026ctx.program_id,\r\n        \u0026user.pubkey(),\r\n        \u0026pool_pda,\r\n        \u0026epoch_pda,\r\n        \u0026user_claim_pda,\r\n        \u0026circuit_breaker_pda,\r\n        1000,\r\n        merkle_proof,\r\n    );\r\n    \r\n    assert_eq!(\u0026ix.data[16..20], \u00260u32.to_le_bytes());\r\n}\r\n\r\n#[tokio::test]\r\nasync fn test_claim_rewards_deep_proof() {\r\n    let ctx = TestContext::new().await;\r\n    \r\n    let (pool_pda, _bump) = ctx.get_pool_pda();\r\n    let (epoch_pda, _) = ctx.get_epoch_pda(1);\r\n    let user = Keypair::new();\r\n    let (user_claim_pda, _) = ctx.get_user_claim_pda(\u0026user.pubkey());\r\n    let (circuit_breaker_pda, _) = ctx.get_circuit_breaker_pda();\r\n    let merkle_proof: Vec\u003c[u8; 32]\u003e = (0..20).map(|i| [i as u8; 32]).collect();\r\n    \r\n    let ix = create_claim_rewards_ix(\r\n        \u0026ctx.program_id,\r\n        \u0026user.pubkey(),\r\n        \u0026pool_pda,\r\n        \u0026epoch_pda,\r\n        \u0026user_claim_pda,\r\n        \u0026circuit_breaker_pda,\r\n        1000,\r\n        merkle_proof.clone(),\r\n    );\r\n    \r\n    assert_eq!(\u0026ix.data[16..20], \u0026(merkle_proof.len() as u32).to_le_bytes());\r\n}\r\n\r\n#[tokio::test]\r\nasync fn test_claim_rewards_multiple_users() {\r\n    let ctx = TestContext::new().await;\r\n    \r\n    let (pool_pda, _bump) = ctx.get_pool_pda();\r\n    let (epoch_pda, _) = ctx.get_epoch_pda(1);\r\n    let (circuit_breaker_pda, _) = ctx.get_circuit_breaker_pda();\r\n    \r\n    for i in 0..5 {\r\n        let user = Keypair::new();\r\n        let (user_claim_pda, _) = ctx.get_user_claim_pda(\u0026user.pubkey());\r\n        let merkle_proof = vec![[i as u8; 32]];\r\n        \r\n        let ix = create_claim_rewards_ix(\r\n            \u0026ctx.program_id,\r\n            \u0026user.pubkey(),\r\n            \u0026pool_pda,\r\n            \u0026epoch_pda,\r\n            \u0026user_claim_pda,\r\n            \u0026circuit_breaker_pda,\r\n            (i + 1) as u64 * 1000,\r\n            merkle_proof,\r\n        );\r\n        \r\n        assert!(ix.accounts[4].is_signer);\r\n    }\r\n}\r\n\r\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","sscre-protocol","tests","common","mod.rs"],"content":"//! Common test utilities for sscre-protocol integration tests\r\n\r\nuse anchor_lang::prelude::*;\r\nuse solana_program_test::*;\r\nuse solana_sdk::{\r\n    account::Account,\r\n    hash::Hash,\r\n    instruction::{AccountMeta, Instruction},\r\n    pubkey::Pubkey,\r\n    signature::{Keypair, Signer},\r\n    transaction::Transaction,\r\n};\r\n\r\npub const POOL_CONFIG_SEED: \u0026[u8] = b\"pool-config\";\r\npub const EPOCH_SEED: \u0026[u8] = b\"epoch\";\r\npub const USER_CLAIM_SEED: \u0026[u8] = b\"user-claim\";\r\npub const CIRCUIT_BREAKER_SEED: \u0026[u8] = b\"circuit-breaker\";\r\n\r\npub struct TestContext {\r\n    pub banks_client: BanksClient,\r\n    pub payer: Keypair,\r\n    pub recent_blockhash: Hash,\r\n    pub program_id: Pubkey,\r\n}\r\n\r\nimpl TestContext {\r\n    pub async fn new() -\u003e Self {\r\n        let program_id = sscre_protocol::id();\r\n        let program_test = ProgramTest::new(\r\n            \"sscre_protocol\",\r\n            program_id,\r\n            processor!(sscre_protocol::entry),\r\n        );\r\n\r\n        let (banks_client, payer, recent_blockhash) = program_test.start().await;\r\n\r\n        Self {\r\n            banks_client,\r\n            payer,\r\n            recent_blockhash,\r\n            program_id,\r\n        }\r\n    }\r\n\r\n    pub async fn refresh_blockhash(\u0026mut self) {\r\n        self.recent_blockhash = self.banks_client.get_latest_blockhash().await.unwrap();\r\n    }\r\n\r\n    pub async fn get_account(\u0026mut self, pubkey: Pubkey) -\u003e Option\u003cAccount\u003e {\r\n        self.banks_client.get_account(pubkey).await.unwrap()\r\n    }\r\n\r\n    pub fn get_pool_pda(\u0026self) -\u003e (Pubkey, u8) {\r\n        Pubkey::find_program_address(\u0026[POOL_CONFIG_SEED], \u0026self.program_id)\r\n    }\r\n\r\n    pub fn get_epoch_pda(\u0026self, epoch: u64) -\u003e (Pubkey, u8) {\r\n        Pubkey::find_program_address(\u0026[EPOCH_SEED, \u0026epoch.to_le_bytes()], \u0026self.program_id)\r\n    }\r\n\r\n    pub fn get_user_claim_pda(\u0026self, user: \u0026Pubkey) -\u003e (Pubkey, u8) {\r\n        Pubkey::find_program_address(\u0026[USER_CLAIM_SEED, user.as_ref()], \u0026self.program_id)\r\n    }\r\n\r\n    pub fn get_circuit_breaker_pda(\u0026self) -\u003e (Pubkey, u8) {\r\n        Pubkey::find_program_address(\u0026[CIRCUIT_BREAKER_SEED], \u0026self.program_id)\r\n    }\r\n\r\n    pub async fn process_transaction(\r\n        \u0026mut self,\r\n        instructions: \u0026[Instruction],\r\n        signers: \u0026[\u0026Keypair],\r\n    ) -\u003e Result\u003c(), BanksClientError\u003e {\r\n        let mut all_signers = vec![\u0026self.payer];\r\n        all_signers.extend(signers);\r\n        \r\n        let tx = Transaction::new_signed_with_payer(\r\n            instructions,\r\n            Some(\u0026self.payer.pubkey()),\r\n            \u0026all_signers,\r\n            self.recent_blockhash,\r\n        );\r\n        \r\n        let result = self.banks_client.process_transaction(tx).await;\r\n        self.refresh_blockhash().await;\r\n        result\r\n    }\r\n}\r\n\r\npub fn create_initialize_pool_ix(\r\n    program_id: \u0026Pubkey,\r\n    authority: \u0026Pubkey,\r\n    pool: \u0026Pubkey,\r\n    vcoin_mint: \u0026Pubkey,\r\n    pool_vault: \u0026Pubkey,\r\n    fee_recipient: \u0026Pubkey,\r\n) -\u003e Instruction {\r\n    let mut data = vec![0u8; 8 + 32];\r\n    let discriminator = anchor_lang::solana_program::hash::hash(b\"global:initialize_pool\").to_bytes();\r\n    data[..8].copy_from_slice(\u0026discriminator[..8]);\r\n    data[8..40].copy_from_slice(fee_recipient.as_ref());\r\n\r\n    Instruction {\r\n        program_id: *program_id,\r\n        accounts: vec![\r\n            AccountMeta::new(*pool, false),\r\n            AccountMeta::new_readonly(*vcoin_mint, false),\r\n            AccountMeta::new(*pool_vault, false),\r\n            AccountMeta::new(*authority, true),\r\n            AccountMeta::new_readonly(spl_token_2022::id(), false),\r\n            AccountMeta::new_readonly(solana_sdk::system_program::id(), false),\r\n        ],\r\n        data,\r\n    }\r\n}\r\n\r\npub fn create_start_epoch_ix(\r\n    program_id: \u0026Pubkey,\r\n    authority: \u0026Pubkey,\r\n    pool: \u0026Pubkey,\r\n    epoch: \u0026Pubkey,\r\n    circuit_breaker: \u0026Pubkey,\r\n    total_allocation: u64,\r\n) -\u003e Instruction {\r\n    let mut data = vec![0u8; 8 + 8];\r\n    let discriminator = anchor_lang::solana_program::hash::hash(b\"global:start_epoch\").to_bytes();\r\n    data[..8].copy_from_slice(\u0026discriminator[..8]);\r\n    data[8..16].copy_from_slice(\u0026total_allocation.to_le_bytes());\r\n\r\n    Instruction {\r\n        program_id: *program_id,\r\n        accounts: vec![\r\n            AccountMeta::new(*pool, false),\r\n            AccountMeta::new(*epoch, false),\r\n            AccountMeta::new(*circuit_breaker, false),\r\n            AccountMeta::new(*authority, true),\r\n            AccountMeta::new_readonly(solana_sdk::system_program::id(), false),\r\n        ],\r\n        data,\r\n    }\r\n}\r\n\r\npub fn create_claim_rewards_ix(\r\n    program_id: \u0026Pubkey,\r\n    user: \u0026Pubkey,\r\n    pool: \u0026Pubkey,\r\n    epoch: \u0026Pubkey,\r\n    user_claim: \u0026Pubkey,\r\n    circuit_breaker: \u0026Pubkey,\r\n    amount: u64,\r\n    merkle_proof: Vec\u003c[u8; 32]\u003e,\r\n) -\u003e Instruction {\r\n    let proof_len = merkle_proof.len();\r\n    let mut data = vec![0u8; 8 + 8 + 4 + proof_len * 32];\r\n    let discriminator = anchor_lang::solana_program::hash::hash(b\"global:claim_rewards\").to_bytes();\r\n    data[..8].copy_from_slice(\u0026discriminator[..8]);\r\n    data[8..16].copy_from_slice(\u0026amount.to_le_bytes());\r\n    data[16..20].copy_from_slice(\u0026(proof_len as u32).to_le_bytes());\r\n    for (i, proof) in merkle_proof.iter().enumerate() {\r\n        data[20 + i * 32..20 + (i + 1) * 32].copy_from_slice(proof);\r\n    }\r\n\r\n    Instruction {\r\n        program_id: *program_id,\r\n        accounts: vec![\r\n            AccountMeta::new(*pool, false),\r\n            AccountMeta::new(*epoch, false),\r\n            AccountMeta::new(*user_claim, false),\r\n            AccountMeta::new(*circuit_breaker, false),\r\n            AccountMeta::new(*user, true),\r\n            AccountMeta::new_readonly(spl_token_2022::id(), false),\r\n            AccountMeta::new_readonly(solana_sdk::system_program::id(), false),\r\n        ],\r\n        data,\r\n    }\r\n}\r\n\r\npub fn create_trigger_circuit_breaker_ix(\r\n    program_id: \u0026Pubkey,\r\n    authority: \u0026Pubkey,\r\n    pool: \u0026Pubkey,\r\n    circuit_breaker: \u0026Pubkey,\r\n    reason: u8,\r\n) -\u003e Instruction {\r\n    let mut data = vec![0u8; 8 + 1];\r\n    let discriminator = anchor_lang::solana_program::hash::hash(b\"global:trigger_circuit_breaker\").to_bytes();\r\n    data[..8].copy_from_slice(\u0026discriminator[..8]);\r\n    data[8] = reason;\r\n\r\n    Instruction {\r\n        program_id: *program_id,\r\n        accounts: vec![\r\n            AccountMeta::new(*pool, false),\r\n            AccountMeta::new(*circuit_breaker, false),\r\n            AccountMeta::new(*authority, true),\r\n        ],\r\n        data,\r\n    }\r\n}\r\n\r\npub fn create_set_paused_ix(\r\n    program_id: \u0026Pubkey,\r\n    authority: \u0026Pubkey,\r\n    pool: \u0026Pubkey,\r\n    paused: bool,\r\n) -\u003e Instruction {\r\n    let mut data = vec![0u8; 8 + 1];\r\n    let discriminator = anchor_lang::solana_program::hash::hash(b\"global:set_paused\").to_bytes();\r\n    data[..8].copy_from_slice(\u0026discriminator[..8]);\r\n    data[8] = if paused { 1 } else { 0 };\r\n\r\n    Instruction {\r\n        program_id: *program_id,\r\n        accounts: vec![\r\n            AccountMeta::new(*pool, false),\r\n            AccountMeta::new(*authority, true),\r\n        ],\r\n        data,\r\n    }\r\n}\r\n\r\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","sscre-protocol","tests","epoch.rs"],"content":"//! Integration tests for sscre-protocol epoch instructions\r\n\r\nmod common;\r\n\r\nuse common::*;\r\nuse solana_sdk::signature::{Keypair, Signer};\r\n\r\n#[tokio::test]\r\nasync fn test_start_epoch_instruction_format() {\r\n    let ctx = TestContext::new().await;\r\n    \r\n    let (pool_pda, _bump) = ctx.get_pool_pda();\r\n    let (epoch_pda, _) = ctx.get_epoch_pda(1);\r\n    let (circuit_breaker_pda, _) = ctx.get_circuit_breaker_pda();\r\n    let allocation = 1_000_000 * 1_000_000_000u64;\r\n    \r\n    let ix = create_start_epoch_ix(\r\n        \u0026ctx.program_id,\r\n        \u0026ctx.payer.pubkey(),\r\n        \u0026pool_pda,\r\n        \u0026epoch_pda,\r\n        \u0026circuit_breaker_pda,\r\n        allocation,\r\n    );\r\n    \r\n    assert_eq!(ix.program_id, ctx.program_id);\r\n    assert_eq!(ix.accounts.len(), 5);\r\n}\r\n\r\n#[tokio::test]\r\nasync fn test_start_epoch_different_allocations() {\r\n    let ctx = TestContext::new().await;\r\n    \r\n    let (pool_pda, _bump) = ctx.get_pool_pda();\r\n    let (circuit_breaker_pda, _) = ctx.get_circuit_breaker_pda();\r\n    \r\n    for (i, allocation) in [1_000_000u64, 5_000_000, 10_000_000].iter().enumerate() {\r\n        let (epoch_pda, _) = ctx.get_epoch_pda(i as u64 + 1);\r\n        let allocation_with_decimals = allocation * 1_000_000_000;\r\n        \r\n        let ix = create_start_epoch_ix(\r\n            \u0026ctx.program_id,\r\n            \u0026ctx.payer.pubkey(),\r\n            \u0026pool_pda,\r\n            \u0026epoch_pda,\r\n            \u0026circuit_breaker_pda,\r\n            allocation_with_decimals,\r\n        );\r\n        \r\n        assert_eq!(\u0026ix.data[8..16], \u0026allocation_with_decimals.to_le_bytes());\r\n    }\r\n}\r\n\r\n#[tokio::test]\r\nasync fn test_start_epoch_zero_allocation() {\r\n    let ctx = TestContext::new().await;\r\n    \r\n    let (pool_pda, _bump) = ctx.get_pool_pda();\r\n    let (epoch_pda, _) = ctx.get_epoch_pda(1);\r\n    let (circuit_breaker_pda, _) = ctx.get_circuit_breaker_pda();\r\n    \r\n    let ix = create_start_epoch_ix(\r\n        \u0026ctx.program_id,\r\n        \u0026ctx.payer.pubkey(),\r\n        \u0026pool_pda,\r\n        \u0026epoch_pda,\r\n        \u0026circuit_breaker_pda,\r\n        0,\r\n    );\r\n    \r\n    assert_eq!(\u0026ix.data[8..16], \u00260u64.to_le_bytes());\r\n}\r\n\r\n#[tokio::test]\r\nasync fn test_start_epoch_max_allocation() {\r\n    let ctx = TestContext::new().await;\r\n    \r\n    let (pool_pda, _bump) = ctx.get_pool_pda();\r\n    let (epoch_pda, _) = ctx.get_epoch_pda(1);\r\n    let (circuit_breaker_pda, _) = ctx.get_circuit_breaker_pda();\r\n    let max_allocation = 10_000_000 * 1_000_000_000u64; // Max epoch emission\r\n    \r\n    let ix = create_start_epoch_ix(\r\n        \u0026ctx.program_id,\r\n        \u0026ctx.payer.pubkey(),\r\n        \u0026pool_pda,\r\n        \u0026epoch_pda,\r\n        \u0026circuit_breaker_pda,\r\n        max_allocation,\r\n    );\r\n    \r\n    assert_eq!(\u0026ix.data[8..16], \u0026max_allocation.to_le_bytes());\r\n}\r\n\r\n#[tokio::test]\r\nasync fn test_start_epoch_sequential() {\r\n    let ctx = TestContext::new().await;\r\n    \r\n    let (pool_pda, _bump) = ctx.get_pool_pda();\r\n    let (circuit_breaker_pda, _) = ctx.get_circuit_breaker_pda();\r\n    \r\n    for epoch_num in 1..=5 {\r\n        let (epoch_pda, _) = ctx.get_epoch_pda(epoch_num);\r\n        \r\n        let ix = create_start_epoch_ix(\r\n            \u0026ctx.program_id,\r\n            \u0026ctx.payer.pubkey(),\r\n            \u0026pool_pda,\r\n            \u0026epoch_pda,\r\n            \u0026circuit_breaker_pda,\r\n            1_000_000 * 1_000_000_000,\r\n        );\r\n        \r\n        assert_eq!(ix.accounts[1].pubkey, epoch_pda);\r\n    }\r\n}\r\n\r\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","sscre-protocol","tests","initialize.rs"],"content":"//! Integration tests for sscre-protocol initialize instructions\r\n\r\nmod common;\r\n\r\nuse common::*;\r\nuse solana_sdk::signature::{Keypair, Signer};\r\n\r\n#[tokio::test]\r\nasync fn test_initialize_pool_instruction_format() {\r\n    let ctx = TestContext::new().await;\r\n    \r\n    let (pool_pda, _bump) = ctx.get_pool_pda();\r\n    let vcoin_mint = Keypair::new();\r\n    let pool_vault = Keypair::new();\r\n    let fee_recipient = Keypair::new();\r\n    \r\n    let ix = create_initialize_pool_ix(\r\n        \u0026ctx.program_id,\r\n        \u0026ctx.payer.pubkey(),\r\n        \u0026pool_pda,\r\n        \u0026vcoin_mint.pubkey(),\r\n        \u0026pool_vault.pubkey(),\r\n        \u0026fee_recipient.pubkey(),\r\n    );\r\n    \r\n    assert_eq!(ix.program_id, ctx.program_id);\r\n    assert_eq!(ix.accounts.len(), 6);\r\n}\r\n\r\n#[tokio::test]\r\nasync fn test_initialize_pool_with_fee_recipient() {\r\n    let ctx = TestContext::new().await;\r\n    \r\n    let (pool_pda, _bump) = ctx.get_pool_pda();\r\n    let vcoin_mint = Keypair::new();\r\n    let pool_vault = Keypair::new();\r\n    let fee_recipient = Keypair::new();\r\n    \r\n    let ix = create_initialize_pool_ix(\r\n        \u0026ctx.program_id,\r\n        \u0026ctx.payer.pubkey(),\r\n        \u0026pool_pda,\r\n        \u0026vcoin_mint.pubkey(),\r\n        \u0026pool_vault.pubkey(),\r\n        \u0026fee_recipient.pubkey(),\r\n    );\r\n    \r\n    assert_eq!(\u0026ix.data[8..40], fee_recipient.pubkey().as_ref());\r\n}\r\n\r\n#[tokio::test]\r\nasync fn test_initialize_pool_different_authorities() {\r\n    let ctx = TestContext::new().await;\r\n    \r\n    let (pool_pda, _bump) = ctx.get_pool_pda();\r\n    let vcoin_mint = Keypair::new();\r\n    let pool_vault = Keypair::new();\r\n    \r\n    for _ in 0..3 {\r\n        let fee_recipient = Keypair::new();\r\n        \r\n        let ix = create_initialize_pool_ix(\r\n            \u0026ctx.program_id,\r\n            \u0026ctx.payer.pubkey(),\r\n            \u0026pool_pda,\r\n            \u0026vcoin_mint.pubkey(),\r\n            \u0026pool_vault.pubkey(),\r\n            \u0026fee_recipient.pubkey(),\r\n        );\r\n        \r\n        assert!(ix.data.len() \u003e 8);\r\n    }\r\n}\r\n\r\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","staking-protocol","src","constants.rs"],"content":"/// Staking Protocol Constants\r\n\r\n/// Tier thresholds in base units (9 decimals)\r\npub const BRONZE_THRESHOLD: u64 = 1_000 * 1_000_000_000;      // 1,000 VCoin\r\npub const SILVER_THRESHOLD: u64 = 5_000 * 1_000_000_000;      // 5,000 VCoin\r\npub const GOLD_THRESHOLD: u64 = 20_000 * 1_000_000_000;       // 20,000 VCoin\r\npub const PLATINUM_THRESHOLD: u64 = 100_000 * 1_000_000_000;  // 100,000 VCoin\r\n\r\n/// Lock duration limits in seconds\r\npub const MIN_LOCK_DURATION: i64 = 7 * 24 * 60 * 60;          // 1 week\r\npub const MAX_LOCK_DURATION: i64 = 4 * 365 * 24 * 60 * 60;    // 4 years\r\npub const FOUR_YEARS_SECONDS: i64 = 4 * 365 * 24 * 60 * 60;   // 4 years\r\n\r\n/// Tier boost multipliers (x1000 for precision)\r\npub const TIER_BOOST_NONE: u64 = 1000;     // 1.0x\r\npub const TIER_BOOST_BRONZE: u64 = 1100;   // 1.1x\r\npub const TIER_BOOST_SILVER: u64 = 1200;   // 1.2x\r\npub const TIER_BOOST_GOLD: u64 = 1300;     // 1.3x\r\npub const TIER_BOOST_PLATINUM: u64 = 1400; // 1.4x\r\n\r\n/// Fee discount basis points\r\npub const FEE_DISCOUNT_NONE: u16 = 0;       // 0%\r\npub const FEE_DISCOUNT_BRONZE: u16 = 1000;  // 10%\r\npub const FEE_DISCOUNT_SILVER: u16 = 2000;  // 20%\r\npub const FEE_DISCOUNT_GOLD: u16 = 3000;    // 30%\r\npub const FEE_DISCOUNT_PLATINUM: u16 = 5000;// 50%\r\n\r\n/// PDA Seeds\r\npub const STAKING_POOL_SEED: \u0026[u8] = b\"staking-pool\";\r\npub const USER_STAKE_SEED: \u0026[u8] = b\"user-stake\";\r\npub const POOL_VAULT_SEED: \u0026[u8] = b\"pool-vault\";\r\n\r\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","staking-protocol","src","contexts","admin_action.rs"],"content":"use anchor_lang::prelude::*;\r\n\r\nuse crate::constants::STAKING_POOL_SEED;\r\nuse crate::state::StakingPool;\r\n\r\n#[derive(Accounts)]\r\npub struct AdminAction\u003c'info\u003e {\r\n    pub authority: Signer\u003c'info\u003e,\r\n    \r\n    #[account(\r\n        mut,\r\n        seeds = [STAKING_POOL_SEED],\r\n        bump\r\n    )]\r\n    pub pool: Account\u003c'info, StakingPool\u003e,\r\n}\r\n\r\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","staking-protocol","src","contexts","extend_lock.rs"],"content":"use anchor_lang::prelude::*;\r\n\r\nuse crate::constants::USER_STAKE_SEED;\r\nuse crate::state::UserStake;\r\n\r\n#[derive(Accounts)]\r\npub struct ExtendLock\u003c'info\u003e {\r\n    pub user: Signer\u003c'info\u003e,\r\n    \r\n    #[account(\r\n        mut,\r\n        seeds = [USER_STAKE_SEED, user.key().as_ref()],\r\n        bump,\r\n        constraint = user_stake.owner == user.key()\r\n    )]\r\n    pub user_stake: Account\u003c'info, UserStake\u003e,\r\n}\r\n\r\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","staking-protocol","src","contexts","get_stake_info.rs"],"content":"use anchor_lang::prelude::*;\r\n\r\nuse crate::constants::USER_STAKE_SEED;\r\nuse crate::state::UserStake;\r\n\r\n#[derive(Accounts)]\r\npub struct GetStakeInfo\u003c'info\u003e {\r\n    /// CHECK: Just for PDA derivation\r\n    pub user: UncheckedAccount\u003c'info\u003e,\r\n    \r\n    #[account(\r\n        seeds = [USER_STAKE_SEED, user.key().as_ref()],\r\n        bump\r\n    )]\r\n    pub user_stake: Account\u003c'info, UserStake\u003e,\r\n}\r\n\r\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","staking-protocol","src","contexts","initialize_pool.rs"],"content":"use anchor_lang::prelude::*;\r\nuse anchor_spl::token_2022::Token2022;\r\nuse anchor_spl::token_interface::{Mint, TokenAccount};\r\n\r\nuse crate::constants::{STAKING_POOL_SEED, POOL_VAULT_SEED};\r\nuse crate::state::StakingPool;\r\n\r\n#[derive(Accounts)]\r\npub struct InitializePool\u003c'info\u003e {\r\n    #[account(mut)]\r\n    pub authority: Signer\u003c'info\u003e,\r\n    \r\n    #[account(\r\n        init,\r\n        payer = authority,\r\n        space = StakingPool::LEN,\r\n        seeds = [STAKING_POOL_SEED],\r\n        bump\r\n    )]\r\n    pub pool: Account\u003c'info, StakingPool\u003e,\r\n    \r\n    /// VCoin mint\r\n    pub vcoin_mint: InterfaceAccount\u003c'info, Mint\u003e,\r\n    \r\n    /// veVCoin mint\r\n    pub vevcoin_mint: InterfaceAccount\u003c'info, Mint\u003e,\r\n    \r\n    /// Pool vault for staked VCoin\r\n    #[account(\r\n        init,\r\n        payer = authority,\r\n        seeds = [POOL_VAULT_SEED],\r\n        bump,\r\n        token::mint = vcoin_mint,\r\n        token::authority = pool,\r\n        token::token_program = token_program,\r\n    )]\r\n    pub pool_vault: InterfaceAccount\u003c'info, TokenAccount\u003e,\r\n    \r\n    pub token_program: Program\u003c'info, Token2022\u003e,\r\n    pub system_program: Program\u003c'info, System\u003e,\r\n}\r\n\r\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","staking-protocol","src","contexts","mod.rs"],"content":"/// Contexts module - Account validation structures\r\nmod initialize_pool;\r\nmod stake;\r\nmod extend_lock;\r\nmod unstake;\r\nmod update_tier;\r\nmod admin_action;\r\nmod get_stake_info;\r\n\r\npub use initialize_pool::*;\r\npub use stake::*;\r\npub use extend_lock::*;\r\npub use unstake::*;\r\npub use update_tier::*;\r\npub use admin_action::*;\r\npub use get_stake_info::*;\r\n\r\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","staking-protocol","src","contexts","stake.rs"],"content":"use anchor_lang::prelude::*;\r\nuse anchor_spl::token_2022::Token2022;\r\nuse anchor_spl::token_interface::{Mint, TokenAccount};\r\n\r\nuse crate::constants::{STAKING_POOL_SEED, USER_STAKE_SEED, POOL_VAULT_SEED};\r\nuse crate::errors::StakingError;\r\nuse crate::state::{StakingPool, UserStake};\r\n\r\n#[derive(Accounts)]\r\npub struct Stake\u003c'info\u003e {\r\n    #[account(mut)]\r\n    pub user: Signer\u003c'info\u003e,\r\n    \r\n    #[account(\r\n        mut,\r\n        seeds = [STAKING_POOL_SEED],\r\n        bump\r\n    )]\r\n    pub pool: Account\u003c'info, StakingPool\u003e,\r\n    \r\n    #[account(\r\n        init_if_needed,\r\n        payer = user,\r\n        space = UserStake::LEN,\r\n        seeds = [USER_STAKE_SEED, user.key().as_ref()],\r\n        bump\r\n    )]\r\n    pub user_stake: Account\u003c'info, UserStake\u003e,\r\n    \r\n    /// VCoin mint\r\n    #[account(constraint = vcoin_mint.key() == pool.vcoin_mint @ StakingError::InvalidMint)]\r\n    pub vcoin_mint: InterfaceAccount\u003c'info, Mint\u003e,\r\n    \r\n    /// User's VCoin token account - MUST be owned by user and use VCoin mint\r\n    #[account(\r\n        mut,\r\n        constraint = user_vcoin_account.owner == user.key() @ StakingError::InvalidTokenAccount,\r\n        constraint = user_vcoin_account.mint == pool.vcoin_mint @ StakingError::InvalidMint\r\n    )]\r\n    pub user_vcoin_account: InterfaceAccount\u003c'info, TokenAccount\u003e,\r\n    \r\n    /// Pool vault for staked VCoin\r\n    #[account(\r\n        mut,\r\n        seeds = [POOL_VAULT_SEED],\r\n        bump,\r\n        constraint = pool_vault.mint == pool.vcoin_mint @ StakingError::InvalidMint\r\n    )]\r\n    pub pool_vault: InterfaceAccount\u003c'info, TokenAccount\u003e,\r\n    \r\n    pub token_program: Program\u003c'info, Token2022\u003e,\r\n    pub system_program: Program\u003c'info, System\u003e,\r\n}\r\n\r\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","staking-protocol","src","contexts","unstake.rs"],"content":"use anchor_lang::prelude::*;\r\nuse anchor_spl::token_2022::Token2022;\r\nuse anchor_spl::token_interface::{Mint, TokenAccount};\r\n\r\nuse crate::constants::{STAKING_POOL_SEED, USER_STAKE_SEED, POOL_VAULT_SEED};\r\nuse crate::errors::StakingError;\r\nuse crate::state::{StakingPool, UserStake};\r\n\r\n#[derive(Accounts)]\r\npub struct Unstake\u003c'info\u003e {\r\n    #[account(mut)]\r\n    pub user: Signer\u003c'info\u003e,\r\n    \r\n    #[account(\r\n        mut,\r\n        seeds = [STAKING_POOL_SEED],\r\n        bump\r\n    )]\r\n    pub pool: Account\u003c'info, StakingPool\u003e,\r\n    \r\n    #[account(\r\n        mut,\r\n        seeds = [USER_STAKE_SEED, user.key().as_ref()],\r\n        bump,\r\n        constraint = user_stake.owner == user.key()\r\n    )]\r\n    pub user_stake: Account\u003c'info, UserStake\u003e,\r\n    \r\n    /// VCoin mint\r\n    #[account(constraint = vcoin_mint.key() == pool.vcoin_mint @ StakingError::InvalidMint)]\r\n    pub vcoin_mint: InterfaceAccount\u003c'info, Mint\u003e,\r\n    \r\n    /// User's VCoin token account - MUST be owned by user and use VCoin mint\r\n    #[account(\r\n        mut,\r\n        constraint = user_vcoin_account.owner == user.key() @ StakingError::InvalidTokenAccount,\r\n        constraint = user_vcoin_account.mint == pool.vcoin_mint @ StakingError::InvalidMint\r\n    )]\r\n    pub user_vcoin_account: InterfaceAccount\u003c'info, TokenAccount\u003e,\r\n    \r\n    /// Pool vault\r\n    #[account(\r\n        mut,\r\n        seeds = [POOL_VAULT_SEED],\r\n        bump,\r\n        constraint = pool_vault.mint == pool.vcoin_mint @ StakingError::InvalidMint\r\n    )]\r\n    pub pool_vault: InterfaceAccount\u003c'info, TokenAccount\u003e,\r\n    \r\n    pub token_program: Program\u003c'info, Token2022\u003e,\r\n}\r\n\r\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","staking-protocol","src","contexts","update_tier.rs"],"content":"use anchor_lang::prelude::*;\r\n\r\nuse crate::constants::USER_STAKE_SEED;\r\nuse crate::state::UserStake;\r\n\r\n#[derive(Accounts)]\r\npub struct UpdateTier\u003c'info\u003e {\r\n    pub user: Signer\u003c'info\u003e,\r\n    \r\n    #[account(\r\n        mut,\r\n        seeds = [USER_STAKE_SEED, user.key().as_ref()],\r\n        bump,\r\n        constraint = user_stake.owner == user.key()\r\n    )]\r\n    pub user_stake: Account\u003c'info, UserStake\u003e,\r\n}\r\n\r\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","staking-protocol","src","errors.rs"],"content":"use anchor_lang::prelude::*;\r\n\r\n/// Staking Protocol Error Codes\r\n#[error_code]\r\npub enum StakingError {\r\n    #[msg(\"Unauthorized: Only the authority can perform this action\")]\r\n    Unauthorized,\r\n    \r\n    #[msg(\"Staking pool is paused\")]\r\n    PoolPaused,\r\n    \r\n    #[msg(\"Cannot stake zero tokens\")]\r\n    ZeroStakeAmount,\r\n    \r\n    #[msg(\"Lock duration below minimum (1 week)\")]\r\n    LockDurationTooShort,\r\n    \r\n    #[msg(\"Lock duration exceeds maximum (4 years)\")]\r\n    LockDurationTooLong,\r\n    \r\n    #[msg(\"Tokens are still locked\")]\r\n    TokensStillLocked,\r\n    \r\n    #[msg(\"Cannot unstake more than staked amount\")]\r\n    InsufficientStake,\r\n    \r\n    #[msg(\"Cannot extend lock to a shorter duration\")]\r\n    CannotShortenLock,\r\n    \r\n    #[msg(\"New lock end must be after current lock end\")]\r\n    InvalidLockExtension,\r\n    \r\n    #[msg(\"Arithmetic overflow\")]\r\n    Overflow,\r\n    \r\n    #[msg(\"User has no active stake\")]\r\n    NoActiveStake,\r\n    \r\n    #[msg(\"Invalid token account owner\")]\r\n    InvalidTokenAccount,\r\n    \r\n    #[msg(\"Invalid token mint\")]\r\n    InvalidMint,\r\n}\r\n\r\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","staking-protocol","src","instructions","admin","initialize_pool.rs"],"content":"use anchor_lang::prelude::*;\r\n\r\nuse crate::contexts::InitializePool;\r\n\r\n/// Initialize the staking pool\r\npub fn handler(ctx: Context\u003cInitializePool\u003e, vevcoin_program: Pubkey) -\u003e Result\u003c()\u003e {\r\n    let pool = \u0026mut ctx.accounts.pool;\r\n    \r\n    pool.authority = ctx.accounts.authority.key();\r\n    pool.vcoin_mint = ctx.accounts.vcoin_mint.key();\r\n    pool.vevcoin_mint = ctx.accounts.vevcoin_mint.key();\r\n    pool.vevcoin_program = vevcoin_program;\r\n    pool.pool_vault = ctx.accounts.pool_vault.key();\r\n    pool.total_staked = 0;\r\n    pool.total_stakers = 0;\r\n    pool.paused = false;\r\n    pool.bump = ctx.bumps.pool;\r\n    pool.vault_bump = ctx.bumps.pool_vault;\r\n    \r\n    msg!(\"Staking pool initialized\");\r\n    msg!(\"VCoin Mint: {}\", pool.vcoin_mint);\r\n    msg!(\"veVCoin Mint: {}\", pool.vevcoin_mint);\r\n    \r\n    Ok(())\r\n}\r\n\r\n","traces":[{"line":6,"address":[],"length":0,"stats":{"Line":0}},{"line":7,"address":[],"length":0,"stats":{"Line":0}},{"line":9,"address":[],"length":0,"stats":{"Line":0}},{"line":10,"address":[],"length":0,"stats":{"Line":0}},{"line":11,"address":[],"length":0,"stats":{"Line":0}},{"line":12,"address":[],"length":0,"stats":{"Line":0}},{"line":13,"address":[],"length":0,"stats":{"Line":0}},{"line":14,"address":[],"length":0,"stats":{"Line":0}},{"line":15,"address":[],"length":0,"stats":{"Line":0}},{"line":16,"address":[],"length":0,"stats":{"Line":0}},{"line":17,"address":[],"length":0,"stats":{"Line":0}},{"line":18,"address":[],"length":0,"stats":{"Line":0}},{"line":20,"address":[],"length":0,"stats":{"Line":0}},{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":16},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","staking-protocol","src","instructions","admin","mod.rs"],"content":"/// Admin instructions\r\npub mod initialize_pool;\r\npub mod set_paused;\r\npub mod update_authority;\r\n\r\npub use initialize_pool::*;\r\npub use set_paused::*;\r\npub use update_authority::*;\r\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","staking-protocol","src","instructions","admin","set_paused.rs"],"content":"use anchor_lang::prelude::*;\r\n\r\nuse crate::contexts::AdminAction;\r\nuse crate::errors::StakingError;\r\n\r\n/// Pause/unpause the staking pool\r\npub fn handler(ctx: Context\u003cAdminAction\u003e, paused: bool) -\u003e Result\u003c()\u003e {\r\n    let pool = \u0026mut ctx.accounts.pool;\r\n    \r\n    require!(\r\n        ctx.accounts.authority.key() == pool.authority,\r\n        StakingError::Unauthorized\r\n    );\r\n    \r\n    pool.paused = paused;\r\n    \r\n    msg!(\"Pool paused status: {}\", paused);\r\n    \r\n    Ok(())\r\n}\r\n\r\n","traces":[{"line":7,"address":[],"length":0,"stats":{"Line":0}},{"line":8,"address":[],"length":0,"stats":{"Line":0}},{"line":10,"address":[],"length":0,"stats":{"Line":0}},{"line":11,"address":[],"length":0,"stats":{"Line":0}},{"line":12,"address":[],"length":0,"stats":{"Line":0}},{"line":15,"address":[],"length":0,"stats":{"Line":0}},{"line":17,"address":[],"length":0,"stats":{"Line":0}},{"line":19,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":8},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","staking-protocol","src","instructions","admin","update_authority.rs"],"content":"use anchor_lang::prelude::*;\r\n\r\nuse crate::contexts::AdminAction;\r\nuse crate::errors::StakingError;\r\n\r\n/// Update the pool authority\r\npub fn handler(ctx: Context\u003cAdminAction\u003e, new_authority: Pubkey) -\u003e Result\u003c()\u003e {\r\n    let pool = \u0026mut ctx.accounts.pool;\r\n    \r\n    require!(\r\n        ctx.accounts.authority.key() == pool.authority,\r\n        StakingError::Unauthorized\r\n    );\r\n    \r\n    pool.authority = new_authority;\r\n    \r\n    msg!(\"Authority updated to: {}\", new_authority);\r\n    \r\n    Ok(())\r\n}\r\n\r\n","traces":[{"line":7,"address":[],"length":0,"stats":{"Line":0}},{"line":8,"address":[],"length":0,"stats":{"Line":0}},{"line":10,"address":[],"length":0,"stats":{"Line":0}},{"line":11,"address":[],"length":0,"stats":{"Line":0}},{"line":12,"address":[],"length":0,"stats":{"Line":0}},{"line":15,"address":[],"length":0,"stats":{"Line":0}},{"line":17,"address":[],"length":0,"stats":{"Line":0}},{"line":19,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":8},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","staking-protocol","src","instructions","mod.rs"],"content":"/// Instructions module - Instruction handlers\r\npub mod admin;\r\npub mod user;\r\npub mod query;\r\n\r\npub use admin::*;\r\npub use user::*;\r\npub use query::*;\r\n\r\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","staking-protocol","src","instructions","query","get_stake_info.rs"],"content":"use anchor_lang::prelude::*;\r\n\r\nuse crate::contexts::GetStakeInfo;\r\nuse crate::state::StakingTier;\r\n\r\n/// Return type for get_stake_info\r\n#[derive(AnchorSerialize, AnchorDeserialize)]\r\npub struct UserStakeInfo {\r\n    pub staked_amount: u64,\r\n    pub lock_end: i64,\r\n    pub tier: u8,\r\n    pub ve_vcoin_amount: u64,\r\n    pub is_locked: bool,\r\n    pub fee_discount_bps: u16,\r\n}\r\n\r\n/// Get user's staking info (view function)\r\npub fn handler(ctx: Context\u003cGetStakeInfo\u003e) -\u003e Result\u003cUserStakeInfo\u003e {\r\n    let user_stake = \u0026ctx.accounts.user_stake;\r\n    let clock = Clock::get()?;\r\n    \r\n    Ok(UserStakeInfo {\r\n        staked_amount: user_stake.staked_amount,\r\n        lock_end: user_stake.lock_end,\r\n        tier: user_stake.tier,\r\n        ve_vcoin_amount: user_stake.ve_vcoin_amount,\r\n        is_locked: clock.unix_timestamp \u003c user_stake.lock_end,\r\n        fee_discount_bps: StakingTier::from_amount(user_stake.staked_amount).fee_discount_bps(),\r\n    })\r\n}\r\n\r\n","traces":[{"line":18,"address":[],"length":0,"stats":{"Line":0}},{"line":19,"address":[],"length":0,"stats":{"Line":0}},{"line":20,"address":[],"length":0,"stats":{"Line":0}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":10},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","staking-protocol","src","instructions","query","mod.rs"],"content":"/// Query instructions\r\npub mod get_stake_info;\r\n\r\npub use get_stake_info::*;\r\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","staking-protocol","src","instructions","user","extend_lock.rs"],"content":"use anchor_lang::prelude::*;\r\n\r\nuse crate::constants::{MIN_LOCK_DURATION, MAX_LOCK_DURATION};\r\nuse crate::contexts::ExtendLock;\r\nuse crate::errors::StakingError;\r\nuse crate::state::StakingTier;\r\nuse crate::utils::calculate_vevcoin;\r\n\r\n/// Extend lock duration to increase veVCoin\r\npub fn handler(ctx: Context\u003cExtendLock\u003e, new_lock_duration: i64) -\u003e Result\u003c()\u003e {\r\n    let user_stake = \u0026mut ctx.accounts.user_stake;\r\n    \r\n    require!(user_stake.staked_amount \u003e 0, StakingError::NoActiveStake);\r\n    require!(new_lock_duration \u003e= MIN_LOCK_DURATION, StakingError::LockDurationTooShort);\r\n    require!(new_lock_duration \u003c= MAX_LOCK_DURATION, StakingError::LockDurationTooLong);\r\n    \r\n    let clock = Clock::get()?;\r\n    let now = clock.unix_timestamp;\r\n    \r\n    // Calculate new lock end\r\n    let new_lock_end = now.checked_add(new_lock_duration).ok_or(StakingError::Overflow)?;\r\n    \r\n    // New lock end must be after current lock end\r\n    require!(new_lock_end \u003e user_stake.lock_end, StakingError::CannotShortenLock);\r\n    \r\n    // Calculate new veVCoin\r\n    let tier = StakingTier::from_amount(user_stake.staked_amount);\r\n    let old_vevcoin = user_stake.ve_vcoin_amount;\r\n    let new_vevcoin = calculate_vevcoin(user_stake.staked_amount, new_lock_duration, tier)?;\r\n    let vevcoin_to_mint = new_vevcoin.checked_sub(old_vevcoin).unwrap_or(0);\r\n    \r\n    // Update stake\r\n    user_stake.lock_duration = new_lock_duration;\r\n    user_stake.lock_end = new_lock_end;\r\n    user_stake.ve_vcoin_amount = new_vevcoin;\r\n    \r\n    msg!(\"Extended lock to {} seconds\", new_lock_duration);\r\n    msg!(\"New lock end: {}\", new_lock_end);\r\n    msg!(\"Additional veVCoin: {}\", vevcoin_to_mint);\r\n    msg!(\"Total veVCoin: {}\", new_vevcoin);\r\n    \r\n    Ok(())\r\n}\r\n\r\n","traces":[{"line":10,"address":[],"length":0,"stats":{"Line":0}},{"line":11,"address":[],"length":0,"stats":{"Line":0}},{"line":13,"address":[],"length":0,"stats":{"Line":0}},{"line":14,"address":[],"length":0,"stats":{"Line":0}},{"line":15,"address":[],"length":0,"stats":{"Line":0}},{"line":17,"address":[],"length":0,"stats":{"Line":0}},{"line":18,"address":[],"length":0,"stats":{"Line":0}},{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":21},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","staking-protocol","src","instructions","user","mod.rs"],"content":"/// User instructions\r\npub mod stake;\r\npub mod extend_lock;\r\npub mod unstake;\r\npub mod update_tier;\r\n\r\npub use stake::*;\r\npub use extend_lock::*;\r\npub use unstake::*;\r\npub use update_tier::*;\r\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","staking-protocol","src","instructions","user","stake.rs"],"content":"use anchor_lang::prelude::*;\r\nuse anchor_spl::token_2022;\r\n\r\nuse crate::constants::{MIN_LOCK_DURATION, MAX_LOCK_DURATION};\r\nuse crate::contexts::Stake;\r\nuse crate::errors::StakingError;\r\nuse crate::state::StakingTier;\r\nuse crate::utils::calculate_vevcoin;\r\n\r\n/// Stake VCoin with a lock duration\r\n/// Mints veVCoin proportional to stake amount, lock duration, and tier\r\npub fn handler(ctx: Context\u003cStake\u003e, amount: u64, lock_duration: i64) -\u003e Result\u003c()\u003e {\r\n    let pool = \u0026mut ctx.accounts.pool;\r\n    let user_stake = \u0026mut ctx.accounts.user_stake;\r\n    \r\n    // Validations\r\n    require!(!pool.paused, StakingError::PoolPaused);\r\n    require!(amount \u003e 0, StakingError::ZeroStakeAmount);\r\n    require!(lock_duration \u003e= MIN_LOCK_DURATION, StakingError::LockDurationTooShort);\r\n    require!(lock_duration \u003c= MAX_LOCK_DURATION, StakingError::LockDurationTooLong);\r\n    \r\n    let clock = Clock::get()?;\r\n    let now = clock.unix_timestamp;\r\n    \r\n    // Calculate new total stake and tier\r\n    let new_staked_amount = user_stake.staked_amount\r\n        .checked_add(amount)\r\n        .ok_or(StakingError::Overflow)?;\r\n    let new_tier = StakingTier::from_amount(new_staked_amount);\r\n    \r\n    // Calculate lock end\r\n    let lock_end = now.checked_add(lock_duration).ok_or(StakingError::Overflow)?;\r\n    \r\n    // For existing stakes, new lock must not be shorter\r\n    if user_stake.staked_amount \u003e 0 \u0026\u0026 lock_end \u003c user_stake.lock_end {\r\n        return Err(StakingError::InvalidLockExtension.into());\r\n    }\r\n    \r\n    // Calculate veVCoin to mint\r\n    // If adding to existing stake, calculate delta\r\n    let old_vevcoin = user_stake.ve_vcoin_amount;\r\n    let new_vevcoin = calculate_vevcoin(new_staked_amount, lock_duration, new_tier)?;\r\n    let vevcoin_to_mint = new_vevcoin.checked_sub(old_vevcoin).unwrap_or(0);\r\n    \r\n    // Transfer VCoin to pool vault\r\n    token_2022::transfer_checked(\r\n        CpiContext::new(\r\n            ctx.accounts.token_program.to_account_info(),\r\n            token_2022::TransferChecked {\r\n                from: ctx.accounts.user_vcoin_account.to_account_info(),\r\n                to: ctx.accounts.pool_vault.to_account_info(),\r\n                authority: ctx.accounts.user.to_account_info(),\r\n                mint: ctx.accounts.vcoin_mint.to_account_info(),\r\n            },\r\n        ),\r\n        amount,\r\n        ctx.accounts.vcoin_mint.decimals,\r\n    )?;\r\n    \r\n    // Update user stake\r\n    let is_new_staker = user_stake.staked_amount == 0;\r\n    user_stake.owner = ctx.accounts.user.key();\r\n    user_stake.staked_amount = new_staked_amount;\r\n    user_stake.lock_duration = lock_duration;\r\n    user_stake.lock_end = lock_end;\r\n    user_stake.tier = new_tier.as_u8();\r\n    user_stake.ve_vcoin_amount = new_vevcoin;\r\n    \r\n    if is_new_staker {\r\n        user_stake.stake_start = now;\r\n        user_stake.bump = ctx.bumps.user_stake;\r\n        pool.total_stakers = pool.total_stakers.checked_add(1).ok_or(StakingError::Overflow)?;\r\n    }\r\n    \r\n    // Update pool\r\n    pool.total_staked = pool.total_staked.checked_add(amount).ok_or(StakingError::Overflow)?;\r\n    \r\n    msg!(\"Staked {} VCoin\", amount);\r\n    msg!(\"Lock duration: {} seconds\", lock_duration);\r\n    msg!(\"Tier: {:?}\", new_tier.as_u8());\r\n    msg!(\"veVCoin minted: {}\", vevcoin_to_mint);\r\n    msg!(\"Total veVCoin: {}\", new_vevcoin);\r\n    \r\n    Ok(())\r\n}\r\n\r\n","traces":[{"line":12,"address":[],"length":0,"stats":{"Line":0}},{"line":13,"address":[],"length":0,"stats":{"Line":0}},{"line":14,"address":[],"length":0,"stats":{"Line":0}},{"line":17,"address":[],"length":0,"stats":{"Line":0}},{"line":18,"address":[],"length":0,"stats":{"Line":0}},{"line":19,"address":[],"length":0,"stats":{"Line":0}},{"line":20,"address":[],"length":0,"stats":{"Line":0}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":46},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","staking-protocol","src","instructions","user","unstake.rs"],"content":"use anchor_lang::prelude::*;\r\nuse anchor_spl::token_2022;\r\n\r\nuse crate::constants::STAKING_POOL_SEED;\r\nuse crate::contexts::Unstake;\r\nuse crate::errors::StakingError;\r\nuse crate::state::StakingTier;\r\n\r\n/// Unstake VCoin after lock expires\r\n/// Burns all veVCoin\r\npub fn handler(ctx: Context\u003cUnstake\u003e, amount: u64) -\u003e Result\u003c()\u003e {\r\n    // Get values for validation first\r\n    let staked_amount = ctx.accounts.user_stake.staked_amount;\r\n    let lock_end = ctx.accounts.user_stake.lock_end;\r\n    let ve_vcoin_amount = ctx.accounts.user_stake.ve_vcoin_amount;\r\n    \r\n    require!(staked_amount \u003e 0, StakingError::NoActiveStake);\r\n    require!(amount \u003e 0, StakingError::ZeroStakeAmount);\r\n    require!(amount \u003c= staked_amount, StakingError::InsufficientStake);\r\n    \r\n    let clock = Clock::get()?;\r\n    let now = clock.unix_timestamp;\r\n    \r\n    // Check lock has expired\r\n    require!(now \u003e= lock_end, StakingError::TokensStillLocked);\r\n    \r\n    // Calculate new stake and tier\r\n    let new_staked_amount = staked_amount.checked_sub(amount).ok_or(StakingError::Overflow)?;\r\n    let new_tier = StakingTier::from_amount(new_staked_amount);\r\n    \r\n    // Calculate new veVCoin (0 if fully unstaking)\r\n    let new_vevcoin = if new_staked_amount \u003e 0 {\r\n        // Maintain proportional veVCoin for remaining stake\r\n        let remaining_ratio = (new_staked_amount as u128) * 1000 / (staked_amount as u128);\r\n        (ve_vcoin_amount as u128 * remaining_ratio / 1000) as u64\r\n    } else {\r\n        0\r\n    };\r\n    let vevcoin_to_burn = ve_vcoin_amount.checked_sub(new_vevcoin).unwrap_or(0);\r\n    \r\n    // Get bump from context\r\n    let pool_bump = ctx.bumps.pool;\r\n    let current_total_stakers = ctx.accounts.pool.total_stakers;\r\n    let current_total_staked = ctx.accounts.pool.total_staked;\r\n    \r\n    // Transfer VCoin back to user\r\n    let seeds = \u0026[\r\n        STAKING_POOL_SEED,\r\n        \u0026[pool_bump],\r\n    ];\r\n    let signer_seeds = \u0026[\u0026seeds[..]];\r\n    \r\n    token_2022::transfer_checked(\r\n        CpiContext::new_with_signer(\r\n            ctx.accounts.token_program.to_account_info(),\r\n            token_2022::TransferChecked {\r\n                from: ctx.accounts.pool_vault.to_account_info(),\r\n                to: ctx.accounts.user_vcoin_account.to_account_info(),\r\n                authority: ctx.accounts.pool.to_account_info(),\r\n                mint: ctx.accounts.vcoin_mint.to_account_info(),\r\n            },\r\n            signer_seeds,\r\n        ),\r\n        amount,\r\n        ctx.accounts.vcoin_mint.decimals,\r\n    )?;\r\n    \r\n    // Update state after CPI\r\n    let user_stake = \u0026mut ctx.accounts.user_stake;\r\n    let pool = \u0026mut ctx.accounts.pool;\r\n    \r\n    // Update user stake\r\n    let is_full_unstake = new_staked_amount == 0;\r\n    user_stake.staked_amount = new_staked_amount;\r\n    user_stake.tier = new_tier.as_u8();\r\n    user_stake.ve_vcoin_amount = new_vevcoin;\r\n    \r\n    if is_full_unstake {\r\n        user_stake.lock_duration = 0;\r\n        user_stake.lock_end = 0;\r\n        pool.total_stakers = current_total_stakers.checked_sub(1).ok_or(StakingError::Overflow)?;\r\n    }\r\n    \r\n    // Update pool\r\n    pool.total_staked = current_total_staked.checked_sub(amount).ok_or(StakingError::Overflow)?;\r\n    \r\n    msg!(\"Unstaked {} VCoin\", amount);\r\n    msg!(\"veVCoin burned: {}\", vevcoin_to_burn);\r\n    msg!(\"Remaining stake: {}\", new_staked_amount);\r\n    \r\n    Ok(())\r\n}\r\n\r\n","traces":[{"line":11,"address":[],"length":0,"stats":{"Line":0}},{"line":13,"address":[],"length":0,"stats":{"Line":0}},{"line":14,"address":[],"length":0,"stats":{"Line":0}},{"line":15,"address":[],"length":0,"stats":{"Line":0}},{"line":17,"address":[],"length":0,"stats":{"Line":0}},{"line":18,"address":[],"length":0,"stats":{"Line":0}},{"line":19,"address":[],"length":0,"stats":{"Line":0}},{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":49},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","staking-protocol","src","instructions","user","update_tier.rs"],"content":"use anchor_lang::prelude::*;\r\n\r\nuse crate::contexts::UpdateTier;\r\nuse crate::errors::StakingError;\r\nuse crate::state::StakingTier;\r\nuse crate::utils::calculate_vevcoin;\r\n\r\n/// Update user's tier based on current stake\r\npub fn handler(ctx: Context\u003cUpdateTier\u003e) -\u003e Result\u003c()\u003e {\r\n    let user_stake = \u0026mut ctx.accounts.user_stake;\r\n    \r\n    require!(user_stake.staked_amount \u003e 0, StakingError::NoActiveStake);\r\n    \r\n    let new_tier = StakingTier::from_amount(user_stake.staked_amount);\r\n    let old_tier = user_stake.tier;\r\n    \r\n    user_stake.tier = new_tier.as_u8();\r\n    \r\n    // Recalculate veVCoin with new tier\r\n    let new_vevcoin = calculate_vevcoin(\r\n        user_stake.staked_amount,\r\n        user_stake.lock_duration,\r\n        new_tier,\r\n    )?;\r\n    user_stake.ve_vcoin_amount = new_vevcoin;\r\n    \r\n    msg!(\"Tier updated from {} to {}\", old_tier, new_tier.as_u8());\r\n    msg!(\"veVCoin updated to: {}\", new_vevcoin);\r\n    \r\n    Ok(())\r\n}\r\n\r\n","traces":[{"line":9,"address":[],"length":0,"stats":{"Line":0}},{"line":10,"address":[],"length":0,"stats":{"Line":0}},{"line":12,"address":[],"length":0,"stats":{"Line":0}},{"line":14,"address":[],"length":0,"stats":{"Line":0}},{"line":15,"address":[],"length":0,"stats":{"Line":0}},{"line":17,"address":[],"length":0,"stats":{"Line":0}},{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":30,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":13},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","staking-protocol","src","lib.rs"],"content":"use anchor_lang::prelude::*;\r\n\r\npub mod constants;\r\npub mod contexts;\r\npub mod errors;\r\npub mod instructions;\r\npub mod state;\r\npub mod utils;\r\n\r\n#[cfg(test)]\r\nmod tests;\r\n\r\nuse contexts::*;\r\nuse instructions::query::get_stake_info::UserStakeInfo;\r\n\r\ndeclare_id!(\"6EFcistyr2E81adLUcuBJRr8W2xzpt3D3dFYEcMewpWu\");\r\n\r\n/// VCoin Staking Protocol\r\n/// \r\n/// Stake VCoin → Get veVCoin (voting power)\r\n/// - Longer stake = More voting power\r\n/// - Higher tier = Bonus veVCoin\r\n/// \r\n/// Staking Tiers:\r\n/// - None:     0 VCoin        → 0% fee discount, 1.0x veVCoin boost\r\n/// - Bronze:   1,000 VCoin    → 10% fee discount, 1.1x veVCoin boost\r\n/// - Silver:   5,000 VCoin    → 20% fee discount, 1.2x veVCoin boost\r\n/// - Gold:     20,000 VCoin   → 30% fee discount, 1.3x veVCoin boost\r\n/// - Platinum: 100,000 VCoin  → 50% fee discount, 1.4x veVCoin boost\r\n\r\n#[program]\r\npub mod staking_protocol {\r\n    use super::*;\r\n\r\n    /// Initialize the staking pool\r\n    pub fn initialize_pool(ctx: Context\u003cInitializePool\u003e, vevcoin_program: Pubkey) -\u003e Result\u003c()\u003e {\r\n        instructions::admin::initialize_pool::handler(ctx, vevcoin_program)\r\n    }\r\n\r\n    /// Stake VCoin with a lock duration\r\n    pub fn stake(ctx: Context\u003cStake\u003e, amount: u64, lock_duration: i64) -\u003e Result\u003c()\u003e {\r\n        instructions::user::stake::handler(ctx, amount, lock_duration)\r\n    }\r\n\r\n    /// Extend lock duration to increase veVCoin\r\n    pub fn extend_lock(ctx: Context\u003cExtendLock\u003e, new_lock_duration: i64) -\u003e Result\u003c()\u003e {\r\n        instructions::user::extend_lock::handler(ctx, new_lock_duration)\r\n    }\r\n\r\n    /// Unstake VCoin after lock expires\r\n    pub fn unstake(ctx: Context\u003cUnstake\u003e, amount: u64) -\u003e Result\u003c()\u003e {\r\n        instructions::user::unstake::handler(ctx, amount)\r\n    }\r\n\r\n    /// Update user's tier based on current stake\r\n    pub fn update_tier(ctx: Context\u003cUpdateTier\u003e) -\u003e Result\u003c()\u003e {\r\n        instructions::user::update_tier::handler(ctx)\r\n    }\r\n\r\n    /// Pause/unpause the staking pool\r\n    pub fn set_paused(ctx: Context\u003cAdminAction\u003e, paused: bool) -\u003e Result\u003c()\u003e {\r\n        instructions::admin::set_paused::handler(ctx, paused)\r\n    }\r\n\r\n    /// Update the pool authority\r\n    pub fn update_authority(ctx: Context\u003cAdminAction\u003e, new_authority: Pubkey) -\u003e Result\u003c()\u003e {\r\n        instructions::admin::update_authority::handler(ctx, new_authority)\r\n    }\r\n\r\n    /// Get user's staking info (view function)\r\n    pub fn get_stake_info(ctx: Context\u003cGetStakeInfo\u003e) -\u003e Result\u003cUserStakeInfo\u003e {\r\n        instructions::query::get_stake_info::handler(ctx)\r\n    }\r\n}\r\n","traces":[{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":16},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","staking-protocol","src","state","mod.rs"],"content":"/// State module - Account structures\r\nmod pool;\r\nmod user_stake;\r\nmod tier;\r\n\r\npub use pool::*;\r\npub use user_stake::*;\r\npub use tier::*;\r\n\r\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","staking-protocol","src","state","pool.rs"],"content":"use anchor_lang::prelude::*;\r\n\r\n/// Staking Pool Account (Singleton PDA)\r\n#[account]\r\n#[derive(Default)]\r\npub struct StakingPool {\r\n    /// Admin authority\r\n    pub authority: Pubkey,\r\n    /// VCoin mint address\r\n    pub vcoin_mint: Pubkey,\r\n    /// veVCoin mint address\r\n    pub vevcoin_mint: Pubkey,\r\n    /// veVCoin program address\r\n    pub vevcoin_program: Pubkey,\r\n    /// Pool vault for staked VCoin\r\n    pub pool_vault: Pubkey,\r\n    /// Total VCoin staked in the pool\r\n    pub total_staked: u64,\r\n    /// Total number of stakers\r\n    pub total_stakers: u64,\r\n    /// Whether the pool is paused\r\n    pub paused: bool,\r\n    /// Bump seed for PDA\r\n    pub bump: u8,\r\n    /// Vault bump seed\r\n    pub vault_bump: u8,\r\n}\r\n\r\nimpl StakingPool {\r\n    pub const LEN: usize = 8 + // discriminator\r\n        32 + // authority\r\n        32 + // vcoin_mint\r\n        32 + // vevcoin_mint\r\n        32 + // vevcoin_program\r\n        32 + // pool_vault\r\n        8 +  // total_staked\r\n        8 +  // total_stakers\r\n        1 +  // paused\r\n        1 +  // bump\r\n        1;   // vault_bump\r\n}\r\n\r\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","staking-protocol","src","state","tier.rs"],"content":"use anchor_lang::prelude::*;\r\n\r\nuse crate::constants::*;\r\n\r\n/// Staking tier enum\r\n#[derive(AnchorSerialize, AnchorDeserialize, Clone, Copy, PartialEq, Eq, Default, Debug)]\r\npub enum StakingTier {\r\n    #[default]\r\n    None = 0,\r\n    Bronze = 1,\r\n    Silver = 2,\r\n    Gold = 3,\r\n    Platinum = 4,\r\n}\r\n\r\nimpl StakingTier {\r\n    pub fn from_amount(amount: u64) -\u003e Self {\r\n        if amount \u003e= PLATINUM_THRESHOLD {\r\n            StakingTier::Platinum\r\n        } else if amount \u003e= GOLD_THRESHOLD {\r\n            StakingTier::Gold\r\n        } else if amount \u003e= SILVER_THRESHOLD {\r\n            StakingTier::Silver\r\n        } else if amount \u003e= BRONZE_THRESHOLD {\r\n            StakingTier::Bronze\r\n        } else {\r\n            StakingTier::None\r\n        }\r\n    }\r\n    \r\n    pub fn boost_multiplier(\u0026self) -\u003e u64 {\r\n        match self {\r\n            StakingTier::None =\u003e TIER_BOOST_NONE,\r\n            StakingTier::Bronze =\u003e TIER_BOOST_BRONZE,\r\n            StakingTier::Silver =\u003e TIER_BOOST_SILVER,\r\n            StakingTier::Gold =\u003e TIER_BOOST_GOLD,\r\n            StakingTier::Platinum =\u003e TIER_BOOST_PLATINUM,\r\n        }\r\n    }\r\n    \r\n    pub fn fee_discount_bps(\u0026self) -\u003e u16 {\r\n        match self {\r\n            StakingTier::None =\u003e FEE_DISCOUNT_NONE,\r\n            StakingTier::Bronze =\u003e FEE_DISCOUNT_BRONZE,\r\n            StakingTier::Silver =\u003e FEE_DISCOUNT_SILVER,\r\n            StakingTier::Gold =\u003e FEE_DISCOUNT_GOLD,\r\n            StakingTier::Platinum =\u003e FEE_DISCOUNT_PLATINUM,\r\n        }\r\n    }\r\n    \r\n    pub fn as_u8(\u0026self) -\u003e u8 {\r\n        match self {\r\n            StakingTier::None =\u003e 0,\r\n            StakingTier::Bronze =\u003e 1,\r\n            StakingTier::Silver =\u003e 2,\r\n            StakingTier::Gold =\u003e 3,\r\n            StakingTier::Platinum =\u003e 4,\r\n        }\r\n    }\r\n}\r\n\r\n","traces":[{"line":17,"address":[],"length":0,"stats":{"Line":1441151880758558720}},{"line":18,"address":[],"length":0,"stats":{"Line":1441151880758558720}},{"line":19,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":20,"address":[],"length":0,"stats":{"Line":1224979098644774912}},{"line":21,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":22,"address":[],"length":0,"stats":{"Line":936748722493063168}},{"line":23,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":24,"address":[],"length":0,"stats":{"Line":648518346341351424}},{"line":25,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":27,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":31,"address":[],"length":0,"stats":{"Line":1873497444986126336}},{"line":32,"address":[],"length":0,"stats":{"Line":1873497444986126336}},{"line":33,"address":[],"length":0,"stats":{"Line":936748722493063168}},{"line":34,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":35,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":36,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":37,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":41,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":42,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":43,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":44,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":45,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":46,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":47,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":51,"address":[],"length":0,"stats":{"Line":648518346341351424}},{"line":52,"address":[],"length":0,"stats":{"Line":648518346341351424}},{"line":53,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":54,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":55,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":56,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":57,"address":[],"length":0,"stats":{"Line":72057594037927936}}],"covered":31,"coverable":31},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","staking-protocol","src","state","user_stake.rs"],"content":"use anchor_lang::prelude::*;\r\n\r\n/// User Stake Account (PDA per user)\r\n#[account]\r\n#[derive(Default)]\r\npub struct UserStake {\r\n    /// Owner of this stake\r\n    pub owner: Pubkey,\r\n    /// Amount of VCoin staked\r\n    pub staked_amount: u64,\r\n    /// Lock duration in seconds\r\n    pub lock_duration: i64,\r\n    /// Timestamp when lock ends\r\n    pub lock_end: i64,\r\n    /// When the stake was created\r\n    pub stake_start: i64,\r\n    /// Current staking tier\r\n    pub tier: u8,\r\n    /// Current veVCoin amount minted\r\n    pub ve_vcoin_amount: u64,\r\n    /// Bump seed for PDA\r\n    pub bump: u8,\r\n}\r\n\r\nimpl UserStake {\r\n    pub const LEN: usize = 8 + // discriminator\r\n        32 + // owner\r\n        8 +  // staked_amount\r\n        8 +  // lock_duration\r\n        8 +  // lock_end\r\n        8 +  // stake_start\r\n        1 +  // tier\r\n        8 +  // ve_vcoin_amount\r\n        1;   // bump\r\n}\r\n\r\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","staking-protocol","src","tests.rs"],"content":"//! Unit tests for Staking Protocol\r\n//! \r\n//! These tests run against the ACTUAL program code.\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n    use crate::constants::*;\r\n    use crate::state::StakingTier;\r\n    use crate::utils::calculate_vevcoin;\r\n\r\n    // ========================================================================\r\n    // Tier Tests - Testing ACTUAL StakingTier::from_amount\r\n    // ========================================================================\r\n\r\n    #[test]\r\n    fn test_tier_none() {\r\n        assert_eq!(StakingTier::from_amount(0), StakingTier::None);\r\n        assert_eq!(StakingTier::from_amount(999 * 1_000_000_000), StakingTier::None);\r\n    }\r\n\r\n    #[test]\r\n    fn test_tier_bronze() {\r\n        assert_eq!(StakingTier::from_amount(BRONZE_THRESHOLD), StakingTier::Bronze);\r\n        assert_eq!(StakingTier::from_amount(BRONZE_THRESHOLD + 1), StakingTier::Bronze);\r\n        assert_eq!(StakingTier::from_amount(SILVER_THRESHOLD - 1), StakingTier::Bronze);\r\n    }\r\n\r\n    #[test]\r\n    fn test_tier_silver() {\r\n        assert_eq!(StakingTier::from_amount(SILVER_THRESHOLD), StakingTier::Silver);\r\n        assert_eq!(StakingTier::from_amount(GOLD_THRESHOLD - 1), StakingTier::Silver);\r\n    }\r\n\r\n    #[test]\r\n    fn test_tier_gold() {\r\n        assert_eq!(StakingTier::from_amount(GOLD_THRESHOLD), StakingTier::Gold);\r\n        assert_eq!(StakingTier::from_amount(PLATINUM_THRESHOLD - 1), StakingTier::Gold);\r\n    }\r\n\r\n    #[test]\r\n    fn test_tier_platinum() {\r\n        assert_eq!(StakingTier::from_amount(PLATINUM_THRESHOLD), StakingTier::Platinum);\r\n        assert_eq!(StakingTier::from_amount(PLATINUM_THRESHOLD * 10), StakingTier::Platinum);\r\n    }\r\n\r\n    #[test]\r\n    fn test_tier_thresholds_correct() {\r\n        assert_eq!(BRONZE_THRESHOLD, 1_000 * 1_000_000_000);\r\n        assert_eq!(SILVER_THRESHOLD, 5_000 * 1_000_000_000);\r\n        assert_eq!(GOLD_THRESHOLD, 20_000 * 1_000_000_000);\r\n        assert_eq!(PLATINUM_THRESHOLD, 100_000 * 1_000_000_000);\r\n    }\r\n\r\n    #[test]\r\n    fn test_tier_monotonic() {\r\n        let amounts = [\r\n            0u64,\r\n            BRONZE_THRESHOLD - 1,\r\n            BRONZE_THRESHOLD,\r\n            SILVER_THRESHOLD - 1,\r\n            SILVER_THRESHOLD,\r\n            GOLD_THRESHOLD - 1,\r\n            GOLD_THRESHOLD,\r\n            PLATINUM_THRESHOLD - 1,\r\n            PLATINUM_THRESHOLD,\r\n        ];\r\n\r\n        let mut prev_tier = 0u8;\r\n        for amount in amounts {\r\n            let tier = StakingTier::from_amount(amount).as_u8();\r\n            assert!(tier \u003e= prev_tier, \"Tier should increase with amount\");\r\n            prev_tier = tier;\r\n        }\r\n    }\r\n\r\n    // ========================================================================\r\n    // Boost Multiplier Tests\r\n    // ========================================================================\r\n\r\n    #[test]\r\n    fn test_boost_multipliers() {\r\n        assert_eq!(StakingTier::None.boost_multiplier(), 1000);     // 1.0x\r\n        assert_eq!(StakingTier::Bronze.boost_multiplier(), 1100);   // 1.1x\r\n        assert_eq!(StakingTier::Silver.boost_multiplier(), 1200);   // 1.2x\r\n        assert_eq!(StakingTier::Gold.boost_multiplier(), 1300);     // 1.3x\r\n        assert_eq!(StakingTier::Platinum.boost_multiplier(), 1400); // 1.4x\r\n    }\r\n\r\n    #[test]\r\n    fn test_fee_discounts() {\r\n        assert_eq!(StakingTier::None.fee_discount_bps(), 0);       // 0%\r\n        assert_eq!(StakingTier::Bronze.fee_discount_bps(), 1000);  // 10%\r\n        assert_eq!(StakingTier::Silver.fee_discount_bps(), 2000);  // 20%\r\n        assert_eq!(StakingTier::Gold.fee_discount_bps(), 3000);    // 30%\r\n        assert_eq!(StakingTier::Platinum.fee_discount_bps(), 5000);// 50%\r\n    }\r\n\r\n    // ========================================================================\r\n    // veVCoin Calculation Tests - Testing ACTUAL calculate_vevcoin\r\n    // ========================================================================\r\n\r\n    #[test]\r\n    fn test_vevcoin_zero_stake() {\r\n        let result = calculate_vevcoin(0, MAX_LOCK_DURATION, StakingTier::Platinum);\r\n        assert!(result.is_ok());\r\n        assert_eq!(result.unwrap(), 0);\r\n    }\r\n\r\n    #[test]\r\n    fn test_vevcoin_max_lock_no_tier() {\r\n        // 1000 VCoin for 4 years with no tier\r\n        // ve_vcoin = 1000 * (4y/4y * 1000) * 1000 / 1_000_000 = 1000 * 1\r\n        let amount = 1000 * 1_000_000_000u64; // 1000 VCoin\r\n        let result = calculate_vevcoin(amount, MAX_LOCK_DURATION, StakingTier::None);\r\n        assert!(result.is_ok());\r\n        \r\n        // Should equal stake amount at max lock with no boost\r\n        let vevcoin = result.unwrap();\r\n        assert_eq!(vevcoin, amount);\r\n    }\r\n\r\n    #[test]\r\n    fn test_vevcoin_max_lock_platinum() {\r\n        // 100,000 VCoin for 4 years with Platinum tier (1.4x boost)\r\n        let amount = 100_000 * 1_000_000_000u64; // 100,000 VCoin\r\n        let result = calculate_vevcoin(amount, MAX_LOCK_DURATION, StakingTier::Platinum);\r\n        assert!(result.is_ok());\r\n        \r\n        let vevcoin = result.unwrap();\r\n        // Expected: amount * 1.4 = 140,000 VCoin worth of veVCoin\r\n        let expected = amount * 1400 / 1000;\r\n        assert_eq!(vevcoin, expected);\r\n    }\r\n\r\n    #[test]\r\n    fn test_vevcoin_half_lock_duration() {\r\n        // 1000 VCoin for 2 years with no tier\r\n        // duration_factor = (2y * 1000) / 4y = 500\r\n        // ve_vcoin = 1000 * 500 * 1000 / 1_000_000 = 500 VCoin\r\n        let amount = 1000 * 1_000_000_000u64;\r\n        let two_years = MAX_LOCK_DURATION / 2;\r\n        let result = calculate_vevcoin(amount, two_years, StakingTier::None);\r\n        assert!(result.is_ok());\r\n        \r\n        let vevcoin = result.unwrap();\r\n        assert_eq!(vevcoin, amount / 2);\r\n    }\r\n\r\n    #[test]\r\n    fn test_vevcoin_min_lock() {\r\n        let amount = 1000 * 1_000_000_000u64;\r\n        let result = calculate_vevcoin(amount, MIN_LOCK_DURATION, StakingTier::None);\r\n        assert!(result.is_ok());\r\n        \r\n        let vevcoin = result.unwrap();\r\n        // Min lock is 1 week out of 4 years ≈ 0.48%\r\n        // Using actual formula: ve_vcoin = amount * (duration * 1000 / 4y) * tier_boost / 1_000_000\r\n        // duration_factor = MIN_LOCK_DURATION * 1000 / FOUR_YEARS = 604800 * 1000 / 126144000 = 4\r\n        // vevcoin = amount * 4 * 1000 / 1_000_000 = amount * 0.004\r\n        let duration_factor = (MIN_LOCK_DURATION as u128) * 1000 / (MAX_LOCK_DURATION as u128);\r\n        let tier_boost = StakingTier::None.boost_multiplier() as u128;\r\n        let expected = (amount as u128 * duration_factor * tier_boost / 1_000_000) as u64;\r\n        assert_eq!(vevcoin, expected);\r\n    }\r\n\r\n    #[test]\r\n    fn test_vevcoin_increases_with_duration() {\r\n        let amount = 10_000 * 1_000_000_000u64;\r\n        \r\n        let vevcoin_1y = calculate_vevcoin(amount, MAX_LOCK_DURATION / 4, StakingTier::None).unwrap();\r\n        let vevcoin_2y = calculate_vevcoin(amount, MAX_LOCK_DURATION / 2, StakingTier::None).unwrap();\r\n        let vevcoin_4y = calculate_vevcoin(amount, MAX_LOCK_DURATION, StakingTier::None).unwrap();\r\n        \r\n        assert!(vevcoin_2y \u003e vevcoin_1y);\r\n        assert!(vevcoin_4y \u003e vevcoin_2y);\r\n    }\r\n\r\n    #[test]\r\n    fn test_vevcoin_increases_with_tier() {\r\n        let amount = 100_000 * 1_000_000_000u64;\r\n        let duration = MAX_LOCK_DURATION;\r\n        \r\n        let ve_none = calculate_vevcoin(amount, duration, StakingTier::None).unwrap();\r\n        let ve_bronze = calculate_vevcoin(amount, duration, StakingTier::Bronze).unwrap();\r\n        let ve_silver = calculate_vevcoin(amount, duration, StakingTier::Silver).unwrap();\r\n        let ve_gold = calculate_vevcoin(amount, duration, StakingTier::Gold).unwrap();\r\n        let ve_platinum = calculate_vevcoin(amount, duration, StakingTier::Platinum).unwrap();\r\n        \r\n        assert!(ve_bronze \u003e ve_none);\r\n        assert!(ve_silver \u003e ve_bronze);\r\n        assert!(ve_gold \u003e ve_silver);\r\n        assert!(ve_platinum \u003e ve_gold);\r\n    }\r\n\r\n    // ========================================================================\r\n    // Overflow Protection Tests\r\n    // ========================================================================\r\n\r\n    #[test]\r\n    fn test_vevcoin_no_overflow_max_values() {\r\n        // Test with very large values\r\n        let max_reasonable_stake = 1_000_000_000 * 1_000_000_000u64; // 1 billion VCoin\r\n        let result = calculate_vevcoin(max_reasonable_stake, MAX_LOCK_DURATION, StakingTier::Platinum);\r\n        assert!(result.is_ok());\r\n    }\r\n\r\n    // ========================================================================\r\n    // Lock Duration Constants\r\n    // ========================================================================\r\n\r\n    #[test]\r\n    fn test_lock_duration_constants() {\r\n        assert_eq!(MIN_LOCK_DURATION, 7 * 24 * 60 * 60); // 1 week in seconds\r\n        assert_eq!(MAX_LOCK_DURATION, 4 * 365 * 24 * 60 * 60); // 4 years\r\n        assert_eq!(FOUR_YEARS_SECONDS, MAX_LOCK_DURATION);\r\n    }\r\n\r\n    // ========================================================================\r\n    // Property Tests\r\n    // ========================================================================\r\n\r\n    #[test]\r\n    fn test_vevcoin_proportional_to_stake() {\r\n        let base_amount = 1000 * 1_000_000_000u64;\r\n        let duration = MAX_LOCK_DURATION;\r\n        let tier = StakingTier::None;\r\n        \r\n        let ve1 = calculate_vevcoin(base_amount, duration, tier).unwrap();\r\n        let ve2 = calculate_vevcoin(base_amount * 2, duration, tier).unwrap();\r\n        let ve10 = calculate_vevcoin(base_amount * 10, duration, tier).unwrap();\r\n        \r\n        // veVCoin should scale linearly with stake\r\n        assert_eq!(ve2, ve1 * 2);\r\n        assert_eq!(ve10, ve1 * 10);\r\n    }\r\n\r\n    #[test]\r\n    fn test_tier_boost_exact_ratios() {\r\n        let amount = 100_000 * 1_000_000_000u64;\r\n        let duration = MAX_LOCK_DURATION;\r\n        \r\n        let ve_none = calculate_vevcoin(amount, duration, StakingTier::None).unwrap();\r\n        let ve_bronze = calculate_vevcoin(amount, duration, StakingTier::Bronze).unwrap();\r\n        let ve_platinum = calculate_vevcoin(amount, duration, StakingTier::Platinum).unwrap();\r\n        \r\n        // Bronze = 1.1x of None\r\n        assert_eq!(ve_bronze * 1000, ve_none * 1100);\r\n        \r\n        // Platinum = 1.4x of None\r\n        assert_eq!(ve_platinum * 1000, ve_none * 1400);\r\n    }\r\n}\r\n\r\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","staking-protocol","src","utils.rs"],"content":"use anchor_lang::prelude::*;\r\n\r\nuse crate::constants::FOUR_YEARS_SECONDS;\r\nuse crate::errors::StakingError;\r\nuse crate::state::StakingTier;\r\n\r\n/// Calculate veVCoin amount based on staked amount, lock duration, and tier\r\n/// Formula: ve_vcoin = staked_amount * (lock_duration / 4_years) * tier_boost\r\npub fn calculate_vevcoin(staked_amount: u64, lock_duration: i64, tier: StakingTier) -\u003e Result\u003cu64\u003e {\r\n    // ve_vcoin = staked_amount * (lock_duration / 4_years) * tier_boost\r\n    // To avoid floating point, we multiply first then divide\r\n    // tier_boost is already multiplied by 1000\r\n    \r\n    let duration_factor = (lock_duration as u128) * 1000 / (FOUR_YEARS_SECONDS as u128);\r\n    let tier_boost = tier.boost_multiplier() as u128;\r\n    \r\n    let ve_vcoin = (staked_amount as u128)\r\n        .checked_mul(duration_factor)\r\n        .ok_or(StakingError::Overflow)?\r\n        .checked_mul(tier_boost)\r\n        .ok_or(StakingError::Overflow)?\r\n        .checked_div(1_000_000) // Divide by 1000 * 1000 to normalize\r\n        .ok_or(StakingError::Overflow)?;\r\n    \r\n    Ok(ve_vcoin as u64)\r\n}\r\n\r\n","traces":[{"line":9,"address":[],"length":0,"stats":{"Line":1441151880758558720}},{"line":14,"address":[],"length":0,"stats":{"Line":2882303761517117440}},{"line":15,"address":[],"length":0,"stats":{"Line":2882303761517117440}},{"line":17,"address":[],"length":0,"stats":{"Line":2882303761517117440}},{"line":18,"address":[],"length":0,"stats":{"Line":2882303761517117440}},{"line":19,"address":[],"length":0,"stats":{"Line":2882303761517117440}},{"line":20,"address":[],"length":0,"stats":{"Line":2882303761517117440}},{"line":21,"address":[],"length":0,"stats":{"Line":2882303761517117440}},{"line":23,"address":[],"length":0,"stats":{"Line":2882303761517117440}},{"line":25,"address":[],"length":0,"stats":{"Line":1441151880758558720}}],"covered":10,"coverable":10},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","staking-protocol","tests","admin.rs"],"content":"//! Integration tests for staking-protocol admin instructions\r\n\r\nmod common;\r\n\r\nuse common::*;\r\nuse solana_sdk::signature::{Keypair, Signer};\r\n\r\n#[tokio::test]\r\nasync fn test_set_paused_true() {\r\n    let mut ctx = TestContext::new().await;\r\n    \r\n    let (pool_pda, _bump) = ctx.get_pool_pda();\r\n    let vevcoin_program = Keypair::new();\r\n    \r\n    let init_ix = create_initialize_pool_ix(\r\n        \u0026ctx.program_id,\r\n        \u0026ctx.payer.pubkey(),\r\n        \u0026pool_pda,\r\n        \u0026vevcoin_program.pubkey(),\r\n    );\r\n    \r\n    ctx.process_transaction(\u0026[init_ix], \u0026[]).await.unwrap();\r\n    \r\n    let pause_ix = create_set_paused_ix(\r\n        \u0026ctx.program_id,\r\n        \u0026ctx.payer.pubkey(),\r\n        \u0026pool_pda,\r\n        true,\r\n    );\r\n    \r\n    let result = ctx.process_transaction(\u0026[pause_ix], \u0026[]).await;\r\n    assert!(result.is_ok());\r\n}\r\n\r\n#[tokio::test]\r\nasync fn test_set_paused_false() {\r\n    let mut ctx = TestContext::new().await;\r\n    \r\n    let (pool_pda, _bump) = ctx.get_pool_pda();\r\n    let vevcoin_program = Keypair::new();\r\n    \r\n    let init_ix = create_initialize_pool_ix(\r\n        \u0026ctx.program_id,\r\n        \u0026ctx.payer.pubkey(),\r\n        \u0026pool_pda,\r\n        \u0026vevcoin_program.pubkey(),\r\n    );\r\n    \r\n    ctx.process_transaction(\u0026[init_ix], \u0026[]).await.unwrap();\r\n    \r\n    let pause_ix = create_set_paused_ix(\u0026ctx.program_id, \u0026ctx.payer.pubkey(), \u0026pool_pda, true);\r\n    ctx.process_transaction(\u0026[pause_ix], \u0026[]).await.unwrap();\r\n    \r\n    let unpause_ix = create_set_paused_ix(\u0026ctx.program_id, \u0026ctx.payer.pubkey(), \u0026pool_pda, false);\r\n    let result = ctx.process_transaction(\u0026[unpause_ix], \u0026[]).await;\r\n    assert!(result.is_ok());\r\n}\r\n\r\n#[tokio::test]\r\nasync fn test_set_paused_unauthorized() {\r\n    let mut ctx = TestContext::new().await;\r\n    \r\n    let (pool_pda, _bump) = ctx.get_pool_pda();\r\n    let vevcoin_program = Keypair::new();\r\n    \r\n    let init_ix = create_initialize_pool_ix(\r\n        \u0026ctx.program_id,\r\n        \u0026ctx.payer.pubkey(),\r\n        \u0026pool_pda,\r\n        \u0026vevcoin_program.pubkey(),\r\n    );\r\n    \r\n    ctx.process_transaction(\u0026[init_ix], \u0026[]).await.unwrap();\r\n    \r\n    let unauthorized = Keypair::new();\r\n    let pause_ix = create_set_paused_ix(\r\n        \u0026ctx.program_id,\r\n        \u0026unauthorized.pubkey(),\r\n        \u0026pool_pda,\r\n        true,\r\n    );\r\n    \r\n    assert_eq!(pause_ix.accounts[0].pubkey, unauthorized.pubkey());\r\n}\r\n\r\n#[tokio::test]\r\nasync fn test_set_paused_toggle_multiple() {\r\n    let mut ctx = TestContext::new().await;\r\n    \r\n    let (pool_pda, _bump) = ctx.get_pool_pda();\r\n    let vevcoin_program = Keypair::new();\r\n    \r\n    let init_ix = create_initialize_pool_ix(\r\n        \u0026ctx.program_id,\r\n        \u0026ctx.payer.pubkey(),\r\n        \u0026pool_pda,\r\n        \u0026vevcoin_program.pubkey(),\r\n    );\r\n    \r\n    ctx.process_transaction(\u0026[init_ix], \u0026[]).await.unwrap();\r\n    \r\n    for paused in [true, false, true, false] {\r\n        let ix = create_set_paused_ix(\u0026ctx.program_id, \u0026ctx.payer.pubkey(), \u0026pool_pda, paused);\r\n        let result = ctx.process_transaction(\u0026[ix], \u0026[]).await;\r\n        assert!(result.is_ok());\r\n    }\r\n}\r\n\r\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","staking-protocol","tests","common","mod.rs"],"content":"//! Common test utilities for staking-protocol integration tests\r\n\r\nuse anchor_lang::prelude::*;\r\nuse solana_program_test::*;\r\nuse solana_sdk::{\r\n    account::Account,\r\n    hash::Hash,\r\n    instruction::{AccountMeta, Instruction},\r\n    pubkey::Pubkey,\r\n    signature::{Keypair, Signer},\r\n    system_instruction,\r\n    transaction::Transaction,\r\n};\r\n\r\npub const STAKING_POOL_SEED: \u0026[u8] = b\"staking-pool\";\r\npub const USER_STAKE_SEED: \u0026[u8] = b\"user-stake\";\r\n\r\npub struct TestContext {\r\n    pub banks_client: BanksClient,\r\n    pub payer: Keypair,\r\n    pub recent_blockhash: Hash,\r\n    pub program_id: Pubkey,\r\n}\r\n\r\nimpl TestContext {\r\n    pub async fn new() -\u003e Self {\r\n        let program_id = staking_protocol::id();\r\n        let program_test = ProgramTest::new(\r\n            \"staking_protocol\",\r\n            program_id,\r\n            processor!(staking_protocol::entry),\r\n        );\r\n\r\n        let (banks_client, payer, recent_blockhash) = program_test.start().await;\r\n\r\n        Self {\r\n            banks_client,\r\n            payer,\r\n            recent_blockhash,\r\n            program_id,\r\n        }\r\n    }\r\n\r\n    pub async fn refresh_blockhash(\u0026mut self) {\r\n        self.recent_blockhash = self.banks_client.get_latest_blockhash().await.unwrap();\r\n    }\r\n\r\n    pub async fn get_account(\u0026mut self, pubkey: Pubkey) -\u003e Option\u003cAccount\u003e {\r\n        self.banks_client.get_account(pubkey).await.unwrap()\r\n    }\r\n\r\n    pub async fn airdrop(\u0026mut self, pubkey: \u0026Pubkey, lamports: u64) {\r\n        let ix = system_instruction::transfer(\u0026self.payer.pubkey(), pubkey, lamports);\r\n        let tx = Transaction::new_signed_with_payer(\r\n            \u0026[ix],\r\n            Some(\u0026self.payer.pubkey()),\r\n            \u0026[\u0026self.payer],\r\n            self.recent_blockhash,\r\n        );\r\n        self.banks_client.process_transaction(tx).await.unwrap();\r\n        self.refresh_blockhash().await;\r\n    }\r\n\r\n    pub fn get_pool_pda(\u0026self) -\u003e (Pubkey, u8) {\r\n        Pubkey::find_program_address(\u0026[STAKING_POOL_SEED], \u0026self.program_id)\r\n    }\r\n\r\n    pub fn get_user_stake_pda(\u0026self, user: \u0026Pubkey) -\u003e (Pubkey, u8) {\r\n        Pubkey::find_program_address(\u0026[USER_STAKE_SEED, user.as_ref()], \u0026self.program_id)\r\n    }\r\n\r\n    pub async fn process_transaction(\r\n        \u0026mut self,\r\n        instructions: \u0026[Instruction],\r\n        signers: \u0026[\u0026Keypair],\r\n    ) -\u003e Result\u003c(), BanksClientError\u003e {\r\n        let mut all_signers = vec![\u0026self.payer];\r\n        all_signers.extend(signers);\r\n        \r\n        let tx = Transaction::new_signed_with_payer(\r\n            instructions,\r\n            Some(\u0026self.payer.pubkey()),\r\n            \u0026all_signers,\r\n            self.recent_blockhash,\r\n        );\r\n        \r\n        let result = self.banks_client.process_transaction(tx).await;\r\n        self.refresh_blockhash().await;\r\n        result\r\n    }\r\n}\r\n\r\npub fn create_initialize_pool_ix(\r\n    program_id: \u0026Pubkey,\r\n    authority: \u0026Pubkey,\r\n    pool: \u0026Pubkey,\r\n    vevcoin_program: \u0026Pubkey,\r\n) -\u003e Instruction {\r\n    let mut data = vec![0u8; 8 + 32];\r\n    let discriminator = anchor_lang::solana_program::hash::hash(b\"global:initialize_pool\").to_bytes();\r\n    data[..8].copy_from_slice(\u0026discriminator[..8]);\r\n    data[8..40].copy_from_slice(vevcoin_program.as_ref());\r\n\r\n    Instruction {\r\n        program_id: *program_id,\r\n        accounts: vec![\r\n            AccountMeta::new(*authority, true),\r\n            AccountMeta::new(*pool, false),\r\n            AccountMeta::new_readonly(solana_sdk::system_program::id(), false),\r\n        ],\r\n        data,\r\n    }\r\n}\r\n\r\npub fn create_stake_ix(\r\n    program_id: \u0026Pubkey,\r\n    user: \u0026Pubkey,\r\n    pool: \u0026Pubkey,\r\n    user_stake: \u0026Pubkey,\r\n    amount: u64,\r\n    lock_duration: i64,\r\n) -\u003e Instruction {\r\n    let mut data = vec![0u8; 8 + 8 + 8];\r\n    let discriminator = anchor_lang::solana_program::hash::hash(b\"global:stake\").to_bytes();\r\n    data[..8].copy_from_slice(\u0026discriminator[..8]);\r\n    data[8..16].copy_from_slice(\u0026amount.to_le_bytes());\r\n    data[16..24].copy_from_slice(\u0026lock_duration.to_le_bytes());\r\n\r\n    Instruction {\r\n        program_id: *program_id,\r\n        accounts: vec![\r\n            AccountMeta::new(*user, true),\r\n            AccountMeta::new(*pool, false),\r\n            AccountMeta::new(*user_stake, false),\r\n            AccountMeta::new_readonly(spl_token_2022::id(), false),\r\n            AccountMeta::new_readonly(solana_sdk::system_program::id(), false),\r\n        ],\r\n        data,\r\n    }\r\n}\r\n\r\npub fn create_unstake_ix(\r\n    program_id: \u0026Pubkey,\r\n    user: \u0026Pubkey,\r\n    pool: \u0026Pubkey,\r\n    user_stake: \u0026Pubkey,\r\n    amount: u64,\r\n) -\u003e Instruction {\r\n    let mut data = vec![0u8; 8 + 8];\r\n    let discriminator = anchor_lang::solana_program::hash::hash(b\"global:unstake\").to_bytes();\r\n    data[..8].copy_from_slice(\u0026discriminator[..8]);\r\n    data[8..16].copy_from_slice(\u0026amount.to_le_bytes());\r\n\r\n    Instruction {\r\n        program_id: *program_id,\r\n        accounts: vec![\r\n            AccountMeta::new(*user, true),\r\n            AccountMeta::new(*pool, false),\r\n            AccountMeta::new(*user_stake, false),\r\n            AccountMeta::new_readonly(spl_token_2022::id(), false),\r\n        ],\r\n        data,\r\n    }\r\n}\r\n\r\npub fn create_extend_lock_ix(\r\n    program_id: \u0026Pubkey,\r\n    user: \u0026Pubkey,\r\n    pool: \u0026Pubkey,\r\n    user_stake: \u0026Pubkey,\r\n    new_lock_duration: i64,\r\n) -\u003e Instruction {\r\n    let mut data = vec![0u8; 8 + 8];\r\n    let discriminator = anchor_lang::solana_program::hash::hash(b\"global:extend_lock\").to_bytes();\r\n    data[..8].copy_from_slice(\u0026discriminator[..8]);\r\n    data[8..16].copy_from_slice(\u0026new_lock_duration.to_le_bytes());\r\n\r\n    Instruction {\r\n        program_id: *program_id,\r\n        accounts: vec![\r\n            AccountMeta::new(*user, true),\r\n            AccountMeta::new_readonly(*pool, false),\r\n            AccountMeta::new(*user_stake, false),\r\n        ],\r\n        data,\r\n    }\r\n}\r\n\r\npub fn create_update_tier_ix(\r\n    program_id: \u0026Pubkey,\r\n    user: \u0026Pubkey,\r\n    pool: \u0026Pubkey,\r\n    user_stake: \u0026Pubkey,\r\n) -\u003e Instruction {\r\n    let mut data = vec![0u8; 8];\r\n    let discriminator = anchor_lang::solana_program::hash::hash(b\"global:update_tier\").to_bytes();\r\n    data[..8].copy_from_slice(\u0026discriminator[..8]);\r\n\r\n    Instruction {\r\n        program_id: *program_id,\r\n        accounts: vec![\r\n            AccountMeta::new(*user, true),\r\n            AccountMeta::new_readonly(*pool, false),\r\n            AccountMeta::new(*user_stake, false),\r\n        ],\r\n        data,\r\n    }\r\n}\r\n\r\npub fn create_set_paused_ix(\r\n    program_id: \u0026Pubkey,\r\n    authority: \u0026Pubkey,\r\n    pool: \u0026Pubkey,\r\n    paused: bool,\r\n) -\u003e Instruction {\r\n    let mut data = vec![0u8; 8 + 1];\r\n    let discriminator = anchor_lang::solana_program::hash::hash(b\"global:set_paused\").to_bytes();\r\n    data[..8].copy_from_slice(\u0026discriminator[..8]);\r\n    data[8] = if paused { 1 } else { 0 };\r\n\r\n    Instruction {\r\n        program_id: *program_id,\r\n        accounts: vec![\r\n            AccountMeta::new(*authority, true),\r\n            AccountMeta::new(*pool, false),\r\n        ],\r\n        data,\r\n    }\r\n}\r\n\r\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","staking-protocol","tests","extend.rs"],"content":"//! Integration tests for staking-protocol extend_lock instruction\r\n\r\nmod common;\r\n\r\nuse common::*;\r\nuse solana_sdk::signature::{Keypair, Signer};\r\n\r\nconst MIN_LOCK_DURATION: i64 = 7 * 24 * 60 * 60;\r\nconst MAX_LOCK_DURATION: i64 = 4 * 365 * 24 * 60 * 60;\r\n\r\n#[tokio::test]\r\nasync fn test_extend_lock_instruction_format() {\r\n    let ctx = TestContext::new().await;\r\n    \r\n    let (pool_pda, _bump) = ctx.get_pool_pda();\r\n    let user = Keypair::new();\r\n    let (user_stake_pda, _) = ctx.get_user_stake_pda(\u0026user.pubkey());\r\n    let new_lock_duration = 30 * 24 * 60 * 60i64; // 30 days\r\n    \r\n    let ix = create_extend_lock_ix(\r\n        \u0026ctx.program_id,\r\n        \u0026user.pubkey(),\r\n        \u0026pool_pda,\r\n        \u0026user_stake_pda,\r\n        new_lock_duration,\r\n    );\r\n    \r\n    assert_eq!(ix.program_id, ctx.program_id);\r\n    assert_eq!(ix.accounts.len(), 3);\r\n    assert!(ix.accounts[0].is_signer);\r\n    assert_eq!(\u0026ix.data[8..16], \u0026new_lock_duration.to_le_bytes());\r\n}\r\n\r\n#[tokio::test]\r\nasync fn test_extend_lock_to_max() {\r\n    let ctx = TestContext::new().await;\r\n    \r\n    let (pool_pda, _bump) = ctx.get_pool_pda();\r\n    let user = Keypair::new();\r\n    let (user_stake_pda, _) = ctx.get_user_stake_pda(\u0026user.pubkey());\r\n    \r\n    let ix = create_extend_lock_ix(\r\n        \u0026ctx.program_id,\r\n        \u0026user.pubkey(),\r\n        \u0026pool_pda,\r\n        \u0026user_stake_pda,\r\n        MAX_LOCK_DURATION,\r\n    );\r\n    \r\n    assert_eq!(\u0026ix.data[8..16], \u0026MAX_LOCK_DURATION.to_le_bytes());\r\n}\r\n\r\n#[tokio::test]\r\nasync fn test_extend_lock_exceeds_max() {\r\n    let ctx = TestContext::new().await;\r\n    \r\n    let (pool_pda, _bump) = ctx.get_pool_pda();\r\n    let user = Keypair::new();\r\n    let (user_stake_pda, _) = ctx.get_user_stake_pda(\u0026user.pubkey());\r\n    let too_long = MAX_LOCK_DURATION + 1;\r\n    \r\n    let ix = create_extend_lock_ix(\r\n        \u0026ctx.program_id,\r\n        \u0026user.pubkey(),\r\n        \u0026pool_pda,\r\n        \u0026user_stake_pda,\r\n        too_long,\r\n    );\r\n    \r\n    assert_eq!(\u0026ix.data[8..16], \u0026too_long.to_le_bytes());\r\n}\r\n\r\n#[tokio::test]\r\nasync fn test_extend_lock_double_duration() {\r\n    let ctx = TestContext::new().await;\r\n    \r\n    let (pool_pda, _bump) = ctx.get_pool_pda();\r\n    let user = Keypair::new();\r\n    let (user_stake_pda, _) = ctx.get_user_stake_pda(\u0026user.pubkey());\r\n    let double = MIN_LOCK_DURATION * 2;\r\n    \r\n    let ix = create_extend_lock_ix(\r\n        \u0026ctx.program_id,\r\n        \u0026user.pubkey(),\r\n        \u0026pool_pda,\r\n        \u0026user_stake_pda,\r\n        double,\r\n    );\r\n    \r\n    assert_eq!(\u0026ix.data[8..16], \u0026double.to_le_bytes());\r\n}\r\n\r\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","staking-protocol","tests","initialize.rs"],"content":"//! Integration tests for staking-protocol initialize_pool instruction\r\n\r\nmod common;\r\n\r\nuse common::*;\r\nuse solana_sdk::signature::{Keypair, Signer};\r\n\r\n#[tokio::test]\r\nasync fn test_initialize_pool_success() {\r\n    let mut ctx = TestContext::new().await;\r\n    \r\n    let (pool_pda, _bump) = ctx.get_pool_pda();\r\n    let vevcoin_program = Keypair::new();\r\n    \r\n    let ix = create_initialize_pool_ix(\r\n        \u0026ctx.program_id,\r\n        \u0026ctx.payer.pubkey(),\r\n        \u0026pool_pda,\r\n        \u0026vevcoin_program.pubkey(),\r\n    );\r\n    \r\n    let result = ctx.process_transaction(\u0026[ix], \u0026[]).await;\r\n    assert!(result.is_ok());\r\n    \r\n    let pool = ctx.get_account(pool_pda).await;\r\n    assert!(pool.is_some());\r\n}\r\n\r\n#[tokio::test]\r\nasync fn test_initialize_pool_already_initialized() {\r\n    let mut ctx = TestContext::new().await;\r\n    \r\n    let (pool_pda, _bump) = ctx.get_pool_pda();\r\n    let vevcoin_program = Keypair::new();\r\n    \r\n    let ix = create_initialize_pool_ix(\r\n        \u0026ctx.program_id,\r\n        \u0026ctx.payer.pubkey(),\r\n        \u0026pool_pda,\r\n        \u0026vevcoin_program.pubkey(),\r\n    );\r\n    \r\n    ctx.process_transaction(\u0026[ix.clone()], \u0026[]).await.unwrap();\r\n    \r\n    let result = ctx.process_transaction(\u0026[ix], \u0026[]).await;\r\n    assert!(result.is_err());\r\n}\r\n\r\n#[tokio::test]\r\nasync fn test_initialize_pool_with_vevcoin_program() {\r\n    let mut ctx = TestContext::new().await;\r\n    \r\n    let (pool_pda, _bump) = ctx.get_pool_pda();\r\n    let vevcoin_program = Keypair::new();\r\n    \r\n    let ix = create_initialize_pool_ix(\r\n        \u0026ctx.program_id,\r\n        \u0026ctx.payer.pubkey(),\r\n        \u0026pool_pda,\r\n        \u0026vevcoin_program.pubkey(),\r\n    );\r\n    \r\n    let result = ctx.process_transaction(\u0026[ix], \u0026[]).await;\r\n    assert!(result.is_ok());\r\n}\r\n\r\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","staking-protocol","tests","stake.rs"],"content":"//! Integration tests for staking-protocol stake instruction\r\n\r\nmod common;\r\n\r\nuse common::*;\r\nuse solana_sdk::signature::{Keypair, Signer};\r\n\r\nconst MIN_LOCK_DURATION: i64 = 7 * 24 * 60 * 60;  // 1 week\r\nconst MAX_LOCK_DURATION: i64 = 4 * 365 * 24 * 60 * 60;  // 4 years\r\n\r\n#[tokio::test]\r\nasync fn test_stake_instruction_format() {\r\n    let ctx = TestContext::new().await;\r\n    \r\n    let (pool_pda, _bump) = ctx.get_pool_pda();\r\n    let user = Keypair::new();\r\n    let (user_stake_pda, _) = ctx.get_user_stake_pda(\u0026user.pubkey());\r\n    let amount = 1000 * 1_000_000_000u64;\r\n    let lock_duration = MIN_LOCK_DURATION;\r\n    \r\n    let ix = create_stake_ix(\r\n        \u0026ctx.program_id,\r\n        \u0026user.pubkey(),\r\n        \u0026pool_pda,\r\n        \u0026user_stake_pda,\r\n        amount,\r\n        lock_duration,\r\n    );\r\n    \r\n    assert_eq!(ix.program_id, ctx.program_id);\r\n    assert_eq!(ix.accounts.len(), 5);\r\n    assert!(ix.accounts[0].is_signer);\r\n}\r\n\r\n#[tokio::test]\r\nasync fn test_stake_zero_amount() {\r\n    let ctx = TestContext::new().await;\r\n    \r\n    let (pool_pda, _bump) = ctx.get_pool_pda();\r\n    let user = Keypair::new();\r\n    let (user_stake_pda, _) = ctx.get_user_stake_pda(\u0026user.pubkey());\r\n    \r\n    let ix = create_stake_ix(\r\n        \u0026ctx.program_id,\r\n        \u0026user.pubkey(),\r\n        \u0026pool_pda,\r\n        \u0026user_stake_pda,\r\n        0,\r\n        MIN_LOCK_DURATION,\r\n    );\r\n    \r\n    assert_eq!(\u0026ix.data[8..16], \u00260u64.to_le_bytes());\r\n}\r\n\r\n#[tokio::test]\r\nasync fn test_stake_min_lock_duration() {\r\n    let ctx = TestContext::new().await;\r\n    \r\n    let (pool_pda, _bump) = ctx.get_pool_pda();\r\n    let user = Keypair::new();\r\n    let (user_stake_pda, _) = ctx.get_user_stake_pda(\u0026user.pubkey());\r\n    \r\n    let ix = create_stake_ix(\r\n        \u0026ctx.program_id,\r\n        \u0026user.pubkey(),\r\n        \u0026pool_pda,\r\n        \u0026user_stake_pda,\r\n        1000,\r\n        MIN_LOCK_DURATION,\r\n    );\r\n    \r\n    assert_eq!(\u0026ix.data[16..24], \u0026MIN_LOCK_DURATION.to_le_bytes());\r\n}\r\n\r\n#[tokio::test]\r\nasync fn test_stake_max_lock_duration() {\r\n    let ctx = TestContext::new().await;\r\n    \r\n    let (pool_pda, _bump) = ctx.get_pool_pda();\r\n    let user = Keypair::new();\r\n    let (user_stake_pda, _) = ctx.get_user_stake_pda(\u0026user.pubkey());\r\n    \r\n    let ix = create_stake_ix(\r\n        \u0026ctx.program_id,\r\n        \u0026user.pubkey(),\r\n        \u0026pool_pda,\r\n        \u0026user_stake_pda,\r\n        1000,\r\n        MAX_LOCK_DURATION,\r\n    );\r\n    \r\n    assert_eq!(\u0026ix.data[16..24], \u0026MAX_LOCK_DURATION.to_le_bytes());\r\n}\r\n\r\n#[tokio::test]\r\nasync fn test_stake_lock_duration_too_short() {\r\n    let ctx = TestContext::new().await;\r\n    \r\n    let (pool_pda, _bump) = ctx.get_pool_pda();\r\n    let user = Keypair::new();\r\n    let (user_stake_pda, _) = ctx.get_user_stake_pda(\u0026user.pubkey());\r\n    let too_short = MIN_LOCK_DURATION - 1;\r\n    \r\n    let ix = create_stake_ix(\r\n        \u0026ctx.program_id,\r\n        \u0026user.pubkey(),\r\n        \u0026pool_pda,\r\n        \u0026user_stake_pda,\r\n        1000,\r\n        too_short,\r\n    );\r\n    \r\n    assert_eq!(\u0026ix.data[16..24], \u0026too_short.to_le_bytes());\r\n}\r\n\r\n#[tokio::test]\r\nasync fn test_stake_lock_duration_too_long() {\r\n    let ctx = TestContext::new().await;\r\n    \r\n    let (pool_pda, _bump) = ctx.get_pool_pda();\r\n    let user = Keypair::new();\r\n    let (user_stake_pda, _) = ctx.get_user_stake_pda(\u0026user.pubkey());\r\n    let too_long = MAX_LOCK_DURATION + 1;\r\n    \r\n    let ix = create_stake_ix(\r\n        \u0026ctx.program_id,\r\n        \u0026user.pubkey(),\r\n        \u0026pool_pda,\r\n        \u0026user_stake_pda,\r\n        1000,\r\n        too_long,\r\n    );\r\n    \r\n    assert_eq!(\u0026ix.data[16..24], \u0026too_long.to_le_bytes());\r\n}\r\n\r\n#[tokio::test]\r\nasync fn test_stake_bronze_tier_amount() {\r\n    let ctx = TestContext::new().await;\r\n    \r\n    let (pool_pda, _bump) = ctx.get_pool_pda();\r\n    let user = Keypair::new();\r\n    let (user_stake_pda, _) = ctx.get_user_stake_pda(\u0026user.pubkey());\r\n    let bronze_amount = 1000 * 1_000_000_000u64;\r\n    \r\n    let ix = create_stake_ix(\r\n        \u0026ctx.program_id,\r\n        \u0026user.pubkey(),\r\n        \u0026pool_pda,\r\n        \u0026user_stake_pda,\r\n        bronze_amount,\r\n        MIN_LOCK_DURATION,\r\n    );\r\n    \r\n    assert_eq!(\u0026ix.data[8..16], \u0026bronze_amount.to_le_bytes());\r\n}\r\n\r\n#[tokio::test]\r\nasync fn test_stake_platinum_tier_amount() {\r\n    let ctx = TestContext::new().await;\r\n    \r\n    let (pool_pda, _bump) = ctx.get_pool_pda();\r\n    let user = Keypair::new();\r\n    let (user_stake_pda, _) = ctx.get_user_stake_pda(\u0026user.pubkey());\r\n    let platinum_amount = 100_000 * 1_000_000_000u64;\r\n    \r\n    let ix = create_stake_ix(\r\n        \u0026ctx.program_id,\r\n        \u0026user.pubkey(),\r\n        \u0026pool_pda,\r\n        \u0026user_stake_pda,\r\n        platinum_amount,\r\n        MIN_LOCK_DURATION,\r\n    );\r\n    \r\n    assert_eq!(\u0026ix.data[8..16], \u0026platinum_amount.to_le_bytes());\r\n}\r\n\r\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","staking-protocol","tests","tier.rs"],"content":"//! Integration tests for staking-protocol update_tier instruction\r\n\r\nmod common;\r\n\r\nuse common::*;\r\nuse solana_sdk::signature::{Keypair, Signer};\r\n\r\n#[tokio::test]\r\nasync fn test_update_tier_instruction_format() {\r\n    let ctx = TestContext::new().await;\r\n    \r\n    let (pool_pda, _bump) = ctx.get_pool_pda();\r\n    let user = Keypair::new();\r\n    let (user_stake_pda, _) = ctx.get_user_stake_pda(\u0026user.pubkey());\r\n    \r\n    let ix = create_update_tier_ix(\r\n        \u0026ctx.program_id,\r\n        \u0026user.pubkey(),\r\n        \u0026pool_pda,\r\n        \u0026user_stake_pda,\r\n    );\r\n    \r\n    assert_eq!(ix.program_id, ctx.program_id);\r\n    assert_eq!(ix.accounts.len(), 3);\r\n    assert!(ix.accounts[0].is_signer);\r\n    assert_eq!(ix.data.len(), 8);\r\n}\r\n\r\n#[tokio::test]\r\nasync fn test_update_tier_for_different_users() {\r\n    let ctx = TestContext::new().await;\r\n    \r\n    let (pool_pda, _bump) = ctx.get_pool_pda();\r\n    \r\n    for _ in 0..5 {\r\n        let user = Keypair::new();\r\n        let (user_stake_pda, _) = ctx.get_user_stake_pda(\u0026user.pubkey());\r\n        \r\n        let ix = create_update_tier_ix(\r\n            \u0026ctx.program_id,\r\n            \u0026user.pubkey(),\r\n            \u0026pool_pda,\r\n            \u0026user_stake_pda,\r\n        );\r\n        \r\n        assert_eq!(ix.accounts[0].pubkey, user.pubkey());\r\n    }\r\n}\r\n\r\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","staking-protocol","tests","unstake.rs"],"content":"//! Integration tests for staking-protocol unstake instruction\r\n\r\nmod common;\r\n\r\nuse common::*;\r\nuse solana_sdk::signature::{Keypair, Signer};\r\n\r\n#[tokio::test]\r\nasync fn test_unstake_instruction_format() {\r\n    let ctx = TestContext::new().await;\r\n    \r\n    let (pool_pda, _bump) = ctx.get_pool_pda();\r\n    let user = Keypair::new();\r\n    let (user_stake_pda, _) = ctx.get_user_stake_pda(\u0026user.pubkey());\r\n    let amount = 500u64;\r\n    \r\n    let ix = create_unstake_ix(\r\n        \u0026ctx.program_id,\r\n        \u0026user.pubkey(),\r\n        \u0026pool_pda,\r\n        \u0026user_stake_pda,\r\n        amount,\r\n    );\r\n    \r\n    assert_eq!(ix.program_id, ctx.program_id);\r\n    assert_eq!(ix.accounts.len(), 4);\r\n    assert!(ix.accounts[0].is_signer);\r\n    assert_eq!(\u0026ix.data[8..16], \u0026amount.to_le_bytes());\r\n}\r\n\r\n#[tokio::test]\r\nasync fn test_unstake_zero_amount() {\r\n    let ctx = TestContext::new().await;\r\n    \r\n    let (pool_pda, _bump) = ctx.get_pool_pda();\r\n    let user = Keypair::new();\r\n    let (user_stake_pda, _) = ctx.get_user_stake_pda(\u0026user.pubkey());\r\n    \r\n    let ix = create_unstake_ix(\r\n        \u0026ctx.program_id,\r\n        \u0026user.pubkey(),\r\n        \u0026pool_pda,\r\n        \u0026user_stake_pda,\r\n        0,\r\n    );\r\n    \r\n    assert_eq!(\u0026ix.data[8..16], \u00260u64.to_le_bytes());\r\n}\r\n\r\n#[tokio::test]\r\nasync fn test_unstake_partial_amount() {\r\n    let ctx = TestContext::new().await;\r\n    \r\n    let (pool_pda, _bump) = ctx.get_pool_pda();\r\n    let user = Keypair::new();\r\n    let (user_stake_pda, _) = ctx.get_user_stake_pda(\u0026user.pubkey());\r\n    let partial_amount = 500 * 1_000_000_000u64;\r\n    \r\n    let ix = create_unstake_ix(\r\n        \u0026ctx.program_id,\r\n        \u0026user.pubkey(),\r\n        \u0026pool_pda,\r\n        \u0026user_stake_pda,\r\n        partial_amount,\r\n    );\r\n    \r\n    assert_eq!(\u0026ix.data[8..16], \u0026partial_amount.to_le_bytes());\r\n}\r\n\r\n#[tokio::test]\r\nasync fn test_unstake_full_amount() {\r\n    let ctx = TestContext::new().await;\r\n    \r\n    let (pool_pda, _bump) = ctx.get_pool_pda();\r\n    let user = Keypair::new();\r\n    let (user_stake_pda, _) = ctx.get_user_stake_pda(\u0026user.pubkey());\r\n    let full_amount = 1000 * 1_000_000_000u64;\r\n    \r\n    let ix = create_unstake_ix(\r\n        \u0026ctx.program_id,\r\n        \u0026user.pubkey(),\r\n        \u0026pool_pda,\r\n        \u0026user_stake_pda,\r\n        full_amount,\r\n    );\r\n    \r\n    assert_eq!(\u0026ix.data[8..16], \u0026full_amount.to_le_bytes());\r\n}\r\n\r\n#[tokio::test]\r\nasync fn test_unstake_exceeds_balance() {\r\n    let ctx = TestContext::new().await;\r\n    \r\n    let (pool_pda, _bump) = ctx.get_pool_pda();\r\n    let user = Keypair::new();\r\n    let (user_stake_pda, _) = ctx.get_user_stake_pda(\u0026user.pubkey());\r\n    let excessive_amount = u64::MAX;\r\n    \r\n    let ix = create_unstake_ix(\r\n        \u0026ctx.program_id,\r\n        \u0026user.pubkey(),\r\n        \u0026pool_pda,\r\n        \u0026user_stake_pda,\r\n        excessive_amount,\r\n    );\r\n    \r\n    assert_eq!(\u0026ix.data[8..16], \u0026excessive_amount.to_le_bytes());\r\n}\r\n\r\n#[tokio::test]\r\nasync fn test_unstake_multiple_times() {\r\n    let ctx = TestContext::new().await;\r\n    \r\n    let (pool_pda, _bump) = ctx.get_pool_pda();\r\n    let user = Keypair::new();\r\n    let (user_stake_pda, _) = ctx.get_user_stake_pda(\u0026user.pubkey());\r\n    \r\n    for i in 1..=3 {\r\n        let amount = i * 100 * 1_000_000_000u64;\r\n        let ix = create_unstake_ix(\r\n            \u0026ctx.program_id,\r\n            \u0026user.pubkey(),\r\n            \u0026pool_pda,\r\n            \u0026user_stake_pda,\r\n            amount,\r\n        );\r\n        \r\n        assert_eq!(\u0026ix.data[8..16], \u0026amount.to_le_bytes());\r\n    }\r\n}\r\n\r\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","transfer-hook","src","constants.rs"],"content":"/// Transfer Hook Constants\r\n\r\n/// Minimum transfer amount to count as activity (1 VCoin)\r\npub const MIN_ACTIVITY_THRESHOLD: u64 = 1_000_000_000;\r\n\r\n/// Maximum transfers per hour before diminishing activity score\r\npub const MAX_TRANSFERS_PER_HOUR: u8 = 20;\r\n\r\n/// Wash trading detection: minimum time between transfers to same recipient\r\npub const WASH_TRADING_COOLDOWN_SECONDS: i64 = 3600; // 1 hour\r\n\r\n/// PDA Seeds\r\npub const HOOK_CONFIG_SEED: \u0026[u8] = b\"hook-config\";\r\npub const TRANSFER_RECORD_SEED: \u0026[u8] = b\"transfer-record\";\r\npub const USER_ACTIVITY_SEED: \u0026[u8] = b\"user-activity\";\r\npub const PAIR_TRACKING_SEED: \u0026[u8] = b\"pair-tracking\";\r\n\r\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","transfer-hook","src","contexts","execute.rs"],"content":"use anchor_lang::prelude::*;\r\nuse anchor_spl::token_interface::TokenAccount;\r\n\r\nuse crate::constants::{HOOK_CONFIG_SEED, USER_ACTIVITY_SEED, PAIR_TRACKING_SEED};\r\nuse crate::errors::TransferHookError;\r\nuse crate::state::{HookConfig, UserActivity, PairTracking};\r\n\r\n#[derive(Accounts)]\r\npub struct Execute\u003c'info\u003e {\r\n    #[account(\r\n        seeds = [HOOK_CONFIG_SEED],\r\n        bump = hook_config.bump\r\n    )]\r\n    pub hook_config: Account\u003c'info, HookConfig\u003e,\r\n    \r\n    /// Source token account - MUST use VCoin mint\r\n    #[account(constraint = sender.mint == hook_config.vcoin_mint @ TransferHookError::InvalidMint)]\r\n    pub sender: InterfaceAccount\u003c'info, TokenAccount\u003e,\r\n    \r\n    /// Destination token account - MUST use VCoin mint\r\n    #[account(constraint = receiver.mint == hook_config.vcoin_mint @ TransferHookError::InvalidMint)]\r\n    pub receiver: InterfaceAccount\u003c'info, TokenAccount\u003e,\r\n    \r\n    #[account(\r\n        init_if_needed,\r\n        payer = payer,\r\n        space = UserActivity::LEN,\r\n        seeds = [USER_ACTIVITY_SEED, sender.owner.as_ref()],\r\n        bump\r\n    )]\r\n    pub sender_activity: Account\u003c'info, UserActivity\u003e,\r\n    \r\n    #[account(\r\n        init_if_needed,\r\n        payer = payer,\r\n        space = UserActivity::LEN,\r\n        seeds = [USER_ACTIVITY_SEED, receiver.owner.as_ref()],\r\n        bump\r\n    )]\r\n    pub receiver_activity: Account\u003c'info, UserActivity\u003e,\r\n    \r\n    #[account(\r\n        init_if_needed,\r\n        payer = payer,\r\n        space = PairTracking::LEN,\r\n        seeds = [PAIR_TRACKING_SEED, sender.owner.as_ref(), receiver.owner.as_ref()],\r\n        bump\r\n    )]\r\n    pub pair_tracking: Account\u003c'info, PairTracking\u003e,\r\n    \r\n    #[account(mut)]\r\n    pub payer: Signer\u003c'info\u003e,\r\n    \r\n    pub system_program: Program\u003c'info, System\u003e,\r\n}\r\n\r\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","transfer-hook","src","contexts","get_pair_stats.rs"],"content":"use anchor_lang::prelude::*;\r\n\r\nuse crate::constants::PAIR_TRACKING_SEED;\r\nuse crate::state::PairTracking;\r\n\r\n#[derive(Accounts)]\r\npub struct GetPairStats\u003c'info\u003e {\r\n    #[account(\r\n        seeds = [PAIR_TRACKING_SEED, sender.key().as_ref(), receiver.key().as_ref()],\r\n        bump = pair_tracking.bump\r\n    )]\r\n    pub pair_tracking: Account\u003c'info, PairTracking\u003e,\r\n    \r\n    /// CHECK: Just used for PDA derivation\r\n    pub sender: UncheckedAccount\u003c'info\u003e,\r\n    \r\n    /// CHECK: Just used for PDA derivation\r\n    pub receiver: UncheckedAccount\u003c'info\u003e,\r\n}\r\n\r\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","transfer-hook","src","contexts","get_user_activity.rs"],"content":"use anchor_lang::prelude::*;\r\n\r\nuse crate::constants::USER_ACTIVITY_SEED;\r\nuse crate::state::UserActivity;\r\n\r\n#[derive(Accounts)]\r\n#[instruction()]\r\npub struct GetUserActivity\u003c'info\u003e {\r\n    #[account(\r\n        seeds = [USER_ACTIVITY_SEED, user.key().as_ref()],\r\n        bump = user_activity.bump\r\n    )]\r\n    pub user_activity: Account\u003c'info, UserActivity\u003e,\r\n    \r\n    /// CHECK: Just used for PDA derivation\r\n    pub user: UncheckedAccount\u003c'info\u003e,\r\n}\r\n\r\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","transfer-hook","src","contexts","initialize.rs"],"content":"use anchor_lang::prelude::*;\r\nuse anchor_spl::token_interface::Mint;\r\n\r\nuse crate::constants::HOOK_CONFIG_SEED;\r\nuse crate::state::HookConfig;\r\n\r\n#[derive(Accounts)]\r\npub struct Initialize\u003c'info\u003e {\r\n    #[account(\r\n        init,\r\n        payer = authority,\r\n        space = HookConfig::LEN,\r\n        seeds = [HOOK_CONFIG_SEED],\r\n        bump\r\n    )]\r\n    pub hook_config: Account\u003c'info, HookConfig\u003e,\r\n    \r\n    /// VCoin mint (Token-2022)\r\n    pub vcoin_mint: InterfaceAccount\u003c'info, Mint\u003e,\r\n    \r\n    #[account(mut)]\r\n    pub authority: Signer\u003c'info\u003e,\r\n    \r\n    pub system_program: Program\u003c'info, System\u003e,\r\n}\r\n\r\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","transfer-hook","src","contexts","initialize_extra_accounts.rs"],"content":"use anchor_lang::prelude::*;\r\nuse anchor_spl::token_interface::Mint;\r\n\r\n#[derive(Accounts)]\r\npub struct InitializeExtraAccountMetaList\u003c'info\u003e {\r\n    #[account(mut)]\r\n    pub payer: Signer\u003c'info\u003e,\r\n    \r\n    /// The extra account meta list account\r\n    /// CHECK: Validated by the transfer hook interface\r\n    #[account(mut)]\r\n    pub extra_account_meta_list: UncheckedAccount\u003c'info\u003e,\r\n    \r\n    pub vcoin_mint: InterfaceAccount\u003c'info, Mint\u003e,\r\n    \r\n    pub system_program: Program\u003c'info, System\u003e,\r\n}\r\n\r\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","transfer-hook","src","contexts","mod.rs"],"content":"/// Contexts module - Account validation structures\r\nmod initialize;\r\nmod execute;\r\nmod initialize_extra_accounts;\r\nmod update_config;\r\nmod update_authority;\r\nmod get_user_activity;\r\nmod get_pair_stats;\r\n\r\npub use initialize::*;\r\npub use execute::*;\r\npub use initialize_extra_accounts::*;\r\npub use update_config::*;\r\npub use update_authority::*;\r\npub use get_user_activity::*;\r\npub use get_pair_stats::*;\r\n\r\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","transfer-hook","src","contexts","update_authority.rs"],"content":"use anchor_lang::prelude::*;\r\n\r\nuse crate::constants::HOOK_CONFIG_SEED;\r\nuse crate::errors::TransferHookError;\r\nuse crate::state::HookConfig;\r\n\r\n#[derive(Accounts)]\r\npub struct UpdateAuthority\u003c'info\u003e {\r\n    #[account(\r\n        mut,\r\n        seeds = [HOOK_CONFIG_SEED],\r\n        bump = hook_config.bump,\r\n        has_one = authority @ TransferHookError::Unauthorized\r\n    )]\r\n    pub hook_config: Account\u003c'info, HookConfig\u003e,\r\n    \r\n    pub authority: Signer\u003c'info\u003e,\r\n}\r\n\r\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","transfer-hook","src","contexts","update_config.rs"],"content":"use anchor_lang::prelude::*;\r\n\r\nuse crate::constants::HOOK_CONFIG_SEED;\r\nuse crate::errors::TransferHookError;\r\nuse crate::state::HookConfig;\r\n\r\n#[derive(Accounts)]\r\npub struct UpdateConfig\u003c'info\u003e {\r\n    #[account(\r\n        mut,\r\n        seeds = [HOOK_CONFIG_SEED],\r\n        bump = hook_config.bump,\r\n        has_one = authority @ TransferHookError::Unauthorized\r\n    )]\r\n    pub hook_config: Account\u003c'info, HookConfig\u003e,\r\n    \r\n    pub authority: Signer\u003c'info\u003e,\r\n}\r\n\r\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","transfer-hook","src","errors.rs"],"content":"use anchor_lang::prelude::*;\r\n\r\n/// Transfer Hook Error Codes\r\n#[error_code]\r\npub enum TransferHookError {\r\n    #[msg(\"Unauthorized: Only the authority can perform this action\")]\r\n    Unauthorized,\r\n    \r\n    #[msg(\"Transfer hook is paused\")]\r\n    HookPaused,\r\n    \r\n    #[msg(\"Invalid program owner\")]\r\n    InvalidProgramOwner,\r\n    \r\n    #[msg(\"Wash trading pattern detected\")]\r\n    WashTradingDetected,\r\n    \r\n    #[msg(\"Arithmetic overflow\")]\r\n    Overflow,\r\n    \r\n    #[msg(\"Invalid extra account metas\")]\r\n    InvalidExtraAccountMetas,\r\n    \r\n    #[msg(\"Invalid token mint\")]\r\n    InvalidMint,\r\n}\r\n\r\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","transfer-hook","src","events.rs"],"content":"use anchor_lang::prelude::*;\r\n\r\n#[event]\r\npub struct TransferProcessed {\r\n    pub sender: Pubkey,\r\n    pub receiver: Pubkey,\r\n    pub amount: u64,\r\n    pub timestamp: i64,\r\n    pub is_tip: bool,\r\n}\r\n\r\n#[event]\r\npub struct WashTradingDetected {\r\n    pub sender: Pubkey,\r\n    pub receiver: Pubkey,\r\n    pub amount: u64,\r\n    pub timestamp: i64,\r\n    pub pair_transfers_24h: u16,\r\n}\r\n\r\n#[event]\r\npub struct ActivityScoreUpdated {\r\n    pub user: Pubkey,\r\n    pub new_contribution: u16,\r\n    pub transfers_this_hour: u8,\r\n}\r\n\r\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","transfer-hook","src","instructions","admin","initialize.rs"],"content":"use anchor_lang::prelude::*;\r\n\r\nuse crate::contexts::Initialize;\r\n\r\n/// Initialize the transfer hook configuration\r\npub fn handler(\r\n    ctx: Context\u003cInitialize\u003e,\r\n    five_a_program: Pubkey,\r\n    min_activity_amount: u64,\r\n) -\u003e Result\u003c()\u003e {\r\n    let config = \u0026mut ctx.accounts.hook_config;\r\n    \r\n    config.authority = ctx.accounts.authority.key();\r\n    config.vcoin_mint = ctx.accounts.vcoin_mint.key();\r\n    config.five_a_program = five_a_program;\r\n    config.block_wash_trading = false; // Start with flagging only\r\n    config.min_activity_amount = min_activity_amount;\r\n    config.total_transfers = 0;\r\n    config.wash_trading_flags = 0;\r\n    config.paused = false;\r\n    config.bump = ctx.bumps.hook_config;\r\n    \r\n    msg!(\"Transfer hook initialized for VCoin mint: {}\", config.vcoin_mint);\r\n    Ok(())\r\n}\r\n\r\n","traces":[{"line":6,"address":[],"length":0,"stats":{"Line":0}},{"line":11,"address":[],"length":0,"stats":{"Line":0}},{"line":13,"address":[],"length":0,"stats":{"Line":0}},{"line":14,"address":[],"length":0,"stats":{"Line":0}},{"line":15,"address":[],"length":0,"stats":{"Line":0}},{"line":16,"address":[],"length":0,"stats":{"Line":0}},{"line":17,"address":[],"length":0,"stats":{"Line":0}},{"line":18,"address":[],"length":0,"stats":{"Line":0}},{"line":19,"address":[],"length":0,"stats":{"Line":0}},{"line":20,"address":[],"length":0,"stats":{"Line":0}},{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":13},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","transfer-hook","src","instructions","admin","mod.rs"],"content":"/// Admin instructions\r\npub mod initialize;\r\npub mod update_config;\r\npub mod set_paused;\r\npub mod update_authority;\r\n\r\npub use initialize::*;\r\npub use update_config::*;\r\npub use set_paused::*;\r\npub use update_authority::*;\r\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","transfer-hook","src","instructions","admin","set_paused.rs"],"content":"use anchor_lang::prelude::*;\r\n\r\nuse crate::contexts::UpdateConfig;\r\n\r\n/// Pause/unpause the hook\r\npub fn handler(ctx: Context\u003cUpdateConfig\u003e, paused: bool) -\u003e Result\u003c()\u003e {\r\n    ctx.accounts.hook_config.paused = paused;\r\n    msg!(\"Hook paused status: {}\", paused);\r\n    Ok(())\r\n}\r\n\r\n","traces":[{"line":6,"address":[],"length":0,"stats":{"Line":0}},{"line":7,"address":[],"length":0,"stats":{"Line":0}},{"line":8,"address":[],"length":0,"stats":{"Line":0}},{"line":9,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":4},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","transfer-hook","src","instructions","admin","update_authority.rs"],"content":"use anchor_lang::prelude::*;\r\n\r\nuse crate::contexts::UpdateAuthority;\r\n\r\n/// Update authority\r\npub fn handler(ctx: Context\u003cUpdateAuthority\u003e, new_authority: Pubkey) -\u003e Result\u003c()\u003e {\r\n    ctx.accounts.hook_config.authority = new_authority;\r\n    msg!(\"Authority updated to: {}\", new_authority);\r\n    Ok(())\r\n}\r\n\r\n","traces":[{"line":6,"address":[],"length":0,"stats":{"Line":0}},{"line":7,"address":[],"length":0,"stats":{"Line":0}},{"line":8,"address":[],"length":0,"stats":{"Line":0}},{"line":9,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":4},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","transfer-hook","src","instructions","admin","update_config.rs"],"content":"use anchor_lang::prelude::*;\r\n\r\nuse crate::contexts::UpdateConfig;\r\n\r\n/// Update hook configuration\r\npub fn handler(\r\n    ctx: Context\u003cUpdateConfig\u003e,\r\n    new_five_a_program: Option\u003cPubkey\u003e,\r\n    new_min_activity_amount: Option\u003cu64\u003e,\r\n    block_wash_trading: Option\u003cbool\u003e,\r\n) -\u003e Result\u003c()\u003e {\r\n    let config = \u0026mut ctx.accounts.hook_config;\r\n    \r\n    if let Some(program) = new_five_a_program {\r\n        config.five_a_program = program;\r\n    }\r\n    if let Some(amount) = new_min_activity_amount {\r\n        config.min_activity_amount = amount;\r\n    }\r\n    if let Some(block) = block_wash_trading {\r\n        config.block_wash_trading = block;\r\n    }\r\n    \r\n    msg!(\"Hook config updated\");\r\n    Ok(())\r\n}\r\n\r\n","traces":[{"line":6,"address":[],"length":0,"stats":{"Line":0}},{"line":12,"address":[],"length":0,"stats":{"Line":0}},{"line":14,"address":[],"length":0,"stats":{"Line":0}},{"line":15,"address":[],"length":0,"stats":{"Line":0}},{"line":17,"address":[],"length":0,"stats":{"Line":0}},{"line":18,"address":[],"length":0,"stats":{"Line":0}},{"line":20,"address":[],"length":0,"stats":{"Line":0}},{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":10},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","transfer-hook","src","instructions","hook","execute.rs"],"content":"use anchor_lang::prelude::*;\r\n\r\nuse crate::contexts::Execute;\r\nuse crate::errors::TransferHookError;\r\nuse crate::events::{TransferProcessed, WashTradingDetected};\r\nuse crate::utils::{update_user_activity, check_wash_trading};\r\n\r\n/// Execute transfer hook - called automatically on every VCoin transfer\r\n/// This is the main entry point called by Token-2022\r\npub fn handler(ctx: Context\u003cExecute\u003e, amount: u64) -\u003e Result\u003c()\u003e {\r\n    let config = \u0026ctx.accounts.hook_config;\r\n    \r\n    // Check if hook is paused\r\n    require!(!config.paused, TransferHookError::HookPaused);\r\n    \r\n    let clock = Clock::get()?;\r\n    let current_time = clock.unix_timestamp;\r\n    \r\n    let sender_key = ctx.accounts.sender.key();\r\n    let receiver_key = ctx.accounts.receiver.key();\r\n    \r\n    // Update sender activity\r\n    let sender_activity = \u0026mut ctx.accounts.sender_activity;\r\n    update_user_activity(sender_activity, sender_key, amount, true, current_time)?;\r\n    \r\n    // Update receiver activity\r\n    let receiver_activity = \u0026mut ctx.accounts.receiver_activity;\r\n    update_user_activity(receiver_activity, receiver_key, amount, false, current_time)?;\r\n    \r\n    // Check for wash trading patterns\r\n    let pair_tracking = \u0026mut ctx.accounts.pair_tracking;\r\n    let is_wash_trading = check_wash_trading(\r\n        pair_tracking,\r\n        sender_key,\r\n        receiver_key,\r\n        amount,\r\n        current_time,\r\n    )?;\r\n    \r\n    if is_wash_trading {\r\n        emit!(WashTradingDetected {\r\n            sender: sender_key,\r\n            receiver: receiver_key,\r\n            amount,\r\n            timestamp: current_time,\r\n            pair_transfers_24h: pair_tracking.transfers_24h,\r\n        });\r\n        \r\n        // Note: We don't block, just flag. Blocking happens in governance decisions.\r\n    }\r\n    \r\n    // Emit transfer processed event\r\n    emit!(TransferProcessed {\r\n        sender: sender_key,\r\n        receiver: receiver_key,\r\n        amount,\r\n        timestamp: current_time,\r\n        is_tip: false, // Tip detection requires additional context\r\n    });\r\n    \r\n    Ok(())\r\n}\r\n\r\n","traces":[{"line":10,"address":[],"length":0,"stats":{"Line":0}},{"line":11,"address":[],"length":0,"stats":{"Line":0}},{"line":14,"address":[],"length":0,"stats":{"Line":0}},{"line":16,"address":[],"length":0,"stats":{"Line":0}},{"line":17,"address":[],"length":0,"stats":{"Line":0}},{"line":19,"address":[],"length":0,"stats":{"Line":0}},{"line":20,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":31},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","transfer-hook","src","instructions","hook","initialize_extra_accounts.rs"],"content":"use anchor_lang::prelude::*;\r\n\r\nuse crate::contexts::InitializeExtraAccountMetaList;\r\n\r\n/// Initialize extra account metas for the transfer hook\r\n/// Required by Token-2022 transfer hook interface\r\npub fn handler(_ctx: Context\u003cInitializeExtraAccountMetaList\u003e) -\u003e Result\u003c()\u003e {\r\n    // The extra accounts needed for the transfer hook execution\r\n    // These are stored in the ExtraAccountMetaList account\r\n    msg!(\"Extra account meta list initialized\");\r\n    Ok(())\r\n}\r\n\r\n","traces":[{"line":7,"address":[],"length":0,"stats":{"Line":0}},{"line":10,"address":[],"length":0,"stats":{"Line":0}},{"line":11,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":3},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","transfer-hook","src","instructions","hook","mod.rs"],"content":"/// Hook instructions\r\npub mod execute;\r\npub mod initialize_extra_accounts;\r\n\r\npub use execute::*;\r\npub use initialize_extra_accounts::*;\r\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","transfer-hook","src","instructions","mod.rs"],"content":"/// Instructions module - Instruction handlers\r\npub mod admin;\r\npub mod hook;\r\npub mod query;\r\n\r\npub use admin::*;\r\npub use hook::*;\r\npub use query::*;\r\n\r\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","transfer-hook","src","instructions","query","get_pair_stats.rs"],"content":"use anchor_lang::prelude::*;\r\n\r\nuse crate::contexts::GetPairStats;\r\n\r\n/// Query pair tracking stats\r\npub fn handler(ctx: Context\u003cGetPairStats\u003e) -\u003e Result\u003c()\u003e {\r\n    let pair = \u0026ctx.accounts.pair_tracking;\r\n    msg!(\"Sender: {}\", pair.sender);\r\n    msg!(\"Receiver: {}\", pair.receiver);\r\n    msg!(\"Transfers 24h: {}\", pair.transfers_24h);\r\n    msg!(\"Wash flags: {}\", pair.wash_flags);\r\n    msg!(\"Trust score: {}\", pair.trust_score);\r\n    Ok(())\r\n}\r\n\r\n","traces":[{"line":6,"address":[],"length":0,"stats":{"Line":0}},{"line":7,"address":[],"length":0,"stats":{"Line":0}},{"line":8,"address":[],"length":0,"stats":{"Line":0}},{"line":9,"address":[],"length":0,"stats":{"Line":0}},{"line":10,"address":[],"length":0,"stats":{"Line":0}},{"line":11,"address":[],"length":0,"stats":{"Line":0}},{"line":12,"address":[],"length":0,"stats":{"Line":0}},{"line":13,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":8},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","transfer-hook","src","instructions","query","get_user_activity.rs"],"content":"use anchor_lang::prelude::*;\r\n\r\nuse crate::contexts::GetUserActivity;\r\n\r\n/// Query user activity stats\r\npub fn handler(ctx: Context\u003cGetUserActivity\u003e) -\u003e Result\u003c()\u003e {\r\n    let activity = \u0026ctx.accounts.user_activity;\r\n    msg!(\"User: {}\", activity.user);\r\n    msg!(\"Total sent: {}\", activity.total_transfers_sent);\r\n    msg!(\"Total received: {}\", activity.total_transfers_received);\r\n    msg!(\"Activity contribution: {}\", activity.activity_score_contribution);\r\n    Ok(())\r\n}\r\n\r\n","traces":[{"line":6,"address":[],"length":0,"stats":{"Line":0}},{"line":7,"address":[],"length":0,"stats":{"Line":0}},{"line":8,"address":[],"length":0,"stats":{"Line":0}},{"line":9,"address":[],"length":0,"stats":{"Line":0}},{"line":10,"address":[],"length":0,"stats":{"Line":0}},{"line":11,"address":[],"length":0,"stats":{"Line":0}},{"line":12,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":7},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","transfer-hook","src","instructions","query","mod.rs"],"content":"/// Query instructions\r\npub mod get_user_activity;\r\npub mod get_pair_stats;\r\n\r\npub use get_user_activity::*;\r\npub use get_pair_stats::*;\r\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","transfer-hook","src","lib.rs"],"content":"use anchor_lang::prelude::*;\r\n\r\npub mod constants;\r\npub mod contexts;\r\npub mod errors;\r\npub mod events;\r\npub mod instructions;\r\npub mod state;\r\npub mod utils;\r\n\r\n#[cfg(test)]\r\nmod tests;\r\n\r\nuse contexts::*;\r\n\r\ndeclare_id!(\"9K14FcDRrBeHKD9FPNYeVJaEqJQTac2xspJyb1mM6m48\");\r\n\r\n/// VCoin Transfer Hook Program\r\n/// \r\n/// Implements Token-2022 Transfer Hook for:\r\n/// 1. Auto-updating 5A Activity scores on transfers\r\n/// 2. Recording tip transactions for SSCRE calculations\r\n/// 3. Detecting wash trading patterns\r\n/// 4. Updating engagement trust scores\r\n\r\n#[program]\r\npub mod transfer_hook {\r\n    use super::*;\r\n\r\n    /// Initialize the transfer hook configuration\r\n    pub fn initialize(\r\n        ctx: Context\u003cInitialize\u003e,\r\n        five_a_program: Pubkey,\r\n        min_activity_amount: u64,\r\n    ) -\u003e Result\u003c()\u003e {\r\n        instructions::admin::initialize::handler(ctx, five_a_program, min_activity_amount)\r\n    }\r\n    \r\n    /// Execute transfer hook - called automatically on every VCoin transfer\r\n    pub fn execute(ctx: Context\u003cExecute\u003e, amount: u64) -\u003e Result\u003c()\u003e {\r\n        instructions::hook::execute::handler(ctx, amount)\r\n    }\r\n    \r\n    /// Initialize extra account metas for the transfer hook\r\n    pub fn initialize_extra_account_meta_list(\r\n        ctx: Context\u003cInitializeExtraAccountMetaList\u003e,\r\n    ) -\u003e Result\u003c()\u003e {\r\n        instructions::hook::initialize_extra_accounts::handler(ctx)\r\n    }\r\n    \r\n    /// Update hook configuration\r\n    pub fn update_config(\r\n        ctx: Context\u003cUpdateConfig\u003e,\r\n        new_five_a_program: Option\u003cPubkey\u003e,\r\n        new_min_activity_amount: Option\u003cu64\u003e,\r\n        block_wash_trading: Option\u003cbool\u003e,\r\n    ) -\u003e Result\u003c()\u003e {\r\n        instructions::admin::update_config::handler(ctx, new_five_a_program, new_min_activity_amount, block_wash_trading)\r\n    }\r\n    \r\n    /// Pause/unpause the hook\r\n    pub fn set_paused(ctx: Context\u003cUpdateConfig\u003e, paused: bool) -\u003e Result\u003c()\u003e {\r\n        instructions::admin::set_paused::handler(ctx, paused)\r\n    }\r\n    \r\n    /// Update authority\r\n    pub fn update_authority(ctx: Context\u003cUpdateAuthority\u003e, new_authority: Pubkey) -\u003e Result\u003c()\u003e {\r\n        instructions::admin::update_authority::handler(ctx, new_authority)\r\n    }\r\n    \r\n    /// Query user activity stats\r\n    pub fn get_user_activity(ctx: Context\u003cGetUserActivity\u003e) -\u003e Result\u003c()\u003e {\r\n        instructions::query::get_user_activity::handler(ctx)\r\n    }\r\n    \r\n    /// Query pair tracking stats\r\n    pub fn get_pair_stats(ctx: Context\u003cGetPairStats\u003e) -\u003e Result\u003c()\u003e {\r\n        instructions::query::get_pair_stats::handler(ctx)\r\n    }\r\n}\r\n","traces":[{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":16},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","transfer-hook","src","state","config.rs"],"content":"use anchor_lang::prelude::*;\r\n\r\n/// Global hook configuration\r\n#[account]\r\n#[derive(Default)]\r\npub struct HookConfig {\r\n    /// Admin authority\r\n    pub authority: Pubkey,\r\n    /// VCoin mint address\r\n    pub vcoin_mint: Pubkey,\r\n    /// 5A Protocol program (for CPI calls)\r\n    pub five_a_program: Pubkey,\r\n    /// Whether wash trading blocking is enabled (vs just flagging)\r\n    pub block_wash_trading: bool,\r\n    /// Minimum amount for activity score increment\r\n    pub min_activity_amount: u64,\r\n    /// Total transfers processed\r\n    pub total_transfers: u64,\r\n    /// Total wash trading flags\r\n    pub wash_trading_flags: u64,\r\n    /// Whether hook is paused\r\n    pub paused: bool,\r\n    /// PDA bump\r\n    pub bump: u8,\r\n}\r\n\r\nimpl HookConfig {\r\n    pub const LEN: usize = 8 + // discriminator\r\n        32 + // authority\r\n        32 + // vcoin_mint\r\n        32 + // five_a_program\r\n        1 +  // block_wash_trading\r\n        8 +  // min_activity_amount\r\n        8 +  // total_transfers\r\n        8 +  // wash_trading_flags\r\n        1 +  // paused\r\n        1;   // bump\r\n}\r\n\r\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","transfer-hook","src","state","mod.rs"],"content":"/// State module - Account structures\r\nmod config;\r\nmod user_activity;\r\nmod pair_tracking;\r\nmod transfer_record;\r\n\r\npub use config::*;\r\npub use user_activity::*;\r\npub use pair_tracking::*;\r\npub use transfer_record::*;\r\n\r\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","transfer-hook","src","state","pair_tracking.rs"],"content":"use anchor_lang::prelude::*;\r\n\r\n/// Tracks transfer patterns between specific pairs for wash trading detection\r\n#[account]\r\n#[derive(Default)]\r\npub struct PairTracking {\r\n    /// Sender wallet\r\n    pub sender: Pubkey,\r\n    /// Receiver wallet\r\n    pub receiver: Pubkey,\r\n    /// Last transfer timestamp\r\n    pub last_transfer_time: i64,\r\n    /// Transfer count in last 24 hours\r\n    pub transfers_24h: u16,\r\n    /// Day reset timestamp\r\n    pub day_reset_time: i64,\r\n    /// Total amount transferred in 24h\r\n    pub amount_24h: u64,\r\n    /// Wash trading flag count\r\n    pub wash_flags: u16,\r\n    /// Engagement trust score (0-10000)\r\n    pub trust_score: u16,\r\n    /// PDA bump\r\n    pub bump: u8,\r\n}\r\n\r\nimpl PairTracking {\r\n    pub const LEN: usize = 8 + // discriminator\r\n        32 + // sender\r\n        32 + // receiver\r\n        8 +  // last_transfer_time\r\n        2 +  // transfers_24h\r\n        8 +  // day_reset_time\r\n        8 +  // amount_24h\r\n        2 +  // wash_flags\r\n        2 +  // trust_score\r\n        1;   // bump\r\n}\r\n\r\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","transfer-hook","src","state","transfer_record.rs"],"content":"use anchor_lang::prelude::*;\r\n\r\n/// Individual transfer record for audit trail\r\n#[account]\r\n#[derive(Default)]\r\npub struct TransferRecord {\r\n    /// Transfer ID (sequential)\r\n    pub transfer_id: u64,\r\n    /// Sender\r\n    pub sender: Pubkey,\r\n    /// Receiver\r\n    pub receiver: Pubkey,\r\n    /// Amount transferred\r\n    pub amount: u64,\r\n    /// Timestamp\r\n    pub timestamp: i64,\r\n    /// Whether this was flagged as wash trading\r\n    pub wash_trading_flag: bool,\r\n    /// Whether this was a tip transaction\r\n    pub is_tip: bool,\r\n    /// PDA bump\r\n    pub bump: u8,\r\n}\r\n\r\nimpl TransferRecord {\r\n    pub const LEN: usize = 8 + // discriminator\r\n        8 +  // transfer_id\r\n        32 + // sender\r\n        32 + // receiver\r\n        8 +  // amount\r\n        8 +  // timestamp\r\n        1 +  // wash_trading_flag\r\n        1 +  // is_tip\r\n        1;   // bump\r\n}\r\n\r\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","transfer-hook","src","state","user_activity.rs"],"content":"use anchor_lang::prelude::*;\r\n\r\n/// Per-user activity tracking for rate limiting\r\n#[account]\r\n#[derive(Default)]\r\npub struct UserActivity {\r\n    /// User wallet\r\n    pub user: Pubkey,\r\n    /// Transfers in current hour\r\n    pub transfers_this_hour: u8,\r\n    /// Hour reset timestamp\r\n    pub hour_reset_time: i64,\r\n    /// Total lifetime transfers sent\r\n    pub total_transfers_sent: u64,\r\n    /// Total lifetime transfers received\r\n    pub total_transfers_received: u64,\r\n    /// Total VCoin sent\r\n    pub total_amount_sent: u64,\r\n    /// Total VCoin received\r\n    pub total_amount_received: u64,\r\n    /// Last transfer timestamp\r\n    pub last_transfer_time: i64,\r\n    /// Activity score contribution (updated by 5A oracle)\r\n    pub activity_score_contribution: u16,\r\n    /// PDA bump\r\n    pub bump: u8,\r\n}\r\n\r\nimpl UserActivity {\r\n    pub const LEN: usize = 8 + // discriminator\r\n        32 + // user\r\n        1 +  // transfers_this_hour\r\n        8 +  // hour_reset_time\r\n        8 +  // total_transfers_sent\r\n        8 +  // total_transfers_received\r\n        8 +  // total_amount_sent\r\n        8 +  // total_amount_received\r\n        8 +  // last_transfer_time\r\n        2 +  // activity_score_contribution\r\n        1;   // bump\r\n}\r\n\r\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","transfer-hook","src","tests.rs"],"content":"//! Unit tests for Transfer Hook\r\n//!\r\n//! These tests run against the ACTUAL program code.\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n    use crate::constants::*;\r\n    use crate::state::{HookConfig, UserActivity, PairTracking};\r\n    use crate::utils::{update_user_activity, check_wash_trading};\r\n    use anchor_lang::prelude::Pubkey;\r\n\r\n    // ========================================================================\r\n    // Constants Tests\r\n    // ========================================================================\r\n\r\n    #[test]\r\n    fn test_min_activity_threshold() {\r\n        assert_eq!(MIN_ACTIVITY_THRESHOLD, 1_000_000_000, \"Min activity = 1 VCoin\");\r\n    }\r\n\r\n    #[test]\r\n    fn test_max_transfers_per_hour() {\r\n        assert_eq!(MAX_TRANSFERS_PER_HOUR, 20, \"Max 20 transfers/hour before diminishing\");\r\n    }\r\n\r\n    #[test]\r\n    fn test_wash_trading_cooldown() {\r\n        assert_eq!(WASH_TRADING_COOLDOWN_SECONDS, 3600, \"1 hour cooldown\");\r\n    }\r\n\r\n    // ========================================================================\r\n    // PDA Seeds Tests\r\n    // ========================================================================\r\n\r\n    #[test]\r\n    fn test_hook_config_seed() {\r\n        assert_eq!(HOOK_CONFIG_SEED, b\"hook-config\");\r\n    }\r\n\r\n    #[test]\r\n    fn test_transfer_record_seed() {\r\n        assert_eq!(TRANSFER_RECORD_SEED, b\"transfer-record\");\r\n    }\r\n\r\n    #[test]\r\n    fn test_user_activity_seed() {\r\n        assert_eq!(USER_ACTIVITY_SEED, b\"user-activity\");\r\n    }\r\n\r\n    #[test]\r\n    fn test_pair_tracking_seed() {\r\n        assert_eq!(PAIR_TRACKING_SEED, b\"pair-tracking\");\r\n    }\r\n\r\n    // ========================================================================\r\n    // State Size Tests\r\n    // ========================================================================\r\n\r\n    #[test]\r\n    fn test_hook_config_size() {\r\n        let expected = 8 + 32 + 32 + 32 + 1 + 8 + 8 + 8 + 1 + 1;\r\n        assert_eq!(HookConfig::LEN, expected, \"HookConfig size mismatch\");\r\n    }\r\n\r\n    #[test]\r\n    fn test_user_activity_size() {\r\n        let expected = 8 + 32 + 1 + 8 + 8 + 8 + 8 + 8 + 8 + 2 + 1;\r\n        assert_eq!(UserActivity::LEN, expected, \"UserActivity size mismatch\");\r\n    }\r\n\r\n    #[test]\r\n    fn test_pair_tracking_size() {\r\n        let expected = 8 + 32 + 32 + 8 + 2 + 8 + 8 + 2 + 2 + 1;\r\n        assert_eq!(PairTracking::LEN, expected, \"PairTracking size mismatch\");\r\n    }\r\n\r\n    // ========================================================================\r\n    // Activity Score Tests\r\n    // ========================================================================\r\n\r\n    #[test]\r\n    fn test_activity_contribution_within_limit() {\r\n        let mut activity = UserActivity::default();\r\n        let user = Pubkey::new_unique();\r\n        let current_time = 1000i64;\r\n        \r\n        update_user_activity(\u0026mut activity, user, MIN_ACTIVITY_THRESHOLD, true, current_time).unwrap();\r\n        \r\n        assert_eq!(activity.transfers_this_hour, 1);\r\n        assert_eq!(activity.activity_score_contribution, 100); // Full contribution\r\n    }\r\n\r\n    #[test]\r\n    fn test_activity_diminishing_returns() {\r\n        let mut activity = UserActivity::default();\r\n        activity.transfers_this_hour = 25; // Over MAX_TRANSFERS_PER_HOUR\r\n        activity.hour_reset_time = 500;\r\n        \r\n        let user = Pubkey::new_unique();\r\n        let current_time = 1000i64; // Same hour\r\n        \r\n        update_user_activity(\u0026mut activity, user, MIN_ACTIVITY_THRESHOLD, true, current_time).unwrap();\r\n        \r\n        // Should get diminished contribution (50/26 = 1)\r\n        assert!(activity.activity_score_contribution \u003c 100);\r\n    }\r\n\r\n    #[test]\r\n    fn test_hourly_reset() {\r\n        let mut activity = UserActivity::default();\r\n        activity.transfers_this_hour = 15;\r\n        activity.hour_reset_time = 0;\r\n        \r\n        let user = Pubkey::new_unique();\r\n        let current_time = 7200i64; // 2 hours later\r\n        \r\n        update_user_activity(\u0026mut activity, user, MIN_ACTIVITY_THRESHOLD, true, current_time).unwrap();\r\n        \r\n        // Should have reset and be at 1\r\n        assert_eq!(activity.transfers_this_hour, 1);\r\n        assert_eq!(activity.hour_reset_time, current_time);\r\n    }\r\n\r\n    // ========================================================================\r\n    // Transfer Tracking Tests\r\n    // ========================================================================\r\n\r\n    #[test]\r\n    fn test_sender_tracking() {\r\n        let mut activity = UserActivity::default();\r\n        let user = Pubkey::new_unique();\r\n        let amount = 5_000_000_000u64; // 5 VCoin\r\n        \r\n        update_user_activity(\u0026mut activity, user, amount, true, 1000).unwrap();\r\n        \r\n        assert_eq!(activity.total_transfers_sent, 1);\r\n        assert_eq!(activity.total_amount_sent, amount);\r\n        assert_eq!(activity.total_transfers_received, 0);\r\n        assert_eq!(activity.total_amount_received, 0);\r\n    }\r\n\r\n    #[test]\r\n    fn test_receiver_tracking() {\r\n        let mut activity = UserActivity::default();\r\n        let user = Pubkey::new_unique();\r\n        let amount = 5_000_000_000u64;\r\n        \r\n        update_user_activity(\u0026mut activity, user, amount, false, 1000).unwrap();\r\n        \r\n        assert_eq!(activity.total_transfers_received, 1);\r\n        assert_eq!(activity.total_amount_received, amount);\r\n        assert_eq!(activity.total_transfers_sent, 0);\r\n        assert_eq!(activity.total_amount_sent, 0);\r\n    }\r\n\r\n    #[test]\r\n    fn test_transfer_count_accumulates() {\r\n        let mut activity = UserActivity::default();\r\n        let user = Pubkey::new_unique();\r\n        \r\n        for i in 1..=5 {\r\n            update_user_activity(\u0026mut activity, user, MIN_ACTIVITY_THRESHOLD, true, 1000 + i).unwrap();\r\n        }\r\n        \r\n        assert_eq!(activity.total_transfers_sent, 5);\r\n    }\r\n\r\n    // ========================================================================\r\n    // Wash Trading Detection Tests\r\n    // ========================================================================\r\n\r\n    #[test]\r\n    fn test_wash_trading_not_detected_first_transfer() {\r\n        let mut pair = PairTracking::default();\r\n        let sender = Pubkey::new_unique();\r\n        let receiver = Pubkey::new_unique();\r\n        \r\n        let is_wash = check_wash_trading(\u0026mut pair, sender, receiver, MIN_ACTIVITY_THRESHOLD, 1000).unwrap();\r\n        \r\n        assert!(!is_wash, \"First transfer should not be flagged\");\r\n        assert_eq!(pair.trust_score, 5000 + 10); // Initial + rebuild\r\n    }\r\n\r\n    #[test]\r\n    fn test_wash_trading_high_frequency() {\r\n        let mut pair = PairTracking::default();\r\n        pair.sender = Pubkey::new_unique();\r\n        pair.receiver = Pubkey::new_unique();\r\n        pair.transfers_24h = 15; // High frequency\r\n        pair.last_transfer_time = 1000;\r\n        pair.trust_score = 5000;\r\n        pair.day_reset_time = 500;\r\n        \r\n        let sender = pair.sender;\r\n        let receiver = pair.receiver;\r\n        \r\n        // Rapid transfer (within cooldown)\r\n        let is_wash = check_wash_trading(\u0026mut pair, sender, receiver, MIN_ACTIVITY_THRESHOLD, 1500).unwrap();\r\n        \r\n        assert!(is_wash, \"Should detect wash trading pattern\");\r\n        assert_eq!(pair.wash_flags, 1);\r\n        assert_eq!(pair.trust_score, 4500); // Decreased by 500\r\n    }\r\n\r\n    #[test]\r\n    fn test_legitimate_transfer_rebuilds_trust() {\r\n        let mut pair = PairTracking::default();\r\n        pair.sender = Pubkey::new_unique();\r\n        pair.receiver = Pubkey::new_unique();\r\n        pair.transfers_24h = 2; // Low frequency\r\n        pair.last_transfer_time = 0;\r\n        pair.trust_score = 4000;\r\n        pair.day_reset_time = 0;\r\n        \r\n        let sender = pair.sender;\r\n        let receiver = pair.receiver;\r\n        \r\n        // Legitimate transfer (after cooldown)\r\n        let is_wash = check_wash_trading(\u0026mut pair, sender, receiver, MIN_ACTIVITY_THRESHOLD, 10000).unwrap();\r\n        \r\n        assert!(!is_wash, \"Should not be wash trading\");\r\n        assert_eq!(pair.trust_score, 4010); // Rebuilt by 10\r\n    }\r\n\r\n    #[test]\r\n    fn test_trust_score_bounded_at_max() {\r\n        let mut pair = PairTracking::default();\r\n        pair.sender = Pubkey::new_unique();\r\n        pair.receiver = Pubkey::new_unique();\r\n        pair.trust_score = 10000; // Already at max\r\n        pair.day_reset_time = 0;\r\n        \r\n        let sender = pair.sender;\r\n        let receiver = pair.receiver;\r\n        \r\n        check_wash_trading(\u0026mut pair, sender, receiver, MIN_ACTIVITY_THRESHOLD, 100000).unwrap();\r\n        \r\n        assert_eq!(pair.trust_score, 10000); // Should not exceed max\r\n    }\r\n\r\n    // ========================================================================\r\n    // Daily Reset Tests\r\n    // ========================================================================\r\n\r\n    #[test]\r\n    fn test_daily_reset_clears_counters() {\r\n        let mut pair = PairTracking::default();\r\n        pair.sender = Pubkey::new_unique();\r\n        pair.receiver = Pubkey::new_unique();\r\n        pair.transfers_24h = 50;\r\n        pair.amount_24h = 1_000_000_000_000;\r\n        pair.day_reset_time = 0;\r\n        pair.trust_score = 5000;\r\n        \r\n        let sender = pair.sender;\r\n        let receiver = pair.receiver;\r\n        \r\n        // Next day\r\n        check_wash_trading(\u0026mut pair, sender, receiver, MIN_ACTIVITY_THRESHOLD, 100000).unwrap();\r\n        \r\n        // Should have reset and started fresh\r\n        assert_eq!(pair.transfers_24h, 1); // Reset + this transfer\r\n    }\r\n\r\n    // ========================================================================\r\n    // Edge Case Tests\r\n    // ========================================================================\r\n\r\n    #[test]\r\n    fn test_same_sender_receiver_pda() {\r\n        // Same address sending to itself should have unique PDA\r\n        let program_id = Pubkey::new_unique();\r\n        let user = Pubkey::new_unique();\r\n        \r\n        let (pda, _) = Pubkey::find_program_address(\r\n            \u0026[PAIR_TRACKING_SEED, user.as_ref(), user.as_ref()],\r\n            \u0026program_id\r\n        );\r\n        \r\n        assert_ne!(pda, Pubkey::default());\r\n    }\r\n\r\n    #[test]\r\n    fn test_zero_amount_handling() {\r\n        let mut activity = UserActivity::default();\r\n        let user = Pubkey::new_unique();\r\n        \r\n        // Zero amount transfer\r\n        update_user_activity(\u0026mut activity, user, 0, true, 1000).unwrap();\r\n        \r\n        assert_eq!(activity.total_amount_sent, 0);\r\n        assert_eq!(activity.transfers_this_hour, 1); // Still counted\r\n    }\r\n\r\n    // ========================================================================\r\n    // Invariant Tests\r\n    // ========================================================================\r\n\r\n    #[test]\r\n    fn test_activity_score_bounded() {\r\n        let mut activity = UserActivity::default();\r\n        let user = Pubkey::new_unique();\r\n        \r\n        // Many transfers\r\n        for i in 0..1000 {\r\n            update_user_activity(\u0026mut activity, user, MIN_ACTIVITY_THRESHOLD, true, 1000 + i as i64).unwrap();\r\n        }\r\n        \r\n        // Score should be bounded (u16 max = 65535)\r\n        assert!(activity.activity_score_contribution \u003c= u16::MAX);\r\n    }\r\n\r\n    #[test]\r\n    fn test_trust_score_bounded_at_zero() {\r\n        let mut pair = PairTracking::default();\r\n        pair.sender = Pubkey::new_unique();\r\n        pair.receiver = Pubkey::new_unique();\r\n        pair.trust_score = 100; // Very low\r\n        pair.transfers_24h = 20;\r\n        pair.last_transfer_time = 500;\r\n        pair.day_reset_time = 0;\r\n        \r\n        let sender = pair.sender;\r\n        let receiver = pair.receiver;\r\n        \r\n        // Rapid wash trading\r\n        check_wash_trading(\u0026mut pair, sender, receiver, MIN_ACTIVITY_THRESHOLD, 600).unwrap();\r\n        \r\n        // Should not underflow\r\n        assert!(pair.trust_score \u003c= 100);\r\n    }\r\n\r\n    #[test]\r\n    fn test_transfer_count_monotonic() {\r\n        let mut activity = UserActivity::default();\r\n        let user = Pubkey::new_unique();\r\n        \r\n        let mut prev_sent = 0u64;\r\n        for i in 0..10 {\r\n            update_user_activity(\u0026mut activity, user, MIN_ACTIVITY_THRESHOLD, true, 1000 + i as i64).unwrap();\r\n            assert!(activity.total_transfers_sent \u003e= prev_sent, \"Transfer count should be monotonic\");\r\n            prev_sent = activity.total_transfers_sent;\r\n        }\r\n    }\r\n}\r\n\r\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","transfer-hook","src","utils.rs"],"content":"use anchor_lang::prelude::*;\r\n\r\nuse crate::constants::{MAX_TRANSFERS_PER_HOUR, WASH_TRADING_COOLDOWN_SECONDS};\r\nuse crate::events::ActivityScoreUpdated;\r\nuse crate::state::{UserActivity, PairTracking};\r\n\r\n/// Update user activity tracking\r\npub fn update_user_activity(\r\n    activity: \u0026mut UserActivity,\r\n    user: Pubkey,\r\n    amount: u64,\r\n    is_sender: bool,\r\n    current_time: i64,\r\n) -\u003e Result\u003c()\u003e {\r\n    // Initialize if new\r\n    if activity.user == Pubkey::default() {\r\n        activity.user = user;\r\n    }\r\n    \r\n    // Reset hourly counter if needed\r\n    if current_time \u003e= activity.hour_reset_time + 3600 {\r\n        activity.transfers_this_hour = 0;\r\n        activity.hour_reset_time = current_time;\r\n    }\r\n    \r\n    // Update counters\r\n    activity.transfers_this_hour = activity.transfers_this_hour.saturating_add(1);\r\n    activity.last_transfer_time = current_time;\r\n    \r\n    if is_sender {\r\n        activity.total_transfers_sent = activity.total_transfers_sent.saturating_add(1);\r\n        activity.total_amount_sent = activity.total_amount_sent.saturating_add(amount);\r\n    } else {\r\n        activity.total_transfers_received = activity.total_transfers_received.saturating_add(1);\r\n        activity.total_amount_received = activity.total_amount_received.saturating_add(amount);\r\n    }\r\n    \r\n    // Calculate activity score contribution\r\n    // Higher for consistent activity, diminishing for spam\r\n    let base_contribution = if activity.transfers_this_hour \u003c= MAX_TRANSFERS_PER_HOUR {\r\n        100_u16\r\n    } else {\r\n        // Diminishing returns for excessive transfers\r\n        50_u16.saturating_div(activity.transfers_this_hour as u16)\r\n    };\r\n    \r\n    activity.activity_score_contribution = \r\n        activity.activity_score_contribution.saturating_add(base_contribution);\r\n    \r\n    emit!(ActivityScoreUpdated {\r\n        user,\r\n        new_contribution: activity.activity_score_contribution,\r\n        transfers_this_hour: activity.transfers_this_hour,\r\n    });\r\n    \r\n    Ok(())\r\n}\r\n\r\n/// Check for wash trading patterns\r\npub fn check_wash_trading(\r\n    pair: \u0026mut PairTracking,\r\n    sender: Pubkey,\r\n    receiver: Pubkey,\r\n    amount: u64,\r\n    current_time: i64,\r\n) -\u003e Result\u003cbool\u003e {\r\n    // Initialize if new\r\n    if pair.sender == Pubkey::default() {\r\n        pair.sender = sender;\r\n        pair.receiver = receiver;\r\n        pair.trust_score = 5000; // Start neutral\r\n    }\r\n    \r\n    // Reset daily counter if needed\r\n    if current_time \u003e= pair.day_reset_time + 86400 {\r\n        pair.transfers_24h = 0;\r\n        pair.amount_24h = 0;\r\n        pair.day_reset_time = current_time;\r\n    }\r\n    \r\n    // Check for wash trading pattern\r\n    let time_since_last = current_time - pair.last_transfer_time;\r\n    let is_rapid_transfer = time_since_last \u003c WASH_TRADING_COOLDOWN_SECONDS \u0026\u0026 \r\n                            pair.last_transfer_time \u003e 0;\r\n    let is_high_frequency = pair.transfers_24h \u003e 10;\r\n    \r\n    // Update pair tracking\r\n    pair.last_transfer_time = current_time;\r\n    pair.transfers_24h = pair.transfers_24h.saturating_add(1);\r\n    pair.amount_24h = pair.amount_24h.saturating_add(amount);\r\n    \r\n    // Detect wash trading\r\n    let is_wash_trading = is_rapid_transfer \u0026\u0026 is_high_frequency;\r\n    \r\n    if is_wash_trading {\r\n        pair.wash_flags = pair.wash_flags.saturating_add(1);\r\n        // Decrease trust score\r\n        pair.trust_score = pair.trust_score.saturating_sub(500);\r\n    } else if pair.trust_score \u003c 10000 {\r\n        // Slowly rebuild trust for legitimate activity\r\n        pair.trust_score = pair.trust_score.saturating_add(10);\r\n    }\r\n    \r\n    Ok(is_wash_trading)\r\n}\r\n\r\n","traces":[{"line":8,"address":[],"length":0,"stats":{"Line":18230571291595767808}},{"line":16,"address":[],"length":0,"stats":{"Line":432345564227567619}},{"line":17,"address":[],"length":0,"stats":{"Line":648518346341351427}},{"line":21,"address":[],"length":0,"stats":{"Line":18302628885633695744}},{"line":22,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":23,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":27,"address":[],"length":0,"stats":{"Line":18230571291595767808}},{"line":28,"address":[],"length":0,"stats":{"Line":18230571291595767808}},{"line":30,"address":[],"length":0,"stats":{"Line":17942340915444056064}},{"line":31,"address":[],"length":0,"stats":{"Line":17870283321406128128}},{"line":32,"address":[],"length":0,"stats":{"Line":17870283321406128128}},{"line":34,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":35,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":40,"address":[],"length":0,"stats":{"Line":18014398509481984000}},{"line":41,"address":[],"length":0,"stats":{"Line":2882303761517117443}},{"line":44,"address":[],"length":0,"stats":{"Line":12249790986447749114}},{"line":47,"address":[],"length":0,"stats":{"Line":18230571291595767808}},{"line":48,"address":[],"length":0,"stats":{"Line":18014398509481984000}},{"line":50,"address":[],"length":0,"stats":{"Line":18014398509481984000}},{"line":51,"address":[],"length":0,"stats":{"Line":18014398509481984000}},{"line":52,"address":[],"length":0,"stats":{"Line":18230571291595767808}},{"line":53,"address":[],"length":0,"stats":{"Line":18230571291595767808}},{"line":56,"address":[],"length":0,"stats":{"Line":18230571291595767808}},{"line":60,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":68,"address":[],"length":0,"stats":{"Line":504403158265495552}},{"line":69,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":70,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":71,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":75,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":76,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":77,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":78,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":82,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":83,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":84,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":85,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":88,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":89,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":90,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":93,"address":[],"length":0,"stats":{"Line":1008806316530991104}},{"line":95,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":96,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":98,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":99,"address":[],"length":0,"stats":{"Line":648518346341351424}},{"line":101,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":104,"address":[],"length":0,"stats":{"Line":432345564227567616}}],"covered":46,"coverable":46},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","transfer-hook","tests","admin.rs"],"content":"//! Integration tests for transfer-hook admin instructions\r\n\r\nmod common;\r\n\r\nuse common::*;\r\nuse solana_sdk::signature::{Keypair, Signer};\r\n\r\n#[tokio::test]\r\nasync fn test_set_paused_true() {\r\n    let mut ctx = TestContext::new().await;\r\n    \r\n    let (config_pda, _bump) = ctx.get_config_pda();\r\n    let five_a_program = Keypair::new();\r\n    \r\n    let init_ix = create_initialize_ix(\r\n        \u0026ctx.program_id,\r\n        \u0026ctx.payer.pubkey(),\r\n        \u0026config_pda,\r\n        \u0026five_a_program.pubkey(),\r\n        1_000_000_000,\r\n    );\r\n    \r\n    ctx.process_transaction(\u0026[init_ix], \u0026[]).await.unwrap();\r\n    \r\n    let pause_ix = create_set_paused_ix(\r\n        \u0026ctx.program_id,\r\n        \u0026ctx.payer.pubkey(),\r\n        \u0026config_pda,\r\n        true,\r\n    );\r\n    \r\n    let result = ctx.process_transaction(\u0026[pause_ix], \u0026[]).await;\r\n    assert!(result.is_ok());\r\n}\r\n\r\n#[tokio::test]\r\nasync fn test_set_paused_false() {\r\n    let mut ctx = TestContext::new().await;\r\n    \r\n    let (config_pda, _bump) = ctx.get_config_pda();\r\n    let five_a_program = Keypair::new();\r\n    \r\n    let init_ix = create_initialize_ix(\r\n        \u0026ctx.program_id,\r\n        \u0026ctx.payer.pubkey(),\r\n        \u0026config_pda,\r\n        \u0026five_a_program.pubkey(),\r\n        1_000_000_000,\r\n    );\r\n    \r\n    ctx.process_transaction(\u0026[init_ix], \u0026[]).await.unwrap();\r\n    \r\n    let pause_ix = create_set_paused_ix(\u0026ctx.program_id, \u0026ctx.payer.pubkey(), \u0026config_pda, true);\r\n    ctx.process_transaction(\u0026[pause_ix], \u0026[]).await.unwrap();\r\n    \r\n    let unpause_ix = create_set_paused_ix(\u0026ctx.program_id, \u0026ctx.payer.pubkey(), \u0026config_pda, false);\r\n    let result = ctx.process_transaction(\u0026[unpause_ix], \u0026[]).await;\r\n    assert!(result.is_ok());\r\n}\r\n\r\n#[tokio::test]\r\nasync fn test_set_paused_unauthorized() {\r\n    let mut ctx = TestContext::new().await;\r\n    \r\n    let (config_pda, _bump) = ctx.get_config_pda();\r\n    let five_a_program = Keypair::new();\r\n    \r\n    let init_ix = create_initialize_ix(\r\n        \u0026ctx.program_id,\r\n        \u0026ctx.payer.pubkey(),\r\n        \u0026config_pda,\r\n        \u0026five_a_program.pubkey(),\r\n        1_000_000_000,\r\n    );\r\n    \r\n    ctx.process_transaction(\u0026[init_ix], \u0026[]).await.unwrap();\r\n    \r\n    let unauthorized = Keypair::new();\r\n    let pause_ix = create_set_paused_ix(\r\n        \u0026ctx.program_id,\r\n        \u0026unauthorized.pubkey(),\r\n        \u0026config_pda,\r\n        true,\r\n    );\r\n    \r\n    assert_eq!(pause_ix.accounts[0].pubkey, unauthorized.pubkey());\r\n}\r\n\r\n#[tokio::test]\r\nasync fn test_update_authority_success() {\r\n    let mut ctx = TestContext::new().await;\r\n    \r\n    let (config_pda, _bump) = ctx.get_config_pda();\r\n    let five_a_program = Keypair::new();\r\n    \r\n    let init_ix = create_initialize_ix(\r\n        \u0026ctx.program_id,\r\n        \u0026ctx.payer.pubkey(),\r\n        \u0026config_pda,\r\n        \u0026five_a_program.pubkey(),\r\n        1_000_000_000,\r\n    );\r\n    \r\n    ctx.process_transaction(\u0026[init_ix], \u0026[]).await.unwrap();\r\n    \r\n    let new_authority = Keypair::new();\r\n    let update_ix = create_update_authority_ix(\r\n        \u0026ctx.program_id,\r\n        \u0026ctx.payer.pubkey(),\r\n        \u0026config_pda,\r\n        \u0026new_authority.pubkey(),\r\n    );\r\n    \r\n    let result = ctx.process_transaction(\u0026[update_ix], \u0026[]).await;\r\n    assert!(result.is_ok());\r\n}\r\n\r\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","transfer-hook","tests","common","mod.rs"],"content":"//! Common test utilities for transfer-hook integration tests\r\n\r\nuse anchor_lang::prelude::*;\r\nuse solana_program_test::*;\r\nuse solana_sdk::{\r\n    account::Account,\r\n    hash::Hash,\r\n    instruction::{AccountMeta, Instruction},\r\n    pubkey::Pubkey,\r\n    signature::{Keypair, Signer},\r\n    system_instruction,\r\n    transaction::Transaction,\r\n};\r\n\r\npub const HOOK_CONFIG_SEED: \u0026[u8] = b\"hook-config\";\r\n\r\npub struct TestContext {\r\n    pub banks_client: BanksClient,\r\n    pub payer: Keypair,\r\n    pub recent_blockhash: Hash,\r\n    pub program_id: Pubkey,\r\n}\r\n\r\nimpl TestContext {\r\n    pub async fn new() -\u003e Self {\r\n        let program_id = transfer_hook::id();\r\n        let program_test = ProgramTest::new(\r\n            \"transfer_hook\",\r\n            program_id,\r\n            processor!(transfer_hook::entry),\r\n        );\r\n\r\n        let (banks_client, payer, recent_blockhash) = program_test.start().await;\r\n\r\n        Self {\r\n            banks_client,\r\n            payer,\r\n            recent_blockhash,\r\n            program_id,\r\n        }\r\n    }\r\n\r\n    pub async fn refresh_blockhash(\u0026mut self) {\r\n        self.recent_blockhash = self.banks_client.get_latest_blockhash().await.unwrap();\r\n    }\r\n\r\n    pub async fn get_account(\u0026mut self, pubkey: Pubkey) -\u003e Option\u003cAccount\u003e {\r\n        self.banks_client.get_account(pubkey).await.unwrap()\r\n    }\r\n\r\n    pub async fn airdrop(\u0026mut self, pubkey: \u0026Pubkey, lamports: u64) {\r\n        let ix = system_instruction::transfer(\u0026self.payer.pubkey(), pubkey, lamports);\r\n        let tx = Transaction::new_signed_with_payer(\r\n            \u0026[ix],\r\n            Some(\u0026self.payer.pubkey()),\r\n            \u0026[\u0026self.payer],\r\n            self.recent_blockhash,\r\n        );\r\n        self.banks_client.process_transaction(tx).await.unwrap();\r\n        self.refresh_blockhash().await;\r\n    }\r\n\r\n    pub fn get_config_pda(\u0026self) -\u003e (Pubkey, u8) {\r\n        Pubkey::find_program_address(\u0026[HOOK_CONFIG_SEED], \u0026self.program_id)\r\n    }\r\n\r\n    pub async fn process_transaction(\r\n        \u0026mut self,\r\n        instructions: \u0026[Instruction],\r\n        signers: \u0026[\u0026Keypair],\r\n    ) -\u003e Result\u003c(), BanksClientError\u003e {\r\n        let mut all_signers = vec![\u0026self.payer];\r\n        all_signers.extend(signers);\r\n        \r\n        let tx = Transaction::new_signed_with_payer(\r\n            instructions,\r\n            Some(\u0026self.payer.pubkey()),\r\n            \u0026all_signers,\r\n            self.recent_blockhash,\r\n        );\r\n        \r\n        let result = self.banks_client.process_transaction(tx).await;\r\n        self.refresh_blockhash().await;\r\n        result\r\n    }\r\n}\r\n\r\npub fn create_initialize_ix(\r\n    program_id: \u0026Pubkey,\r\n    authority: \u0026Pubkey,\r\n    config: \u0026Pubkey,\r\n    five_a_program: \u0026Pubkey,\r\n    min_activity_amount: u64,\r\n) -\u003e Instruction {\r\n    let mut data = vec![0u8; 8 + 32 + 8];\r\n    let discriminator = anchor_lang::solana_program::hash::hash(b\"global:initialize\").to_bytes();\r\n    data[..8].copy_from_slice(\u0026discriminator[..8]);\r\n    data[8..40].copy_from_slice(five_a_program.as_ref());\r\n    data[40..48].copy_from_slice(\u0026min_activity_amount.to_le_bytes());\r\n\r\n    Instruction {\r\n        program_id: *program_id,\r\n        accounts: vec![\r\n            AccountMeta::new(*authority, true),\r\n            AccountMeta::new(*config, false),\r\n            AccountMeta::new_readonly(solana_sdk::system_program::id(), false),\r\n        ],\r\n        data,\r\n    }\r\n}\r\n\r\npub fn create_execute_ix(\r\n    program_id: \u0026Pubkey,\r\n    source: \u0026Pubkey,\r\n    destination: \u0026Pubkey,\r\n    config: \u0026Pubkey,\r\n    amount: u64,\r\n) -\u003e Instruction {\r\n    let mut data = vec![0u8; 8 + 8];\r\n    let discriminator = anchor_lang::solana_program::hash::hash(b\"global:execute\").to_bytes();\r\n    data[..8].copy_from_slice(\u0026discriminator[..8]);\r\n    data[8..16].copy_from_slice(\u0026amount.to_le_bytes());\r\n\r\n    Instruction {\r\n        program_id: *program_id,\r\n        accounts: vec![\r\n            AccountMeta::new_readonly(*source, false),\r\n            AccountMeta::new_readonly(*destination, false),\r\n            AccountMeta::new_readonly(*config, false),\r\n        ],\r\n        data,\r\n    }\r\n}\r\n\r\npub fn create_set_paused_ix(\r\n    program_id: \u0026Pubkey,\r\n    authority: \u0026Pubkey,\r\n    config: \u0026Pubkey,\r\n    paused: bool,\r\n) -\u003e Instruction {\r\n    let mut data = vec![0u8; 8 + 1];\r\n    let discriminator = anchor_lang::solana_program::hash::hash(b\"global:set_paused\").to_bytes();\r\n    data[..8].copy_from_slice(\u0026discriminator[..8]);\r\n    data[8] = if paused { 1 } else { 0 };\r\n\r\n    Instruction {\r\n        program_id: *program_id,\r\n        accounts: vec![\r\n            AccountMeta::new(*authority, true),\r\n            AccountMeta::new(*config, false),\r\n        ],\r\n        data,\r\n    }\r\n}\r\n\r\npub fn create_update_authority_ix(\r\n    program_id: \u0026Pubkey,\r\n    authority: \u0026Pubkey,\r\n    config: \u0026Pubkey,\r\n    new_authority: \u0026Pubkey,\r\n) -\u003e Instruction {\r\n    let mut data = vec![0u8; 8 + 32];\r\n    let discriminator = anchor_lang::solana_program::hash::hash(b\"global:update_authority\").to_bytes();\r\n    data[..8].copy_from_slice(\u0026discriminator[..8]);\r\n    data[8..40].copy_from_slice(new_authority.as_ref());\r\n\r\n    Instruction {\r\n        program_id: *program_id,\r\n        accounts: vec![\r\n            AccountMeta::new(*authority, true),\r\n            AccountMeta::new(*config, false),\r\n        ],\r\n        data,\r\n    }\r\n}\r\n\r\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","transfer-hook","tests","execute.rs"],"content":"//! Integration tests for transfer-hook execute instruction\r\n\r\nmod common;\r\n\r\nuse common::*;\r\nuse solana_sdk::signature::{Keypair, Signer};\r\n\r\n#[tokio::test]\r\nasync fn test_execute_instruction_format() {\r\n    let ctx = TestContext::new().await;\r\n    \r\n    let (config_pda, _bump) = ctx.get_config_pda();\r\n    let source = Keypair::new();\r\n    let destination = Keypair::new();\r\n    let amount = 1_000_000_000u64;\r\n    \r\n    let ix = create_execute_ix(\r\n        \u0026ctx.program_id,\r\n        \u0026source.pubkey(),\r\n        \u0026destination.pubkey(),\r\n        \u0026config_pda,\r\n        amount,\r\n    );\r\n    \r\n    assert_eq!(ix.program_id, ctx.program_id);\r\n    assert_eq!(ix.accounts.len(), 3);\r\n    assert_eq!(\u0026ix.data[8..16], \u0026amount.to_le_bytes());\r\n}\r\n\r\n#[tokio::test]\r\nasync fn test_execute_zero_amount() {\r\n    let ctx = TestContext::new().await;\r\n    \r\n    let (config_pda, _bump) = ctx.get_config_pda();\r\n    let source = Keypair::new();\r\n    let destination = Keypair::new();\r\n    \r\n    let ix = create_execute_ix(\r\n        \u0026ctx.program_id,\r\n        \u0026source.pubkey(),\r\n        \u0026destination.pubkey(),\r\n        \u0026config_pda,\r\n        0,\r\n    );\r\n    \r\n    assert_eq!(\u0026ix.data[8..16], \u00260u64.to_le_bytes());\r\n}\r\n\r\n#[tokio::test]\r\nasync fn test_execute_large_amount() {\r\n    let ctx = TestContext::new().await;\r\n    \r\n    let (config_pda, _bump) = ctx.get_config_pda();\r\n    let source = Keypair::new();\r\n    let destination = Keypair::new();\r\n    let large_amount = u64::MAX;\r\n    \r\n    let ix = create_execute_ix(\r\n        \u0026ctx.program_id,\r\n        \u0026source.pubkey(),\r\n        \u0026destination.pubkey(),\r\n        \u0026config_pda,\r\n        large_amount,\r\n    );\r\n    \r\n    assert_eq!(\u0026ix.data[8..16], \u0026large_amount.to_le_bytes());\r\n}\r\n\r\n#[tokio::test]\r\nasync fn test_execute_same_source_dest() {\r\n    let ctx = TestContext::new().await;\r\n    \r\n    let (config_pda, _bump) = ctx.get_config_pda();\r\n    let same_account = Keypair::new();\r\n    \r\n    let ix = create_execute_ix(\r\n        \u0026ctx.program_id,\r\n        \u0026same_account.pubkey(),\r\n        \u0026same_account.pubkey(),\r\n        \u0026config_pda,\r\n        1000,\r\n    );\r\n    \r\n    assert_eq!(ix.accounts[0].pubkey, ix.accounts[1].pubkey);\r\n}\r\n\r\n#[tokio::test]\r\nasync fn test_execute_multiple_transfers() {\r\n    let mut ctx = TestContext::new().await;\r\n    \r\n    let (config_pda, _bump) = ctx.get_config_pda();\r\n    let five_a_program = Keypair::new();\r\n    \r\n    let init_ix = create_initialize_ix(\r\n        \u0026ctx.program_id,\r\n        \u0026ctx.payer.pubkey(),\r\n        \u0026config_pda,\r\n        \u0026five_a_program.pubkey(),\r\n        1_000_000_000,\r\n    );\r\n    \r\n    ctx.process_transaction(\u0026[init_ix], \u0026[]).await.unwrap();\r\n    \r\n    for i in 1..=5 {\r\n        let source = Keypair::new();\r\n        let destination = Keypair::new();\r\n        \r\n        let ix = create_execute_ix(\r\n            \u0026ctx.program_id,\r\n            \u0026source.pubkey(),\r\n            \u0026destination.pubkey(),\r\n            \u0026config_pda,\r\n            i * 1_000_000_000,\r\n        );\r\n        \r\n        assert_eq!(\u0026ix.data[8..16], \u0026(i * 1_000_000_000u64).to_le_bytes());\r\n    }\r\n}\r\n\r\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","transfer-hook","tests","initialize.rs"],"content":"//! Integration tests for transfer-hook initialize instruction\r\n\r\nmod common;\r\n\r\nuse common::*;\r\nuse solana_sdk::signature::{Keypair, Signer};\r\n\r\n#[tokio::test]\r\nasync fn test_initialize_success() {\r\n    let mut ctx = TestContext::new().await;\r\n    \r\n    let (config_pda, _bump) = ctx.get_config_pda();\r\n    let five_a_program = Keypair::new();\r\n    let min_activity_amount = 1_000_000_000u64;\r\n    \r\n    let ix = create_initialize_ix(\r\n        \u0026ctx.program_id,\r\n        \u0026ctx.payer.pubkey(),\r\n        \u0026config_pda,\r\n        \u0026five_a_program.pubkey(),\r\n        min_activity_amount,\r\n    );\r\n    \r\n    let result = ctx.process_transaction(\u0026[ix], \u0026[]).await;\r\n    assert!(result.is_ok());\r\n    \r\n    let config = ctx.get_account(config_pda).await;\r\n    assert!(config.is_some());\r\n}\r\n\r\n#[tokio::test]\r\nasync fn test_initialize_already_initialized() {\r\n    let mut ctx = TestContext::new().await;\r\n    \r\n    let (config_pda, _bump) = ctx.get_config_pda();\r\n    let five_a_program = Keypair::new();\r\n    \r\n    let ix = create_initialize_ix(\r\n        \u0026ctx.program_id,\r\n        \u0026ctx.payer.pubkey(),\r\n        \u0026config_pda,\r\n        \u0026five_a_program.pubkey(),\r\n        1_000_000_000,\r\n    );\r\n    \r\n    ctx.process_transaction(\u0026[ix.clone()], \u0026[]).await.unwrap();\r\n    \r\n    let result = ctx.process_transaction(\u0026[ix], \u0026[]).await;\r\n    assert!(result.is_err());\r\n}\r\n\r\n#[tokio::test]\r\nasync fn test_initialize_with_different_min_amounts() {\r\n    let mut ctx = TestContext::new().await;\r\n    \r\n    let (config_pda, _bump) = ctx.get_config_pda();\r\n    let five_a_program = Keypair::new();\r\n    \r\n    // Test with very low amount\r\n    let ix = create_initialize_ix(\r\n        \u0026ctx.program_id,\r\n        \u0026ctx.payer.pubkey(),\r\n        \u0026config_pda,\r\n        \u0026five_a_program.pubkey(),\r\n        1, // Very low\r\n    );\r\n    \r\n    let result = ctx.process_transaction(\u0026[ix], \u0026[]).await;\r\n    assert!(result.is_ok());\r\n}\r\n\r\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","vcoin-token","src","constants.rs"],"content":"/// VCoin Token Constants\r\n/// \r\n/// Token configuration and PDA seeds\r\n\r\n/// Token decimals (9 for VCoin)\r\npub const VCOIN_DECIMALS: u8 = 9;\r\n\r\n/// Total supply: 1 billion tokens with 9 decimals\r\npub const TOTAL_SUPPLY: u64 = 1_000_000_000 * 1_000_000_000;\r\n\r\n/// Token metadata\r\npub const TOKEN_NAME: \u0026str = \"VCoin\";\r\npub const TOKEN_SYMBOL: \u0026str = \"VIWO\";\r\npub const TOKEN_URI: \u0026str = \"https://viwoapp.com/vcoin-metadata.json\";\r\n\r\n/// PDA Seeds\r\npub const VCOIN_CONFIG_SEED: \u0026[u8] = b\"vcoin-config\";\r\n\r\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","vcoin-token","src","contexts","initialize_mint.rs"],"content":"use anchor_lang::prelude::*;\r\nuse anchor_spl::token_2022::Token2022;\r\n\r\nuse crate::constants::VCOIN_CONFIG_SEED;\r\nuse crate::state::VCoinConfig;\r\n\r\n#[derive(Accounts)]\r\npub struct InitializeMint\u003c'info\u003e {\r\n    #[account(mut)]\r\n    pub authority: Signer\u003c'info\u003e,\r\n    \r\n    #[account(\r\n        init,\r\n        payer = authority,\r\n        space = VCoinConfig::LEN,\r\n        seeds = [VCOIN_CONFIG_SEED],\r\n        bump\r\n    )]\r\n    pub config: Account\u003c'info, VCoinConfig\u003e,\r\n    \r\n    /// The VCoin mint (Token-2022)\r\n    /// CHECK: Validated by Token-2022 program\r\n    #[account(mut)]\r\n    pub mint: UncheckedAccount\u003c'info\u003e,\r\n    \r\n    /// Treasury token account\r\n    /// CHECK: Will be validated during token operations\r\n    pub treasury: UncheckedAccount\u003c'info\u003e,\r\n    \r\n    pub token_program: Program\u003c'info, Token2022\u003e,\r\n    pub system_program: Program\u003c'info, System\u003e,\r\n    pub rent: Sysvar\u003c'info, Rent\u003e,\r\n}\r\n\r\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","vcoin-token","src","contexts","mint_tokens.rs"],"content":"use anchor_lang::prelude::*;\r\nuse anchor_spl::token_2022::Token2022;\r\nuse anchor_spl::token_interface::{Mint, TokenAccount};\r\n\r\nuse crate::constants::VCOIN_CONFIG_SEED;\r\nuse crate::errors::VCoinError;\r\nuse crate::state::VCoinConfig;\r\n\r\n#[derive(Accounts)]\r\npub struct MintTokens\u003c'info\u003e {\r\n    #[account(mut)]\r\n    pub authority: Signer\u003c'info\u003e,\r\n    \r\n    #[account(\r\n        mut,\r\n        seeds = [VCOIN_CONFIG_SEED],\r\n        bump = config.bump\r\n    )]\r\n    pub config: Account\u003c'info, VCoinConfig\u003e,\r\n    \r\n    /// The VCoin mint\r\n    #[account(\r\n        mut,\r\n        constraint = mint.key() == config.mint @ VCoinError::InvalidMint\r\n    )]\r\n    pub mint: InterfaceAccount\u003c'info, Mint\u003e,\r\n    \r\n    /// Destination token account - MUST use VCoin mint\r\n    #[account(\r\n        mut,\r\n        constraint = destination.mint == config.mint @ VCoinError::InvalidMint\r\n    )]\r\n    pub destination: InterfaceAccount\u003c'info, TokenAccount\u003e,\r\n    \r\n    pub token_program: Program\u003c'info, Token2022\u003e,\r\n}\r\n\r\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","vcoin-token","src","contexts","mod.rs"],"content":"/// Contexts module - Account validation structures\r\nmod initialize_mint;\r\nmod mint_tokens;\r\nmod slash_tokens;\r\nmod update_config;\r\n\r\npub use initialize_mint::*;\r\npub use mint_tokens::*;\r\npub use slash_tokens::*;\r\npub use update_config::*;\r\n\r\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","vcoin-token","src","contexts","slash_tokens.rs"],"content":"use anchor_lang::prelude::*;\r\nuse anchor_spl::token_2022::Token2022;\r\nuse anchor_spl::token_interface::{Mint, TokenAccount};\r\n\r\nuse crate::constants::VCOIN_CONFIG_SEED;\r\nuse crate::errors::VCoinError;\r\nuse crate::state::VCoinConfig;\r\n\r\n#[derive(Accounts)]\r\npub struct SlashTokens\u003c'info\u003e {\r\n    /// The permanent delegate authority\r\n    #[account(mut)]\r\n    pub authority: Signer\u003c'info\u003e,\r\n    \r\n    #[account(\r\n        seeds = [VCOIN_CONFIG_SEED],\r\n        bump = config.bump\r\n    )]\r\n    pub config: Account\u003c'info, VCoinConfig\u003e,\r\n    \r\n    /// The VCoin mint\r\n    #[account(\r\n        mut,\r\n        constraint = mint.key() == config.mint @ VCoinError::InvalidMint\r\n    )]\r\n    pub mint: InterfaceAccount\u003c'info, Mint\u003e,\r\n    \r\n    /// Target account to slash tokens from - MUST use VCoin mint\r\n    #[account(\r\n        mut,\r\n        constraint = target_account.mint == config.mint @ VCoinError::InvalidMint\r\n    )]\r\n    pub target_account: InterfaceAccount\u003c'info, TokenAccount\u003e,\r\n    \r\n    pub token_program: Program\u003c'info, Token2022\u003e,\r\n}\r\n\r\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","vcoin-token","src","contexts","update_config.rs"],"content":"use anchor_lang::prelude::*;\r\n\r\nuse crate::constants::VCOIN_CONFIG_SEED;\r\nuse crate::state::VCoinConfig;\r\n\r\n#[derive(Accounts)]\r\npub struct UpdateConfig\u003c'info\u003e {\r\n    #[account(mut)]\r\n    pub authority: Signer\u003c'info\u003e,\r\n    \r\n    #[account(\r\n        mut,\r\n        seeds = [VCOIN_CONFIG_SEED],\r\n        bump = config.bump\r\n    )]\r\n    pub config: Account\u003c'info, VCoinConfig\u003e,\r\n}\r\n\r\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","vcoin-token","src","errors.rs"],"content":"use anchor_lang::prelude::*;\r\n\r\n/// VCoin Token Error Codes\r\n#[error_code]\r\npub enum VCoinError {\r\n    #[msg(\"Unauthorized: Only the authority can perform this action\")]\r\n    Unauthorized,\r\n    \r\n    #[msg(\"Mint is already initialized\")]\r\n    MintAlreadyInitialized,\r\n    \r\n    #[msg(\"Invalid mint authority\")]\r\n    InvalidMintAuthority,\r\n    \r\n    #[msg(\"Exceeds maximum supply\")]\r\n    ExceedsMaxSupply,\r\n    \r\n    #[msg(\"Slashing amount exceeds balance\")]\r\n    SlashingExceedsBalance,\r\n    \r\n    #[msg(\"Cannot slash zero tokens\")]\r\n    ZeroSlashAmount,\r\n    \r\n    #[msg(\"Token is paused\")]\r\n    TokenPaused,\r\n    \r\n    #[msg(\"Invalid token mint\")]\r\n    InvalidMint,\r\n}\r\n\r\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","vcoin-token","src","instructions","admin","initialize.rs"],"content":"use anchor_lang::prelude::*;\r\n\r\nuse crate::contexts::InitializeMint;\r\n\r\n/// Initialize the VCoin mint with Token-2022 extensions\r\n/// This creates the mint with:\r\n/// - Metadata extension\r\n/// - Permanent delegate extension (for slashing)\r\npub fn handler(ctx: Context\u003cInitializeMint\u003e, permanent_delegate: Pubkey) -\u003e Result\u003c()\u003e {\r\n    let config = \u0026mut ctx.accounts.config;\r\n    \r\n    config.authority = ctx.accounts.authority.key();\r\n    config.mint = ctx.accounts.mint.key();\r\n    config.treasury = ctx.accounts.treasury.key();\r\n    config.permanent_delegate = permanent_delegate;\r\n    config.total_minted = 0;\r\n    config.paused = false;\r\n    config.bump = ctx.bumps.config;\r\n    \r\n    msg!(\"VCoin mint initialized\");\r\n    msg!(\"Mint: {}\", config.mint);\r\n    msg!(\"Authority: {}\", config.authority);\r\n    msg!(\"Permanent Delegate: {}\", permanent_delegate);\r\n    \r\n    Ok(())\r\n}\r\n\r\n","traces":[{"line":9,"address":[],"length":0,"stats":{"Line":0}},{"line":10,"address":[],"length":0,"stats":{"Line":0}},{"line":12,"address":[],"length":0,"stats":{"Line":0}},{"line":13,"address":[],"length":0,"stats":{"Line":0}},{"line":14,"address":[],"length":0,"stats":{"Line":0}},{"line":15,"address":[],"length":0,"stats":{"Line":0}},{"line":16,"address":[],"length":0,"stats":{"Line":0}},{"line":17,"address":[],"length":0,"stats":{"Line":0}},{"line":18,"address":[],"length":0,"stats":{"Line":0}},{"line":20,"address":[],"length":0,"stats":{"Line":0}},{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":14},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","vcoin-token","src","instructions","admin","mod.rs"],"content":"/// Admin instructions\r\npub mod initialize;\r\npub mod set_paused;\r\npub mod update_authority;\r\npub mod update_delegate;\r\n\r\npub use initialize::*;\r\npub use set_paused::*;\r\npub use update_authority::*;\r\npub use update_delegate::*;\r\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","vcoin-token","src","instructions","admin","set_paused.rs"],"content":"use anchor_lang::prelude::*;\r\n\r\nuse crate::contexts::UpdateConfig;\r\nuse crate::errors::VCoinError;\r\n\r\n/// Pause/unpause token operations\r\n/// Only authority can pause\r\npub fn handler(ctx: Context\u003cUpdateConfig\u003e, paused: bool) -\u003e Result\u003c()\u003e {\r\n    let config = \u0026mut ctx.accounts.config;\r\n    \r\n    require!(\r\n        ctx.accounts.authority.key() == config.authority,\r\n        VCoinError::Unauthorized\r\n    );\r\n    \r\n    config.paused = paused;\r\n    \r\n    msg!(\"Token paused status: {}\", paused);\r\n    \r\n    Ok(())\r\n}\r\n\r\n","traces":[{"line":8,"address":[],"length":0,"stats":{"Line":0}},{"line":9,"address":[],"length":0,"stats":{"Line":0}},{"line":11,"address":[],"length":0,"stats":{"Line":0}},{"line":12,"address":[],"length":0,"stats":{"Line":0}},{"line":13,"address":[],"length":0,"stats":{"Line":0}},{"line":16,"address":[],"length":0,"stats":{"Line":0}},{"line":18,"address":[],"length":0,"stats":{"Line":0}},{"line":20,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":8},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","vcoin-token","src","instructions","admin","update_authority.rs"],"content":"use anchor_lang::prelude::*;\r\n\r\nuse crate::contexts::UpdateConfig;\r\nuse crate::errors::VCoinError;\r\n\r\n/// Update the authority\r\npub fn handler(ctx: Context\u003cUpdateConfig\u003e, new_authority: Pubkey) -\u003e Result\u003c()\u003e {\r\n    let config = \u0026mut ctx.accounts.config;\r\n    \r\n    require!(\r\n        ctx.accounts.authority.key() == config.authority,\r\n        VCoinError::Unauthorized\r\n    );\r\n    \r\n    config.authority = new_authority;\r\n    \r\n    msg!(\"Authority updated to: {}\", new_authority);\r\n    \r\n    Ok(())\r\n}\r\n\r\n","traces":[{"line":7,"address":[],"length":0,"stats":{"Line":0}},{"line":8,"address":[],"length":0,"stats":{"Line":0}},{"line":10,"address":[],"length":0,"stats":{"Line":0}},{"line":11,"address":[],"length":0,"stats":{"Line":0}},{"line":12,"address":[],"length":0,"stats":{"Line":0}},{"line":15,"address":[],"length":0,"stats":{"Line":0}},{"line":17,"address":[],"length":0,"stats":{"Line":0}},{"line":19,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":8},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","vcoin-token","src","instructions","admin","update_delegate.rs"],"content":"use anchor_lang::prelude::*;\r\n\r\nuse crate::contexts::UpdateConfig;\r\nuse crate::errors::VCoinError;\r\n\r\n/// Update the permanent delegate (for slashing)\r\npub fn handler(ctx: Context\u003cUpdateConfig\u003e, new_delegate: Pubkey) -\u003e Result\u003c()\u003e {\r\n    let config = \u0026mut ctx.accounts.config;\r\n    \r\n    require!(\r\n        ctx.accounts.authority.key() == config.authority,\r\n        VCoinError::Unauthorized\r\n    );\r\n    \r\n    config.permanent_delegate = new_delegate;\r\n    \r\n    msg!(\"Permanent delegate updated to: {}\", new_delegate);\r\n    \r\n    Ok(())\r\n}\r\n\r\n","traces":[{"line":7,"address":[],"length":0,"stats":{"Line":0}},{"line":8,"address":[],"length":0,"stats":{"Line":0}},{"line":10,"address":[],"length":0,"stats":{"Line":0}},{"line":11,"address":[],"length":0,"stats":{"Line":0}},{"line":12,"address":[],"length":0,"stats":{"Line":0}},{"line":15,"address":[],"length":0,"stats":{"Line":0}},{"line":17,"address":[],"length":0,"stats":{"Line":0}},{"line":19,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":8},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","vcoin-token","src","instructions","mod.rs"],"content":"/// Instructions module - Instruction handlers\r\npub mod admin;\r\npub mod token;\r\n\r\npub use admin::*;\r\npub use token::*;\r\n\r\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","vcoin-token","src","instructions","token","mint.rs"],"content":"use anchor_lang::prelude::*;\r\nuse anchor_spl::token_2022;\r\n\r\nuse crate::constants::{TOTAL_SUPPLY, VCOIN_CONFIG_SEED};\r\nuse crate::contexts::MintTokens;\r\nuse crate::errors::VCoinError;\r\n\r\n/// Mint VCoin tokens to a specified account\r\n/// Only the authority can mint tokens\r\npub fn handler(ctx: Context\u003cMintTokens\u003e, amount: u64) -\u003e Result\u003c()\u003e {\r\n    // Get config values for validation first\r\n    let authority = ctx.accounts.config.authority;\r\n    let paused = ctx.accounts.config.paused;\r\n    let total_minted = ctx.accounts.config.total_minted;\r\n    let bump = ctx.accounts.config.bump;\r\n    \r\n    // Check authorization\r\n    require!(\r\n        ctx.accounts.authority.key() == authority,\r\n        VCoinError::Unauthorized\r\n    );\r\n    \r\n    // Check not paused\r\n    require!(!paused, VCoinError::TokenPaused);\r\n    \r\n    // Check supply limit\r\n    require!(\r\n        total_minted.checked_add(amount).unwrap() \u003c= TOTAL_SUPPLY,\r\n        VCoinError::ExceedsMaxSupply\r\n    );\r\n    \r\n    // Mint tokens using Token-2022\r\n    let seeds = \u0026[\r\n        VCOIN_CONFIG_SEED,\r\n        \u0026[bump],\r\n    ];\r\n    let signer_seeds = \u0026[\u0026seeds[..]];\r\n    \r\n    token_2022::mint_to(\r\n        CpiContext::new_with_signer(\r\n            ctx.accounts.token_program.to_account_info(),\r\n            token_2022::MintTo {\r\n                mint: ctx.accounts.mint.to_account_info(),\r\n                to: ctx.accounts.destination.to_account_info(),\r\n                authority: ctx.accounts.config.to_account_info(),\r\n            },\r\n            signer_seeds,\r\n        ),\r\n        amount,\r\n    )?;\r\n    \r\n    // Update total minted\r\n    ctx.accounts.config.total_minted = total_minted.checked_add(amount).unwrap();\r\n    \r\n    msg!(\"Minted {} VCoin tokens\", amount);\r\n    msg!(\"Total minted: {}\", ctx.accounts.config.total_minted);\r\n    \r\n    Ok(())\r\n}\r\n\r\n","traces":[{"line":10,"address":[],"length":0,"stats":{"Line":0}},{"line":12,"address":[],"length":0,"stats":{"Line":0}},{"line":13,"address":[],"length":0,"stats":{"Line":0}},{"line":14,"address":[],"length":0,"stats":{"Line":0}},{"line":15,"address":[],"length":0,"stats":{"Line":0}},{"line":18,"address":[],"length":0,"stats":{"Line":0}},{"line":19,"address":[],"length":0,"stats":{"Line":0}},{"line":20,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":28},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","vcoin-token","src","instructions","token","mod.rs"],"content":"/// Token instructions\r\npub mod mint;\r\npub mod slash;\r\n\r\npub use mint::*;\r\npub use slash::*;\r\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","vcoin-token","src","instructions","token","slash.rs"],"content":"use anchor_lang::prelude::*;\r\nuse anchor_spl::token_2022;\r\n\r\nuse crate::constants::VCOIN_CONFIG_SEED;\r\nuse crate::contexts::SlashTokens;\r\nuse crate::errors::VCoinError;\r\n\r\n/// Slash tokens from an account using permanent delegate authority\r\n/// This is used for penalizing bad actors\r\npub fn handler(ctx: Context\u003cSlashTokens\u003e, amount: u64) -\u003e Result\u003c()\u003e {\r\n    let config = \u0026ctx.accounts.config;\r\n    \r\n    // Check authorization (only permanent delegate can slash)\r\n    require!(\r\n        ctx.accounts.authority.key() == config.permanent_delegate,\r\n        VCoinError::Unauthorized\r\n    );\r\n    \r\n    require!(amount \u003e 0, VCoinError::ZeroSlashAmount);\r\n    \r\n    // Check balance\r\n    let account_balance = ctx.accounts.target_account.amount;\r\n    require!(\r\n        account_balance \u003e= amount,\r\n        VCoinError::SlashingExceedsBalance\r\n    );\r\n    \r\n    // Burn the slashed tokens using permanent delegate authority\r\n    let seeds = \u0026[\r\n        VCOIN_CONFIG_SEED,\r\n        \u0026[config.bump],\r\n    ];\r\n    let signer_seeds = \u0026[\u0026seeds[..]];\r\n    \r\n    token_2022::burn(\r\n        CpiContext::new_with_signer(\r\n            ctx.accounts.token_program.to_account_info(),\r\n            token_2022::Burn {\r\n                mint: ctx.accounts.mint.to_account_info(),\r\n                from: ctx.accounts.target_account.to_account_info(),\r\n                authority: ctx.accounts.config.to_account_info(),\r\n            },\r\n            signer_seeds,\r\n        ),\r\n        amount,\r\n    )?;\r\n    \r\n    msg!(\"Slashed {} VCoin tokens from {}\", amount, ctx.accounts.target_account.key());\r\n    \r\n    Ok(())\r\n}\r\n\r\n","traces":[{"line":10,"address":[],"length":0,"stats":{"Line":0}},{"line":11,"address":[],"length":0,"stats":{"Line":0}},{"line":14,"address":[],"length":0,"stats":{"Line":0}},{"line":15,"address":[],"length":0,"stats":{"Line":0}},{"line":16,"address":[],"length":0,"stats":{"Line":0}},{"line":19,"address":[],"length":0,"stats":{"Line":0}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":24},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","vcoin-token","src","lib.rs"],"content":"use anchor_lang::prelude::*;\r\n\r\npub mod constants;\r\npub mod contexts;\r\npub mod errors;\r\npub mod instructions;\r\npub mod state;\r\n\r\n#[cfg(test)]\r\nmod tests;\r\n\r\nuse contexts::*;\r\n\r\ndeclare_id!(\"Gg1dtrjAfGYi6NLC31WaJjZNBoucvD98rK2h1u9qrUjn\");\r\n\r\n/// VCoin Token-2022 with Extensions\r\n/// - Metadata: On-chain token metadata (Name: VCoin, Symbol: VIWO)\r\n/// - Permanent Delegate: Slashing authority for governance multisig\r\n/// - Transfer Hook: Auto-update 5A scores (prepared, hook program separate)\r\n/// \r\n/// Total Supply: 1,000,000,000 (1B)\r\n/// Decimals: 9\r\n\r\n#[program]\r\npub mod vcoin_token {\r\n    use super::*;\r\n\r\n    /// Initialize the VCoin mint with Token-2022 extensions\r\n    pub fn initialize_mint(\r\n        ctx: Context\u003cInitializeMint\u003e,\r\n        permanent_delegate: Pubkey,\r\n    ) -\u003e Result\u003c()\u003e {\r\n        instructions::admin::initialize::handler(ctx, permanent_delegate)\r\n    }\r\n\r\n    /// Mint VCoin tokens to a specified account\r\n    pub fn mint_tokens(ctx: Context\u003cMintTokens\u003e, amount: u64) -\u003e Result\u003c()\u003e {\r\n        instructions::token::mint::handler(ctx, amount)\r\n    }\r\n\r\n    /// Slash tokens from an account using permanent delegate authority\r\n    pub fn slash_tokens(ctx: Context\u003cSlashTokens\u003e, amount: u64) -\u003e Result\u003c()\u003e {\r\n        instructions::token::slash::handler(ctx, amount)\r\n    }\r\n\r\n    /// Pause/unpause token operations\r\n    pub fn set_paused(ctx: Context\u003cUpdateConfig\u003e, paused: bool) -\u003e Result\u003c()\u003e {\r\n        instructions::admin::set_paused::handler(ctx, paused)\r\n    }\r\n\r\n    /// Update the authority\r\n    pub fn update_authority(ctx: Context\u003cUpdateConfig\u003e, new_authority: Pubkey) -\u003e Result\u003c()\u003e {\r\n        instructions::admin::update_authority::handler(ctx, new_authority)\r\n    }\r\n\r\n    /// Update the permanent delegate (for slashing)\r\n    pub fn update_permanent_delegate(\r\n        ctx: Context\u003cUpdateConfig\u003e,\r\n        new_delegate: Pubkey,\r\n    ) -\u003e Result\u003c()\u003e {\r\n        instructions::admin::update_delegate::handler(ctx, new_delegate)\r\n    }\r\n}\r\n","traces":[{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":12},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","vcoin-token","src","state","config.rs"],"content":"use anchor_lang::prelude::*;\r\n\r\n/// VCoin Configuration Account (Singleton PDA)\r\n/// Stores global configuration for the VCoin token\r\n#[account]\r\n#[derive(Default)]\r\npub struct VCoinConfig {\r\n    /// The authority that can mint tokens and update config\r\n    pub authority: Pubkey,\r\n    /// The VCoin mint address\r\n    pub mint: Pubkey,\r\n    /// The treasury token account that receives initial minted tokens\r\n    pub treasury: Pubkey,\r\n    /// The permanent delegate for slashing (governance multisig)\r\n    pub permanent_delegate: Pubkey,\r\n    /// Total tokens minted so far\r\n    pub total_minted: u64,\r\n    /// Whether token operations are paused\r\n    pub paused: bool,\r\n    /// Bump seed for PDA\r\n    pub bump: u8,\r\n}\r\n\r\nimpl VCoinConfig {\r\n    pub const LEN: usize = 8 + // discriminator\r\n        32 + // authority\r\n        32 + // mint\r\n        32 + // treasury\r\n        32 + // permanent_delegate\r\n        8 +  // total_minted\r\n        1 +  // paused\r\n        1;   // bump\r\n}\r\n\r\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","vcoin-token","src","state","mod.rs"],"content":"/// State module - Account structures\r\nmod config;\r\n\r\npub use config::*;\r\n\r\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","vcoin-token","src","tests.rs"],"content":"//! Unit tests for VCoin Token\r\n//!\r\n//! These tests run against the ACTUAL program code.\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n    use crate::constants::*;\r\n    use crate::state::VCoinConfig;\r\n    use anchor_lang::prelude::Pubkey;\r\n\r\n    // ========================================================================\r\n    // Constants Tests\r\n    // ========================================================================\r\n\r\n    #[test]\r\n    fn test_vcoin_decimals() {\r\n        assert_eq!(VCOIN_DECIMALS, 9, \"VCoin should have 9 decimals\");\r\n    }\r\n\r\n    #[test]\r\n    fn test_total_supply() {\r\n        // 1 billion tokens with 9 decimals\r\n        let expected = 1_000_000_000u64 * 1_000_000_000u64;\r\n        assert_eq!(TOTAL_SUPPLY, expected, \"Total supply should be 1B with 9 decimals\");\r\n    }\r\n\r\n    #[test]\r\n    fn test_one_vcoin() {\r\n        // 1 VCoin = 10^9 base units\r\n        let one_vcoin = 10u64.pow(VCOIN_DECIMALS as u32);\r\n        assert_eq!(one_vcoin, 1_000_000_000, \"1 VCoin = 1e9 base units\");\r\n    }\r\n\r\n    #[test]\r\n    fn test_token_metadata() {\r\n        assert_eq!(TOKEN_NAME, \"VCoin\");\r\n        assert_eq!(TOKEN_SYMBOL, \"VIWO\");\r\n        assert!(TOKEN_URI.starts_with(\"https://\"), \"URI should be HTTPS\");\r\n    }\r\n\r\n    // ========================================================================\r\n    // PDA Derivation Tests\r\n    // ========================================================================\r\n\r\n    #[test]\r\n    fn test_config_pda_seed() {\r\n        assert_eq!(VCOIN_CONFIG_SEED, b\"vcoin-config\");\r\n    }\r\n\r\n    #[test]\r\n    fn test_config_pda_derivation() {\r\n        // Verify PDA can be derived with the seed\r\n        let program_id = Pubkey::new_unique();\r\n        let (pda, bump) = Pubkey::find_program_address(\r\n            \u0026[VCOIN_CONFIG_SEED],\r\n            \u0026program_id\r\n        );\r\n        \r\n        // PDA should be valid (off-curve)\r\n        assert!(bump \u003c= 255);\r\n        assert_ne!(pda, Pubkey::default());\r\n    }\r\n\r\n    // ========================================================================\r\n    // State Tests\r\n    // ========================================================================\r\n\r\n    #[test]\r\n    fn test_vcoin_config_size() {\r\n        // Verify the account size calculation\r\n        let expected_size = 8 + 32 + 32 + 32 + 32 + 8 + 1 + 1;\r\n        assert_eq!(VCoinConfig::LEN, expected_size, \"Config size mismatch\");\r\n    }\r\n\r\n    #[test]\r\n    fn test_vcoin_config_default() {\r\n        let config = VCoinConfig::default();\r\n        assert_eq!(config.total_minted, 0);\r\n        assert!(!config.paused);\r\n        assert_eq!(config.bump, 0);\r\n    }\r\n\r\n    // ========================================================================\r\n    // Mint Logic Tests\r\n    // ========================================================================\r\n\r\n    #[test]\r\n    fn test_mint_within_supply() {\r\n        let total_minted = 500_000_000u64 * 1_000_000_000u64; // 500M\r\n        let mint_amount = 100_000_000u64 * 1_000_000_000u64;  // 100M\r\n        \r\n        let new_total = total_minted.checked_add(mint_amount);\r\n        assert!(new_total.is_some(), \"Addition should not overflow\");\r\n        assert!(new_total.unwrap() \u003c= TOTAL_SUPPLY, \"Should be within supply\");\r\n    }\r\n\r\n    #[test]\r\n    fn test_mint_exceeds_supply() {\r\n        let total_minted = 950_000_000u64 * 1_000_000_000u64; // 950M\r\n        let mint_amount = 100_000_000u64 * 1_000_000_000u64;  // 100M\r\n        \r\n        let new_total = total_minted.checked_add(mint_amount).unwrap();\r\n        assert!(new_total \u003e TOTAL_SUPPLY, \"Should exceed supply\");\r\n    }\r\n\r\n    #[test]\r\n    fn test_mint_exact_remaining() {\r\n        let total_minted = 900_000_000u64 * 1_000_000_000u64; // 900M\r\n        let remaining = TOTAL_SUPPLY - total_minted;\r\n        \r\n        assert_eq!(remaining, 100_000_000u64 * 1_000_000_000u64, \"100M remaining\");\r\n        \r\n        let new_total = total_minted + remaining;\r\n        assert_eq!(new_total, TOTAL_SUPPLY, \"Should equal total supply\");\r\n    }\r\n\r\n    // ========================================================================\r\n    // Security Tests\r\n    // ========================================================================\r\n\r\n    #[test]\r\n    fn test_zero_mint_rejected() {\r\n        // Zero mint should be rejected (business logic)\r\n        let amount = 0u64;\r\n        assert_eq!(amount, 0, \"Zero amount should be handled by instruction\");\r\n    }\r\n\r\n    #[test]\r\n    fn test_pause_state() {\r\n        let mut config = VCoinConfig::default();\r\n        \r\n        // Initially unpaused\r\n        assert!(!config.paused);\r\n        \r\n        // Pause\r\n        config.paused = true;\r\n        assert!(config.paused);\r\n        \r\n        // Unpause\r\n        config.paused = false;\r\n        assert!(!config.paused);\r\n    }\r\n\r\n    // ========================================================================\r\n    // Arithmetic Overflow Tests\r\n    // ========================================================================\r\n\r\n    #[test]\r\n    fn test_no_overflow_max_supply() {\r\n        // Ensure max supply fits in u64\r\n        assert!(TOTAL_SUPPLY \u003c= u64::MAX, \"Total supply should fit in u64\");\r\n    }\r\n\r\n    #[test]\r\n    fn test_checked_add_for_minting() {\r\n        let total_minted = u64::MAX - 1000;\r\n        let mint_amount = 2000u64;\r\n        \r\n        // This should overflow\r\n        let result = total_minted.checked_add(mint_amount);\r\n        assert!(result.is_none(), \"Should detect overflow\");\r\n    }\r\n\r\n    // ========================================================================\r\n    // Invariant Tests\r\n    // ========================================================================\r\n\r\n    #[test]\r\n    fn test_invariant_total_minted_bounded() {\r\n        // total_minted should never exceed TOTAL_SUPPLY\r\n        for minted in [0u64, TOTAL_SUPPLY / 2, TOTAL_SUPPLY] {\r\n            assert!(minted \u003c= TOTAL_SUPPLY, \"Minted amount must not exceed supply\");\r\n        }\r\n    }\r\n\r\n    #[test]\r\n    fn test_supply_distribution() {\r\n        // Verify supply breakdown constants if defined\r\n        // Total: 1B VCoin\r\n        // Expected distributions (from tokenomics):\r\n        // - Ecosystem Rewards: 35% = 350M\r\n        // - Team \u0026 Development: 18% = 180M\r\n        // - etc.\r\n        \r\n        let total = TOTAL_SUPPLY;\r\n        let one_percent = total / 100;\r\n        \r\n        assert_eq!(one_percent * 100, total, \"Supply should be evenly divisible\");\r\n    }\r\n}\r\n\r\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","vcoin-token","tests","admin.rs"],"content":"//! Integration tests for vcoin-token admin instructions\r\n//!\r\n//! Tests set_paused, update_authority, update_permanent_delegate\r\n\r\nmod common;\r\n\r\nuse common::*;\r\nuse solana_sdk::signature::{Keypair, Signer};\r\n\r\n// ============================================================================\r\n// set_paused tests\r\n// ============================================================================\r\n\r\n/// Test set_paused to true\r\n#[tokio::test]\r\nasync fn test_set_paused_true() {\r\n    let mut ctx = TestContext::new().await;\r\n    \r\n    let (config_pda, _bump) = ctx.get_config_pda();\r\n    let mint = Keypair::new();\r\n    let treasury = Keypair::new();\r\n    let permanent_delegate = Keypair::new();\r\n    \r\n    // Initialize\r\n    let init_ix = create_initialize_mint_ix(\r\n        \u0026ctx.program_id,\r\n        \u0026ctx.payer.pubkey(),\r\n        \u0026config_pda,\r\n        \u0026mint.pubkey(),\r\n        \u0026treasury.pubkey(),\r\n        \u0026permanent_delegate.pubkey(),\r\n    );\r\n    \r\n    ctx.process_transaction(\u0026[init_ix], \u0026[]).await.unwrap();\r\n    \r\n    // Pause\r\n    let pause_ix = create_set_paused_ix(\r\n        \u0026ctx.program_id,\r\n        \u0026ctx.payer.pubkey(),\r\n        \u0026config_pda,\r\n        true,\r\n    );\r\n    \r\n    let result = ctx.process_transaction(\u0026[pause_ix], \u0026[]).await;\r\n    assert!(result.is_ok(), \"Setting paused should succeed\");\r\n}\r\n\r\n/// Test set_paused to false (unpause)\r\n#[tokio::test]\r\nasync fn test_set_paused_false() {\r\n    let mut ctx = TestContext::new().await;\r\n    \r\n    let (config_pda, _bump) = ctx.get_config_pda();\r\n    let mint = Keypair::new();\r\n    let treasury = Keypair::new();\r\n    let permanent_delegate = Keypair::new();\r\n    \r\n    // Initialize\r\n    let init_ix = create_initialize_mint_ix(\r\n        \u0026ctx.program_id,\r\n        \u0026ctx.payer.pubkey(),\r\n        \u0026config_pda,\r\n        \u0026mint.pubkey(),\r\n        \u0026treasury.pubkey(),\r\n        \u0026permanent_delegate.pubkey(),\r\n    );\r\n    \r\n    ctx.process_transaction(\u0026[init_ix], \u0026[]).await.unwrap();\r\n    \r\n    // Pause first\r\n    let pause_ix = create_set_paused_ix(\r\n        \u0026ctx.program_id,\r\n        \u0026ctx.payer.pubkey(),\r\n        \u0026config_pda,\r\n        true,\r\n    );\r\n    ctx.process_transaction(\u0026[pause_ix], \u0026[]).await.unwrap();\r\n    \r\n    // Unpause\r\n    let unpause_ix = create_set_paused_ix(\r\n        \u0026ctx.program_id,\r\n        \u0026ctx.payer.pubkey(),\r\n        \u0026config_pda,\r\n        false,\r\n    );\r\n    \r\n    let result = ctx.process_transaction(\u0026[unpause_ix], \u0026[]).await;\r\n    assert!(result.is_ok(), \"Setting unpaused should succeed\");\r\n}\r\n\r\n/// Test set_paused unauthorized\r\n#[tokio::test]\r\nasync fn test_set_paused_unauthorized() {\r\n    let mut ctx = TestContext::new().await;\r\n    \r\n    let (config_pda, _bump) = ctx.get_config_pda();\r\n    let mint = Keypair::new();\r\n    let treasury = Keypair::new();\r\n    let permanent_delegate = Keypair::new();\r\n    \r\n    // Initialize\r\n    let init_ix = create_initialize_mint_ix(\r\n        \u0026ctx.program_id,\r\n        \u0026ctx.payer.pubkey(),\r\n        \u0026config_pda,\r\n        \u0026mint.pubkey(),\r\n        \u0026treasury.pubkey(),\r\n        \u0026permanent_delegate.pubkey(),\r\n    );\r\n    \r\n    ctx.process_transaction(\u0026[init_ix], \u0026[]).await.unwrap();\r\n    \r\n    // Try pausing with unauthorized signer\r\n    let unauthorized = Keypair::new();\r\n    let pause_ix = create_set_paused_ix(\r\n        \u0026ctx.program_id,\r\n        \u0026unauthorized.pubkey(),\r\n        \u0026config_pda,\r\n        true,\r\n    );\r\n    \r\n    // Verify instruction uses unauthorized signer\r\n    assert_eq!(pause_ix.accounts[0].pubkey, unauthorized.pubkey());\r\n}\r\n\r\n// ============================================================================\r\n// update_authority tests\r\n// ============================================================================\r\n\r\n/// Test update_authority success\r\n#[tokio::test]\r\nasync fn test_update_authority_success() {\r\n    let mut ctx = TestContext::new().await;\r\n    \r\n    let (config_pda, _bump) = ctx.get_config_pda();\r\n    let mint = Keypair::new();\r\n    let treasury = Keypair::new();\r\n    let permanent_delegate = Keypair::new();\r\n    \r\n    // Initialize\r\n    let init_ix = create_initialize_mint_ix(\r\n        \u0026ctx.program_id,\r\n        \u0026ctx.payer.pubkey(),\r\n        \u0026config_pda,\r\n        \u0026mint.pubkey(),\r\n        \u0026treasury.pubkey(),\r\n        \u0026permanent_delegate.pubkey(),\r\n    );\r\n    \r\n    ctx.process_transaction(\u0026[init_ix], \u0026[]).await.unwrap();\r\n    \r\n    // Update authority\r\n    let new_authority = Keypair::new();\r\n    let update_ix = create_update_authority_ix(\r\n        \u0026ctx.program_id,\r\n        \u0026ctx.payer.pubkey(),\r\n        \u0026config_pda,\r\n        \u0026new_authority.pubkey(),\r\n    );\r\n    \r\n    let result = ctx.process_transaction(\u0026[update_ix], \u0026[]).await;\r\n    assert!(result.is_ok(), \"Update authority should succeed\");\r\n}\r\n\r\n/// Test update_authority unauthorized\r\n#[tokio::test]\r\nasync fn test_update_authority_unauthorized() {\r\n    let mut ctx = TestContext::new().await;\r\n    \r\n    let (config_pda, _bump) = ctx.get_config_pda();\r\n    let mint = Keypair::new();\r\n    let treasury = Keypair::new();\r\n    let permanent_delegate = Keypair::new();\r\n    \r\n    // Initialize\r\n    let init_ix = create_initialize_mint_ix(\r\n        \u0026ctx.program_id,\r\n        \u0026ctx.payer.pubkey(),\r\n        \u0026config_pda,\r\n        \u0026mint.pubkey(),\r\n        \u0026treasury.pubkey(),\r\n        \u0026permanent_delegate.pubkey(),\r\n    );\r\n    \r\n    ctx.process_transaction(\u0026[init_ix], \u0026[]).await.unwrap();\r\n    \r\n    // Try updating with wrong authority\r\n    let unauthorized = Keypair::new();\r\n    let new_authority = Keypair::new();\r\n    let update_ix = create_update_authority_ix(\r\n        \u0026ctx.program_id,\r\n        \u0026unauthorized.pubkey(),\r\n        \u0026config_pda,\r\n        \u0026new_authority.pubkey(),\r\n    );\r\n    \r\n    // Verify instruction uses unauthorized signer\r\n    assert_eq!(update_ix.accounts[0].pubkey, unauthorized.pubkey());\r\n}\r\n\r\n/// Test update_authority to self\r\n#[tokio::test]\r\nasync fn test_update_authority_to_self() {\r\n    let mut ctx = TestContext::new().await;\r\n    \r\n    let (config_pda, _bump) = ctx.get_config_pda();\r\n    let mint = Keypair::new();\r\n    let treasury = Keypair::new();\r\n    let permanent_delegate = Keypair::new();\r\n    \r\n    // Initialize\r\n    let init_ix = create_initialize_mint_ix(\r\n        \u0026ctx.program_id,\r\n        \u0026ctx.payer.pubkey(),\r\n        \u0026config_pda,\r\n        \u0026mint.pubkey(),\r\n        \u0026treasury.pubkey(),\r\n        \u0026permanent_delegate.pubkey(),\r\n    );\r\n    \r\n    ctx.process_transaction(\u0026[init_ix], \u0026[]).await.unwrap();\r\n    \r\n    // Update authority to same value\r\n    let update_ix = create_update_authority_ix(\r\n        \u0026ctx.program_id,\r\n        \u0026ctx.payer.pubkey(),\r\n        \u0026config_pda,\r\n        \u0026ctx.payer.pubkey(), // Same as current\r\n    );\r\n    \r\n    let result = ctx.process_transaction(\u0026[update_ix], \u0026[]).await;\r\n    assert!(result.is_ok(), \"Update authority to self should succeed\");\r\n}\r\n\r\n// ============================================================================\r\n// update_permanent_delegate tests\r\n// ============================================================================\r\n\r\n/// Test update_permanent_delegate success\r\n#[tokio::test]\r\nasync fn test_update_delegate_success() {\r\n    let mut ctx = TestContext::new().await;\r\n    \r\n    let (config_pda, _bump) = ctx.get_config_pda();\r\n    let mint = Keypair::new();\r\n    let treasury = Keypair::new();\r\n    let permanent_delegate = Keypair::new();\r\n    \r\n    // Initialize\r\n    let init_ix = create_initialize_mint_ix(\r\n        \u0026ctx.program_id,\r\n        \u0026ctx.payer.pubkey(),\r\n        \u0026config_pda,\r\n        \u0026mint.pubkey(),\r\n        \u0026treasury.pubkey(),\r\n        \u0026permanent_delegate.pubkey(),\r\n    );\r\n    \r\n    ctx.process_transaction(\u0026[init_ix], \u0026[]).await.unwrap();\r\n    \r\n    // Update delegate\r\n    let new_delegate = Keypair::new();\r\n    let update_ix = create_update_delegate_ix(\r\n        \u0026ctx.program_id,\r\n        \u0026ctx.payer.pubkey(),\r\n        \u0026config_pda,\r\n        \u0026new_delegate.pubkey(),\r\n    );\r\n    \r\n    let result = ctx.process_transaction(\u0026[update_ix], \u0026[]).await;\r\n    assert!(result.is_ok(), \"Update delegate should succeed\");\r\n}\r\n\r\n/// Test update_permanent_delegate unauthorized\r\n#[tokio::test]\r\nasync fn test_update_delegate_unauthorized() {\r\n    let mut ctx = TestContext::new().await;\r\n    \r\n    let (config_pda, _bump) = ctx.get_config_pda();\r\n    let mint = Keypair::new();\r\n    let treasury = Keypair::new();\r\n    let permanent_delegate = Keypair::new();\r\n    \r\n    // Initialize\r\n    let init_ix = create_initialize_mint_ix(\r\n        \u0026ctx.program_id,\r\n        \u0026ctx.payer.pubkey(),\r\n        \u0026config_pda,\r\n        \u0026mint.pubkey(),\r\n        \u0026treasury.pubkey(),\r\n        \u0026permanent_delegate.pubkey(),\r\n    );\r\n    \r\n    ctx.process_transaction(\u0026[init_ix], \u0026[]).await.unwrap();\r\n    \r\n    // Try updating with wrong authority\r\n    let unauthorized = Keypair::new();\r\n    let new_delegate = Keypair::new();\r\n    let update_ix = create_update_delegate_ix(\r\n        \u0026ctx.program_id,\r\n        \u0026unauthorized.pubkey(),\r\n        \u0026config_pda,\r\n        \u0026new_delegate.pubkey(),\r\n    );\r\n    \r\n    // Verify instruction uses unauthorized signer\r\n    assert_eq!(update_ix.accounts[0].pubkey, unauthorized.pubkey());\r\n}\r\n\r\n/// Test update_permanent_delegate multiple times\r\n#[tokio::test]\r\nasync fn test_update_delegate_multiple_times() {\r\n    let mut ctx = TestContext::new().await;\r\n    \r\n    let (config_pda, _bump) = ctx.get_config_pda();\r\n    let mint = Keypair::new();\r\n    let treasury = Keypair::new();\r\n    let permanent_delegate = Keypair::new();\r\n    \r\n    // Initialize\r\n    let init_ix = create_initialize_mint_ix(\r\n        \u0026ctx.program_id,\r\n        \u0026ctx.payer.pubkey(),\r\n        \u0026config_pda,\r\n        \u0026mint.pubkey(),\r\n        \u0026treasury.pubkey(),\r\n        \u0026permanent_delegate.pubkey(),\r\n    );\r\n    \r\n    ctx.process_transaction(\u0026[init_ix], \u0026[]).await.unwrap();\r\n    \r\n    // Update delegate multiple times\r\n    for i in 0..3 {\r\n        let new_delegate = Keypair::new();\r\n        let update_ix = create_update_delegate_ix(\r\n            \u0026ctx.program_id,\r\n            \u0026ctx.payer.pubkey(),\r\n            \u0026config_pda,\r\n            \u0026new_delegate.pubkey(),\r\n        );\r\n        \r\n        let result = ctx.process_transaction(\u0026[update_ix], \u0026[]).await;\r\n        assert!(result.is_ok(), \"Update delegate #{} should succeed\", i + 1);\r\n    }\r\n}\r\n\r\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","vcoin-token","tests","common","mod.rs"],"content":"//! Common test utilities for vcoin-token integration tests\r\n//!\r\n//! Provides TestContext and helpers for solana-program-test based testing.\r\n\r\nuse solana_program_test::*;\r\nuse solana_sdk::{\r\n    account::Account,\r\n    hash::{Hash, hash},\r\n    instruction::{AccountMeta, Instruction},\r\n    pubkey::Pubkey,\r\n    signature::{Keypair, Signer},\r\n    system_program,\r\n    sysvar,\r\n    transaction::Transaction,\r\n};\r\n\r\n/// VCoin configuration seed\r\npub const VCOIN_CONFIG_SEED: \u0026[u8] = b\"vcoin-config\";\r\n\r\n/// Test context wrapper for vcoin-token tests\r\npub struct TestContext {\r\n    pub banks_client: BanksClient,\r\n    pub payer: Keypair,\r\n    pub recent_blockhash: Hash,\r\n    pub program_id: Pubkey,\r\n}\r\n\r\nimpl TestContext {\r\n    /// Create a new test context with the vcoin-token program loaded\r\n    pub async fn new() -\u003e Self {\r\n        let program_id = vcoin_token::id();\r\n        let mut program_test = ProgramTest::default();\r\n        program_test.add_program(\"vcoin_token\", program_id, None);\r\n\r\n        let (banks_client, payer, recent_blockhash) = program_test.start().await;\r\n\r\n        Self {\r\n            banks_client,\r\n            payer,\r\n            recent_blockhash,\r\n            program_id,\r\n        }\r\n    }\r\n\r\n    /// Refresh the blockhash\r\n    pub async fn refresh_blockhash(\u0026mut self) {\r\n        self.recent_blockhash = self.banks_client.get_latest_blockhash().await.unwrap();\r\n    }\r\n\r\n    /// Get an account by pubkey\r\n    pub async fn get_account(\u0026mut self, pubkey: Pubkey) -\u003e Option\u003cAccount\u003e {\r\n        self.banks_client.get_account(pubkey).await.unwrap()\r\n    }\r\n\r\n    /// Airdrop SOL to an account\r\n    pub async fn airdrop(\u0026mut self, pubkey: \u0026Pubkey, lamports: u64) {\r\n        let ix = solana_sdk::system_instruction::transfer(\u0026self.payer.pubkey(), pubkey, lamports);\r\n        let tx = Transaction::new_signed_with_payer(\r\n            \u0026[ix],\r\n            Some(\u0026self.payer.pubkey()),\r\n            \u0026[\u0026self.payer],\r\n            self.recent_blockhash,\r\n        );\r\n        self.banks_client.process_transaction(tx).await.unwrap();\r\n        self.refresh_blockhash().await;\r\n    }\r\n\r\n    /// Get the config PDA\r\n    pub fn get_config_pda(\u0026self) -\u003e (Pubkey, u8) {\r\n        Pubkey::find_program_address(\u0026[VCOIN_CONFIG_SEED], \u0026self.program_id)\r\n    }\r\n\r\n    /// Process a transaction and return the result\r\n    pub async fn process_transaction(\r\n        \u0026mut self,\r\n        instructions: \u0026[Instruction],\r\n        signers: \u0026[\u0026Keypair],\r\n    ) -\u003e std::result::Result\u003c(), BanksClientError\u003e {\r\n        let mut all_signers = vec![\u0026self.payer];\r\n        all_signers.extend(signers);\r\n        \r\n        let tx = Transaction::new_signed_with_payer(\r\n            instructions,\r\n            Some(\u0026self.payer.pubkey()),\r\n            \u0026all_signers,\r\n            self.recent_blockhash,\r\n        );\r\n        \r\n        let result = self.banks_client.process_transaction(tx).await;\r\n        self.refresh_blockhash().await;\r\n        result\r\n    }\r\n}\r\n\r\n/// Helper to create an initialize_mint instruction\r\npub fn create_initialize_mint_ix(\r\n    program_id: \u0026Pubkey,\r\n    authority: \u0026Pubkey,\r\n    config: \u0026Pubkey,\r\n    mint: \u0026Pubkey,\r\n    treasury: \u0026Pubkey,\r\n    permanent_delegate: \u0026Pubkey,\r\n) -\u003e Instruction {\r\n    // Build instruction data: discriminator + permanent_delegate pubkey\r\n    let mut data = vec![0u8; 8 + 32]; // 8 byte discriminator + 32 byte pubkey\r\n    // Anchor discriminator for \"initialize_mint\"\r\n    let discriminator = hash(b\"global:initialize_mint\").to_bytes();\r\n    data[..8].copy_from_slice(\u0026discriminator[..8]);\r\n    data[8..40].copy_from_slice(permanent_delegate.as_ref());\r\n\r\n    Instruction {\r\n        program_id: *program_id,\r\n        accounts: vec![\r\n            AccountMeta::new(*authority, true),\r\n            AccountMeta::new(*config, false),\r\n            AccountMeta::new(*mint, false),\r\n            AccountMeta::new_readonly(*treasury, false),\r\n            AccountMeta::new_readonly(spl_token_2022::id(), false),\r\n            AccountMeta::new_readonly(system_program::ID, false),\r\n            AccountMeta::new_readonly(sysvar::rent::ID, false),\r\n        ],\r\n        data,\r\n    }\r\n}\r\n\r\n/// Helper to create a set_paused instruction\r\npub fn create_set_paused_ix(\r\n    program_id: \u0026Pubkey,\r\n    authority: \u0026Pubkey,\r\n    config: \u0026Pubkey,\r\n    paused: bool,\r\n) -\u003e Instruction {\r\n    let mut data = vec![0u8; 8 + 1]; // 8 byte discriminator + 1 byte bool\r\n    let discriminator = hash(b\"global:set_paused\").to_bytes();\r\n    data[..8].copy_from_slice(\u0026discriminator[..8]);\r\n    data[8] = if paused { 1 } else { 0 };\r\n\r\n    Instruction {\r\n        program_id: *program_id,\r\n        accounts: vec![\r\n            AccountMeta::new(*authority, true),\r\n            AccountMeta::new(*config, false),\r\n        ],\r\n        data,\r\n    }\r\n}\r\n\r\n/// Helper to create an update_authority instruction\r\npub fn create_update_authority_ix(\r\n    program_id: \u0026Pubkey,\r\n    authority: \u0026Pubkey,\r\n    config: \u0026Pubkey,\r\n    new_authority: \u0026Pubkey,\r\n) -\u003e Instruction {\r\n    let mut data = vec![0u8; 8 + 32]; // 8 byte discriminator + 32 byte pubkey\r\n    let discriminator = hash(b\"global:update_authority\").to_bytes();\r\n    data[..8].copy_from_slice(\u0026discriminator[..8]);\r\n    data[8..40].copy_from_slice(new_authority.as_ref());\r\n\r\n    Instruction {\r\n        program_id: *program_id,\r\n        accounts: vec![\r\n            AccountMeta::new(*authority, true),\r\n            AccountMeta::new(*config, false),\r\n        ],\r\n        data,\r\n    }\r\n}\r\n\r\n/// Helper to create an update_permanent_delegate instruction\r\npub fn create_update_delegate_ix(\r\n    program_id: \u0026Pubkey,\r\n    authority: \u0026Pubkey,\r\n    config: \u0026Pubkey,\r\n    new_delegate: \u0026Pubkey,\r\n) -\u003e Instruction {\r\n    let mut data = vec![0u8; 8 + 32]; // 8 byte discriminator + 32 byte pubkey\r\n    let discriminator = hash(b\"global:update_permanent_delegate\").to_bytes();\r\n    data[..8].copy_from_slice(\u0026discriminator[..8]);\r\n    data[8..40].copy_from_slice(new_delegate.as_ref());\r\n\r\n    Instruction {\r\n        program_id: *program_id,\r\n        accounts: vec![\r\n            AccountMeta::new(*authority, true),\r\n            AccountMeta::new(*config, false),\r\n        ],\r\n        data,\r\n    }\r\n}\r\n\r\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","vcoin-token","tests","initialize.rs"],"content":"//! Integration tests for vcoin-token initialize_mint instruction\r\n//!\r\n//! Tests the initialization of the VCoin mint with Token-2022 extensions.\r\n\r\nmod common;\r\n\r\nuse common::*;\r\nuse solana_sdk::signature::{Keypair, Signer};\r\n\r\n/// Test successful initialization of the VCoin mint\r\n#[tokio::test]\r\nasync fn test_initialize_mint_success() {\r\n    let mut ctx = TestContext::new().await;\r\n    \r\n    let (config_pda, _bump) = ctx.get_config_pda();\r\n    let mint = Keypair::new();\r\n    let treasury = Keypair::new();\r\n    let permanent_delegate = Keypair::new();\r\n    \r\n    let ix = create_initialize_mint_ix(\r\n        \u0026ctx.program_id,\r\n        \u0026ctx.payer.pubkey(),\r\n        \u0026config_pda,\r\n        \u0026mint.pubkey(),\r\n        \u0026treasury.pubkey(),\r\n        \u0026permanent_delegate.pubkey(),\r\n    );\r\n    \r\n    let result = ctx.process_transaction(\u0026[ix], \u0026[]).await;\r\n    assert!(result.is_ok(), \"Initialize should succeed\");\r\n    \r\n    // Verify config account was created\r\n    let config_account = ctx.get_account(config_pda).await;\r\n    assert!(config_account.is_some(), \"Config account should exist\");\r\n    \r\n    let config_data = config_account.unwrap();\r\n    assert_eq!(config_data.owner, ctx.program_id, \"Config should be owned by program\");\r\n}\r\n\r\n/// Test that initialize fails when config already exists (double init)\r\n#[tokio::test]\r\nasync fn test_initialize_mint_already_initialized() {\r\n    let mut ctx = TestContext::new().await;\r\n    \r\n    let (config_pda, _bump) = ctx.get_config_pda();\r\n    let mint = Keypair::new();\r\n    let treasury = Keypair::new();\r\n    let permanent_delegate = Keypair::new();\r\n    \r\n    // First initialization\r\n    let ix = create_initialize_mint_ix(\r\n        \u0026ctx.program_id,\r\n        \u0026ctx.payer.pubkey(),\r\n        \u0026config_pda,\r\n        \u0026mint.pubkey(),\r\n        \u0026treasury.pubkey(),\r\n        \u0026permanent_delegate.pubkey(),\r\n    );\r\n    \r\n    ctx.process_transaction(\u0026[ix.clone()], \u0026[]).await.unwrap();\r\n    \r\n    // Second initialization should fail\r\n    let result = ctx.process_transaction(\u0026[ix], \u0026[]).await;\r\n    assert!(result.is_err(), \"Double initialization should fail\");\r\n}\r\n\r\n/// Test initialization with different permanent delegates\r\n#[tokio::test]\r\nasync fn test_initialize_mint_with_delegate() {\r\n    let mut ctx = TestContext::new().await;\r\n    \r\n    let (config_pda, _bump) = ctx.get_config_pda();\r\n    let mint = Keypair::new();\r\n    let treasury = Keypair::new();\r\n    let permanent_delegate = Keypair::new();\r\n    \r\n    let ix = create_initialize_mint_ix(\r\n        \u0026ctx.program_id,\r\n        \u0026ctx.payer.pubkey(),\r\n        \u0026config_pda,\r\n        \u0026mint.pubkey(),\r\n        \u0026treasury.pubkey(),\r\n        \u0026permanent_delegate.pubkey(),\r\n    );\r\n    \r\n    let result = ctx.process_transaction(\u0026[ix], \u0026[]).await;\r\n    assert!(result.is_ok(), \"Initialize with delegate should succeed\");\r\n    \r\n    // Config should be created with the specified delegate\r\n    let config_account = ctx.get_account(config_pda).await;\r\n    assert!(config_account.is_some());\r\n}\r\n\r\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","vcoin-token","tests","mint.rs"],"content":"//! Integration tests for vcoin-token mint_tokens instruction\r\n//!\r\n//! Tests minting VCoin tokens to destination accounts.\r\n\r\nmod common;\r\n\r\nuse common::*;\r\nuse solana_sdk::{\r\n    hash::hash,\r\n    instruction::{AccountMeta, Instruction},\r\n    signature::{Keypair, Signer},\r\n};\r\n\r\n/// Helper to create a mint_tokens instruction\r\nfn create_mint_tokens_ix(\r\n    program_id: \u0026solana_sdk::pubkey::Pubkey,\r\n    authority: \u0026solana_sdk::pubkey::Pubkey,\r\n    config: \u0026solana_sdk::pubkey::Pubkey,\r\n    mint: \u0026solana_sdk::pubkey::Pubkey,\r\n    destination: \u0026solana_sdk::pubkey::Pubkey,\r\n    amount: u64,\r\n) -\u003e Instruction {\r\n    let mut data = vec![0u8; 8 + 8]; // 8 byte discriminator + 8 byte u64\r\n    let discriminator = hash(b\"global:mint_tokens\").to_bytes();\r\n    data[..8].copy_from_slice(\u0026discriminator[..8]);\r\n    data[8..16].copy_from_slice(\u0026amount.to_le_bytes());\r\n\r\n    Instruction {\r\n        program_id: *program_id,\r\n        accounts: vec![\r\n            AccountMeta::new(*authority, true),\r\n            AccountMeta::new(*config, false),\r\n            AccountMeta::new(*mint, false),\r\n            AccountMeta::new(*destination, false),\r\n            AccountMeta::new_readonly(spl_token_2022::id(), false),\r\n        ],\r\n        data,\r\n    }\r\n}\r\n\r\n/// Test mint tokens success path\r\n#[tokio::test]\r\nasync fn test_mint_tokens_success() {\r\n    let mut ctx = TestContext::new().await;\r\n    \r\n    // First initialize the mint\r\n    let (config_pda, _bump) = ctx.get_config_pda();\r\n    let mint = Keypair::new();\r\n    let treasury = Keypair::new();\r\n    let permanent_delegate = Keypair::new();\r\n    \r\n    let init_ix = create_initialize_mint_ix(\r\n        \u0026ctx.program_id,\r\n        \u0026ctx.payer.pubkey(),\r\n        \u0026config_pda,\r\n        \u0026mint.pubkey(),\r\n        \u0026treasury.pubkey(),\r\n        \u0026permanent_delegate.pubkey(),\r\n    );\r\n    \r\n    ctx.process_transaction(\u0026[init_ix], \u0026[]).await.unwrap();\r\n    \r\n    // Config should exist after initialization\r\n    let config = ctx.get_account(config_pda).await;\r\n    assert!(config.is_some(), \"Config should exist after init\");\r\n}\r\n\r\n/// Test mint tokens with zero amount should fail\r\n#[tokio::test]\r\nasync fn test_mint_tokens_zero_amount() {\r\n    let mut ctx = TestContext::new().await;\r\n    \r\n    let (config_pda, _bump) = ctx.get_config_pda();\r\n    let mint = Keypair::new();\r\n    let treasury = Keypair::new();\r\n    let permanent_delegate = Keypair::new();\r\n    \r\n    // Initialize first\r\n    let init_ix = create_initialize_mint_ix(\r\n        \u0026ctx.program_id,\r\n        \u0026ctx.payer.pubkey(),\r\n        \u0026config_pda,\r\n        \u0026mint.pubkey(),\r\n        \u0026treasury.pubkey(),\r\n        \u0026permanent_delegate.pubkey(),\r\n    );\r\n    \r\n    ctx.process_transaction(\u0026[init_ix], \u0026[]).await.unwrap();\r\n    \r\n    // Minting 0 should be handled by program logic\r\n    // This validates the instruction data creation works\r\n    let destination = Keypair::new();\r\n    let mint_ix = create_mint_tokens_ix(\r\n        \u0026ctx.program_id,\r\n        \u0026ctx.payer.pubkey(),\r\n        \u0026config_pda,\r\n        \u0026mint.pubkey(),\r\n        \u0026destination.pubkey(),\r\n        0,\r\n    );\r\n    \r\n    // Zero amount minting behavior depends on program logic\r\n    // The instruction should at least be parseable\r\n    assert_eq!(mint_ix.data.len(), 16); // 8 discriminator + 8 amount\r\n}\r\n\r\n/// Test mint tokens unauthorized - wrong authority\r\n#[tokio::test]\r\nasync fn test_mint_tokens_unauthorized() {\r\n    let mut ctx = TestContext::new().await;\r\n    \r\n    let (config_pda, _bump) = ctx.get_config_pda();\r\n    let mint = Keypair::new();\r\n    let treasury = Keypair::new();\r\n    let permanent_delegate = Keypair::new();\r\n    \r\n    // Initialize\r\n    let init_ix = create_initialize_mint_ix(\r\n        \u0026ctx.program_id,\r\n        \u0026ctx.payer.pubkey(),\r\n        \u0026config_pda,\r\n        \u0026mint.pubkey(),\r\n        \u0026treasury.pubkey(),\r\n        \u0026permanent_delegate.pubkey(),\r\n    );\r\n    \r\n    ctx.process_transaction(\u0026[init_ix], \u0026[]).await.unwrap();\r\n    \r\n    // Try minting with unauthorized signer\r\n    let unauthorized = Keypair::new();\r\n    ctx.airdrop(\u0026unauthorized.pubkey(), 1_000_000_000).await;\r\n    \r\n    let destination = Keypair::new();\r\n    let mint_ix = create_mint_tokens_ix(\r\n        \u0026ctx.program_id,\r\n        \u0026unauthorized.pubkey(),\r\n        \u0026config_pda,\r\n        \u0026mint.pubkey(),\r\n        \u0026destination.pubkey(),\r\n        1000,\r\n    );\r\n    \r\n    // This should fail due to unauthorized signer\r\n    // The instruction format is correct but authority check will fail\r\n    assert!(mint_ix.accounts[0].is_signer);\r\n}\r\n\r\n/// Test mint tokens exceeds max supply\r\n#[tokio::test]\r\nasync fn test_mint_tokens_exceeds_supply() {\r\n    let mut ctx = TestContext::new().await;\r\n    \r\n    let (config_pda, _bump) = ctx.get_config_pda();\r\n    let mint = Keypair::new();\r\n    let treasury = Keypair::new();\r\n    let permanent_delegate = Keypair::new();\r\n    \r\n    let init_ix = create_initialize_mint_ix(\r\n        \u0026ctx.program_id,\r\n        \u0026ctx.payer.pubkey(),\r\n        \u0026config_pda,\r\n        \u0026mint.pubkey(),\r\n        \u0026treasury.pubkey(),\r\n        \u0026permanent_delegate.pubkey(),\r\n    );\r\n    \r\n    ctx.process_transaction(\u0026[init_ix], \u0026[]).await.unwrap();\r\n    \r\n    // Try to mint more than max supply (1 billion * 10^9)\r\n    let destination = Keypair::new();\r\n    let excessive_amount = u64::MAX;\r\n    \r\n    let mint_ix = create_mint_tokens_ix(\r\n        \u0026ctx.program_id,\r\n        \u0026ctx.payer.pubkey(),\r\n        \u0026config_pda,\r\n        \u0026mint.pubkey(),\r\n        \u0026destination.pubkey(),\r\n        excessive_amount,\r\n    );\r\n    \r\n    // Verify instruction is created with large amount\r\n    assert_eq!(\u0026mint_ix.data[8..16], \u0026excessive_amount.to_le_bytes());\r\n}\r\n\r\n/// Test mint tokens when paused should fail\r\n#[tokio::test]\r\nasync fn test_mint_tokens_when_paused() {\r\n    let mut ctx = TestContext::new().await;\r\n    \r\n    let (config_pda, _bump) = ctx.get_config_pda();\r\n    let mint = Keypair::new();\r\n    let treasury = Keypair::new();\r\n    let permanent_delegate = Keypair::new();\r\n    \r\n    // Initialize\r\n    let init_ix = create_initialize_mint_ix(\r\n        \u0026ctx.program_id,\r\n        \u0026ctx.payer.pubkey(),\r\n        \u0026config_pda,\r\n        \u0026mint.pubkey(),\r\n        \u0026treasury.pubkey(),\r\n        \u0026permanent_delegate.pubkey(),\r\n    );\r\n    \r\n    ctx.process_transaction(\u0026[init_ix], \u0026[]).await.unwrap();\r\n    \r\n    // Pause the token\r\n    let pause_ix = create_set_paused_ix(\r\n        \u0026ctx.program_id,\r\n        \u0026ctx.payer.pubkey(),\r\n        \u0026config_pda,\r\n        true,\r\n    );\r\n    \r\n    ctx.process_transaction(\u0026[pause_ix], \u0026[]).await.unwrap();\r\n    \r\n    // Verify pause instruction works\r\n    let config = ctx.get_account(config_pda).await;\r\n    assert!(config.is_some());\r\n}\r\n\r\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","vcoin-token","tests","slash.rs"],"content":"//! Integration tests for vcoin-token slash_tokens instruction\r\n//!\r\n//! Tests slashing (burning) tokens using permanent delegate authority.\r\n\r\nmod common;\r\n\r\nuse common::*;\r\nuse solana_sdk::{\r\n    hash::hash,\r\n    instruction::{AccountMeta, Instruction},\r\n    signature::{Keypair, Signer},\r\n};\r\n\r\n/// Helper to create a slash_tokens instruction\r\nfn create_slash_tokens_ix(\r\n    program_id: \u0026solana_sdk::pubkey::Pubkey,\r\n    authority: \u0026solana_sdk::pubkey::Pubkey,\r\n    config: \u0026solana_sdk::pubkey::Pubkey,\r\n    mint: \u0026solana_sdk::pubkey::Pubkey,\r\n    target_account: \u0026solana_sdk::pubkey::Pubkey,\r\n    amount: u64,\r\n) -\u003e Instruction {\r\n    let mut data = vec![0u8; 8 + 8]; // 8 byte discriminator + 8 byte u64\r\n    let discriminator = hash(b\"global:slash_tokens\").to_bytes();\r\n    data[..8].copy_from_slice(\u0026discriminator[..8]);\r\n    data[8..16].copy_from_slice(\u0026amount.to_le_bytes());\r\n\r\n    Instruction {\r\n        program_id: *program_id,\r\n        accounts: vec![\r\n            AccountMeta::new(*authority, true),\r\n            AccountMeta::new_readonly(*config, false),\r\n            AccountMeta::new(*mint, false),\r\n            AccountMeta::new(*target_account, false),\r\n            AccountMeta::new_readonly(spl_token_2022::id(), false),\r\n        ],\r\n        data,\r\n    }\r\n}\r\n\r\n/// Test slash tokens instruction creation\r\n#[tokio::test]\r\nasync fn test_slash_tokens_instruction_format() {\r\n    let ctx = TestContext::new().await;\r\n    \r\n    let (config_pda, _bump) = ctx.get_config_pda();\r\n    let mint = Keypair::new();\r\n    let target = Keypair::new();\r\n    let amount = 1000u64;\r\n    \r\n    let ix = create_slash_tokens_ix(\r\n        \u0026ctx.program_id,\r\n        \u0026ctx.payer.pubkey(),\r\n        \u0026config_pda,\r\n        \u0026mint.pubkey(),\r\n        \u0026target.pubkey(),\r\n        amount,\r\n    );\r\n    \r\n    // Verify instruction structure\r\n    assert_eq!(ix.program_id, ctx.program_id);\r\n    assert_eq!(ix.accounts.len(), 5);\r\n    assert!(ix.accounts[0].is_signer); // authority must sign\r\n    assert_eq!(ix.data.len(), 16);\r\n    assert_eq!(\u0026ix.data[8..16], \u0026amount.to_le_bytes());\r\n}\r\n\r\n/// Test slash tokens with zero amount should fail\r\n#[tokio::test]\r\nasync fn test_slash_tokens_zero_amount() {\r\n    let mut ctx = TestContext::new().await;\r\n    \r\n    let (config_pda, _bump) = ctx.get_config_pda();\r\n    let mint = Keypair::new();\r\n    let treasury = Keypair::new();\r\n    let permanent_delegate = Keypair::new();\r\n    \r\n    // Initialize\r\n    let init_ix = create_initialize_mint_ix(\r\n        \u0026ctx.program_id,\r\n        \u0026ctx.payer.pubkey(),\r\n        \u0026config_pda,\r\n        \u0026mint.pubkey(),\r\n        \u0026treasury.pubkey(),\r\n        \u0026permanent_delegate.pubkey(),\r\n    );\r\n    \r\n    ctx.process_transaction(\u0026[init_ix], \u0026[]).await.unwrap();\r\n    \r\n    // Create slash with zero amount\r\n    let target = Keypair::new();\r\n    let ix = create_slash_tokens_ix(\r\n        \u0026ctx.program_id,\r\n        \u0026permanent_delegate.pubkey(),\r\n        \u0026config_pda,\r\n        \u0026mint.pubkey(),\r\n        \u0026target.pubkey(),\r\n        0,\r\n    );\r\n    \r\n    // Verify zero amount is encoded\r\n    assert_eq!(\u0026ix.data[8..16], \u00260u64.to_le_bytes());\r\n}\r\n\r\n/// Test slash tokens unauthorized - not permanent delegate\r\n#[tokio::test]\r\nasync fn test_slash_tokens_unauthorized() {\r\n    let mut ctx = TestContext::new().await;\r\n    \r\n    let (config_pda, _bump) = ctx.get_config_pda();\r\n    let mint = Keypair::new();\r\n    let treasury = Keypair::new();\r\n    let permanent_delegate = Keypair::new();\r\n    \r\n    // Initialize\r\n    let init_ix = create_initialize_mint_ix(\r\n        \u0026ctx.program_id,\r\n        \u0026ctx.payer.pubkey(),\r\n        \u0026config_pda,\r\n        \u0026mint.pubkey(),\r\n        \u0026treasury.pubkey(),\r\n        \u0026permanent_delegate.pubkey(),\r\n    );\r\n    \r\n    ctx.process_transaction(\u0026[init_ix], \u0026[]).await.unwrap();\r\n    \r\n    // Try slashing with wrong authority (not permanent delegate)\r\n    let target = Keypair::new();\r\n    let unauthorized = Keypair::new();\r\n    \r\n    let ix = create_slash_tokens_ix(\r\n        \u0026ctx.program_id,\r\n        \u0026unauthorized.pubkey(), // Wrong - should be permanent_delegate\r\n        \u0026config_pda,\r\n        \u0026mint.pubkey(),\r\n        \u0026target.pubkey(),\r\n        1000,\r\n    );\r\n    \r\n    // Verify instruction uses unauthorized signer\r\n    assert_eq!(ix.accounts[0].pubkey, unauthorized.pubkey());\r\n}\r\n\r\n/// Test slash tokens exceeds balance\r\n#[tokio::test]\r\nasync fn test_slash_tokens_exceeds_balance() {\r\n    let mut ctx = TestContext::new().await;\r\n    \r\n    let (config_pda, _bump) = ctx.get_config_pda();\r\n    let mint = Keypair::new();\r\n    let treasury = Keypair::new();\r\n    let permanent_delegate = Keypair::new();\r\n    \r\n    // Initialize\r\n    let init_ix = create_initialize_mint_ix(\r\n        \u0026ctx.program_id,\r\n        \u0026ctx.payer.pubkey(),\r\n        \u0026config_pda,\r\n        \u0026mint.pubkey(),\r\n        \u0026treasury.pubkey(),\r\n        \u0026permanent_delegate.pubkey(),\r\n    );\r\n    \r\n    ctx.process_transaction(\u0026[init_ix], \u0026[]).await.unwrap();\r\n    \r\n    // Try to slash more than balance\r\n    let target = Keypair::new();\r\n    let excessive_amount = u64::MAX;\r\n    \r\n    let ix = create_slash_tokens_ix(\r\n        \u0026ctx.program_id,\r\n        \u0026permanent_delegate.pubkey(),\r\n        \u0026config_pda,\r\n        \u0026mint.pubkey(),\r\n        \u0026target.pubkey(),\r\n        excessive_amount,\r\n    );\r\n    \r\n    // Verify large amount encoded correctly\r\n    assert_eq!(\u0026ix.data[8..16], \u0026excessive_amount.to_le_bytes());\r\n}\r\n\r\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","vevcoin-token","src","constants.rs"],"content":"/// veVCoin Token Constants\r\n\r\n/// Token decimals\r\npub const VEVCOIN_DECIMALS: u8 = 9;\r\n\r\n/// Token metadata\r\npub const TOKEN_NAME: \u0026str = \"veVCoin\";\r\npub const TOKEN_SYMBOL: \u0026str = \"veVIWO\";\r\npub const TOKEN_URI: \u0026str = \"https://viwoapp.com/vevcoin-metadata.json\";\r\n\r\n/// PDA Seeds\r\npub const VEVCOIN_CONFIG_SEED: \u0026[u8] = b\"vevcoin-config\";\r\npub const USER_VEVCOIN_SEED: \u0026[u8] = b\"user-vevcoin\";\r\n\r\n/// 4 years in seconds (for veVCoin calculation)\r\npub const FOUR_YEARS_SECONDS: i64 = 4 * 365 * 24 * 60 * 60;\r\n\r\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","vevcoin-token","src","contexts","burn_vevcoin.rs"],"content":"use anchor_lang::prelude::*;\r\nuse anchor_spl::token_2022::Token2022;\r\nuse anchor_spl::token_interface::{Mint, TokenAccount};\r\n\r\nuse crate::constants::VEVCOIN_CONFIG_SEED;\r\nuse crate::errors::VeVCoinError;\r\nuse crate::state::{VeVCoinConfig, UserVeVCoin};\r\n\r\n#[derive(Accounts)]\r\n#[instruction(amount: u64)]\r\npub struct BurnVeVCoin\u003c'info\u003e {\r\n    /// The staking protocol (must match config)\r\n    pub staking_protocol: Signer\u003c'info\u003e,\r\n    \r\n    /// The user whose veVCoin is being burned\r\n    /// CHECK: Just a pubkey for PDA derivation\r\n    pub user: UncheckedAccount\u003c'info\u003e,\r\n    \r\n    #[account(\r\n        mut,\r\n        seeds = [VEVCOIN_CONFIG_SEED],\r\n        bump\r\n    )]\r\n    pub config: Account\u003c'info, VeVCoinConfig\u003e,\r\n    \r\n    #[account(\r\n        mut,\r\n        seeds = [UserVeVCoin::SEED, user.key().as_ref()],\r\n        bump\r\n    )]\r\n    pub user_account: Account\u003c'info, UserVeVCoin\u003e,\r\n    \r\n    /// The veVCoin mint\r\n    #[account(\r\n        mut,\r\n        constraint = mint.key() == config.mint @ VeVCoinError::InvalidMint\r\n    )]\r\n    pub mint: InterfaceAccount\u003c'info, Mint\u003e,\r\n    \r\n    /// User's token account for veVCoin - MUST be owned by user and use veVCoin mint\r\n    #[account(\r\n        mut,\r\n        constraint = user_token_account.owner == user.key() @ VeVCoinError::InvalidTokenAccount,\r\n        constraint = user_token_account.mint == config.mint @ VeVCoinError::InvalidMint\r\n    )]\r\n    pub user_token_account: InterfaceAccount\u003c'info, TokenAccount\u003e,\r\n    \r\n    pub token_program: Program\u003c'info, Token2022\u003e,\r\n}\r\n\r\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","vevcoin-token","src","contexts","get_balance.rs"],"content":"use anchor_lang::prelude::*;\r\n\r\nuse crate::state::UserVeVCoin;\r\n\r\n#[derive(Accounts)]\r\npub struct GetBalance\u003c'info\u003e {\r\n    /// CHECK: Just a pubkey for PDA derivation\r\n    pub user: UncheckedAccount\u003c'info\u003e,\r\n    \r\n    #[account(\r\n        seeds = [UserVeVCoin::SEED, user.key().as_ref()],\r\n        bump\r\n    )]\r\n    pub user_account: Account\u003c'info, UserVeVCoin\u003e,\r\n}\r\n\r\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","vevcoin-token","src","contexts","initialize_mint.rs"],"content":"use anchor_lang::prelude::*;\r\nuse anchor_spl::token_2022::Token2022;\r\n\r\nuse crate::constants::VEVCOIN_CONFIG_SEED;\r\nuse crate::state::VeVCoinConfig;\r\n\r\n#[derive(Accounts)]\r\npub struct InitializeMint\u003c'info\u003e {\r\n    #[account(mut)]\r\n    pub authority: Signer\u003c'info\u003e,\r\n    \r\n    #[account(\r\n        init,\r\n        payer = authority,\r\n        space = VeVCoinConfig::LEN,\r\n        seeds = [VEVCOIN_CONFIG_SEED],\r\n        bump\r\n    )]\r\n    pub config: Account\u003c'info, VeVCoinConfig\u003e,\r\n    \r\n    /// The veVCoin mint (Token-2022 with Non-Transferable extension)\r\n    /// CHECK: Validated by Token-2022 program\r\n    #[account(mut)]\r\n    pub mint: UncheckedAccount\u003c'info\u003e,\r\n    \r\n    pub token_program: Program\u003c'info, Token2022\u003e,\r\n    pub system_program: Program\u003c'info, System\u003e,\r\n    pub rent: Sysvar\u003c'info, Rent\u003e,\r\n}\r\n\r\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","vevcoin-token","src","contexts","mint_vevcoin.rs"],"content":"use anchor_lang::prelude::*;\r\nuse anchor_spl::token_2022::Token2022;\r\nuse anchor_spl::token_interface::{Mint, TokenAccount};\r\n\r\nuse crate::constants::VEVCOIN_CONFIG_SEED;\r\nuse crate::errors::VeVCoinError;\r\nuse crate::state::{VeVCoinConfig, UserVeVCoin};\r\n\r\n#[derive(Accounts)]\r\n#[instruction(amount: u64)]\r\npub struct MintVeVCoin\u003c'info\u003e {\r\n    /// The staking protocol (must match config)\r\n    pub staking_protocol: Signer\u003c'info\u003e,\r\n    \r\n    /// The user receiving veVCoin\r\n    /// CHECK: Just a pubkey for PDA derivation\r\n    pub user: UncheckedAccount\u003c'info\u003e,\r\n    \r\n    #[account(\r\n        mut,\r\n        seeds = [VEVCOIN_CONFIG_SEED],\r\n        bump\r\n    )]\r\n    pub config: Account\u003c'info, VeVCoinConfig\u003e,\r\n    \r\n    #[account(\r\n        init_if_needed,\r\n        payer = payer,\r\n        space = UserVeVCoin::LEN,\r\n        seeds = [UserVeVCoin::SEED, user.key().as_ref()],\r\n        bump\r\n    )]\r\n    pub user_account: Account\u003c'info, UserVeVCoin\u003e,\r\n    \r\n    /// The veVCoin mint\r\n    #[account(\r\n        mut,\r\n        constraint = mint.key() == config.mint @ VeVCoinError::InvalidMint\r\n    )]\r\n    pub mint: InterfaceAccount\u003c'info, Mint\u003e,\r\n    \r\n    /// User's token account for veVCoin - MUST be owned by user and use veVCoin mint\r\n    #[account(\r\n        mut,\r\n        constraint = user_token_account.owner == user.key() @ VeVCoinError::InvalidTokenAccount,\r\n        constraint = user_token_account.mint == config.mint @ VeVCoinError::InvalidMint\r\n    )]\r\n    pub user_token_account: InterfaceAccount\u003c'info, TokenAccount\u003e,\r\n    \r\n    #[account(mut)]\r\n    pub payer: Signer\u003c'info\u003e,\r\n    \r\n    pub token_program: Program\u003c'info, Token2022\u003e,\r\n    pub system_program: Program\u003c'info, System\u003e,\r\n}\r\n\r\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","vevcoin-token","src","contexts","mod.rs"],"content":"/// Contexts module - Account validation structures\r\nmod initialize_mint;\r\nmod mint_vevcoin;\r\nmod burn_vevcoin;\r\nmod update_config;\r\nmod get_balance;\r\n\r\npub use initialize_mint::*;\r\npub use mint_vevcoin::*;\r\npub use burn_vevcoin::*;\r\npub use update_config::*;\r\npub use get_balance::*;\r\n\r\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","vevcoin-token","src","contexts","update_config.rs"],"content":"use anchor_lang::prelude::*;\r\n\r\nuse crate::constants::VEVCOIN_CONFIG_SEED;\r\nuse crate::state::VeVCoinConfig;\r\n\r\n#[derive(Accounts)]\r\npub struct UpdateConfig\u003c'info\u003e {\r\n    #[account(mut)]\r\n    pub authority: Signer\u003c'info\u003e,\r\n    \r\n    #[account(\r\n        mut,\r\n        seeds = [VEVCOIN_CONFIG_SEED],\r\n        bump\r\n    )]\r\n    pub config: Account\u003c'info, VeVCoinConfig\u003e,\r\n}\r\n\r\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","vevcoin-token","src","errors.rs"],"content":"use anchor_lang::prelude::*;\r\n\r\n/// veVCoin Token Error Codes\r\n#[error_code]\r\npub enum VeVCoinError {\r\n    #[msg(\"Unauthorized: Only the staking protocol can perform this action\")]\r\n    Unauthorized,\r\n    \r\n    #[msg(\"Mint is already initialized\")]\r\n    MintAlreadyInitialized,\r\n    \r\n    #[msg(\"Cannot transfer soulbound tokens\")]\r\n    TransferNotAllowed,\r\n    \r\n    #[msg(\"Invalid staking protocol\")]\r\n    InvalidStakingProtocol,\r\n    \r\n    #[msg(\"Cannot burn more tokens than balance\")]\r\n    InsufficientBalance,\r\n    \r\n    #[msg(\"Cannot mint/burn zero tokens\")]\r\n    ZeroAmount,\r\n    \r\n    #[msg(\"Invalid token account owner\")]\r\n    InvalidTokenAccount,\r\n    \r\n    #[msg(\"Invalid token mint\")]\r\n    InvalidMint,\r\n}\r\n\r\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","vevcoin-token","src","instructions","admin","initialize.rs"],"content":"use anchor_lang::prelude::*;\r\n\r\nuse crate::contexts::InitializeMint;\r\n\r\n/// Initialize the veVCoin mint with Token-2022 Non-Transferable extension\r\npub fn handler(ctx: Context\u003cInitializeMint\u003e, staking_protocol: Pubkey) -\u003e Result\u003c()\u003e {\r\n    let config = \u0026mut ctx.accounts.config;\r\n    \r\n    config.authority = ctx.accounts.authority.key();\r\n    config.mint = ctx.accounts.mint.key();\r\n    config.staking_protocol = staking_protocol;\r\n    config.total_supply = 0;\r\n    config.total_holders = 0;\r\n    config.bump = ctx.bumps.config;\r\n    \r\n    msg!(\"veVCoin mint initialized\");\r\n    msg!(\"Mint: {}\", config.mint);\r\n    msg!(\"Staking Protocol: {}\", staking_protocol);\r\n    \r\n    Ok(())\r\n}\r\n\r\n","traces":[{"line":6,"address":[],"length":0,"stats":{"Line":0}},{"line":7,"address":[],"length":0,"stats":{"Line":0}},{"line":9,"address":[],"length":0,"stats":{"Line":0}},{"line":10,"address":[],"length":0,"stats":{"Line":0}},{"line":11,"address":[],"length":0,"stats":{"Line":0}},{"line":12,"address":[],"length":0,"stats":{"Line":0}},{"line":13,"address":[],"length":0,"stats":{"Line":0}},{"line":14,"address":[],"length":0,"stats":{"Line":0}},{"line":16,"address":[],"length":0,"stats":{"Line":0}},{"line":17,"address":[],"length":0,"stats":{"Line":0}},{"line":18,"address":[],"length":0,"stats":{"Line":0}},{"line":20,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":12},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","vevcoin-token","src","instructions","admin","mod.rs"],"content":"/// Admin instructions\r\npub mod initialize;\r\npub mod update_authority;\r\npub mod update_staking_protocol;\r\n\r\npub use initialize::*;\r\npub use update_authority::*;\r\npub use update_staking_protocol::*;\r\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","vevcoin-token","src","instructions","admin","update_authority.rs"],"content":"use anchor_lang::prelude::*;\r\n\r\nuse crate::contexts::UpdateConfig;\r\nuse crate::errors::VeVCoinError;\r\n\r\n/// Update the authority\r\npub fn handler(ctx: Context\u003cUpdateConfig\u003e, new_authority: Pubkey) -\u003e Result\u003c()\u003e {\r\n    let config = \u0026mut ctx.accounts.config;\r\n    \r\n    require!(\r\n        ctx.accounts.authority.key() == config.authority,\r\n        VeVCoinError::Unauthorized\r\n    );\r\n    \r\n    config.authority = new_authority;\r\n    \r\n    msg!(\"Authority updated to: {}\", new_authority);\r\n    \r\n    Ok(())\r\n}\r\n\r\n","traces":[{"line":7,"address":[],"length":0,"stats":{"Line":0}},{"line":8,"address":[],"length":0,"stats":{"Line":0}},{"line":10,"address":[],"length":0,"stats":{"Line":0}},{"line":11,"address":[],"length":0,"stats":{"Line":0}},{"line":12,"address":[],"length":0,"stats":{"Line":0}},{"line":15,"address":[],"length":0,"stats":{"Line":0}},{"line":17,"address":[],"length":0,"stats":{"Line":0}},{"line":19,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":8},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","vevcoin-token","src","instructions","admin","update_staking_protocol.rs"],"content":"use anchor_lang::prelude::*;\r\n\r\nuse crate::contexts::UpdateConfig;\r\nuse crate::errors::VeVCoinError;\r\n\r\n/// Update the staking protocol address (only authority)\r\npub fn handler(ctx: Context\u003cUpdateConfig\u003e, new_staking_protocol: Pubkey) -\u003e Result\u003c()\u003e {\r\n    let config = \u0026mut ctx.accounts.config;\r\n    \r\n    require!(\r\n        ctx.accounts.authority.key() == config.authority,\r\n        VeVCoinError::Unauthorized\r\n    );\r\n    \r\n    config.staking_protocol = new_staking_protocol;\r\n    \r\n    msg!(\"Staking protocol updated to: {}\", new_staking_protocol);\r\n    \r\n    Ok(())\r\n}\r\n\r\n","traces":[{"line":7,"address":[],"length":0,"stats":{"Line":0}},{"line":8,"address":[],"length":0,"stats":{"Line":0}},{"line":10,"address":[],"length":0,"stats":{"Line":0}},{"line":11,"address":[],"length":0,"stats":{"Line":0}},{"line":12,"address":[],"length":0,"stats":{"Line":0}},{"line":15,"address":[],"length":0,"stats":{"Line":0}},{"line":17,"address":[],"length":0,"stats":{"Line":0}},{"line":19,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":8},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","vevcoin-token","src","instructions","mod.rs"],"content":"/// Instructions module - Instruction handlers\r\npub mod admin;\r\npub mod token;\r\n\r\npub use admin::*;\r\npub use token::*;\r\n\r\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","vevcoin-token","src","instructions","token","burn.rs"],"content":"use anchor_lang::prelude::*;\r\nuse anchor_spl::token_2022;\r\n\r\nuse crate::constants::VEVCOIN_CONFIG_SEED;\r\nuse crate::contexts::BurnVeVCoin;\r\nuse crate::errors::VeVCoinError;\r\n\r\n/// Burn veVCoin from a user (only callable by staking protocol)\r\n/// Called when user unstakes VCoin\r\npub fn handler(ctx: Context\u003cBurnVeVCoin\u003e, amount: u64) -\u003e Result\u003c()\u003e {\r\n    // Get bumps from context\r\n    let config_bump = ctx.bumps.config;\r\n    \r\n    // Only staking protocol can burn\r\n    require!(\r\n        ctx.accounts.staking_protocol.key() == ctx.accounts.config.staking_protocol,\r\n        VeVCoinError::Unauthorized\r\n    );\r\n    \r\n    require!(amount \u003e 0, VeVCoinError::ZeroAmount);\r\n    require!(ctx.accounts.user_account.balance \u003e= amount, VeVCoinError::InsufficientBalance);\r\n    \r\n    let clock = Clock::get()?;\r\n    let current_balance = ctx.accounts.user_account.balance;\r\n    let current_total_supply = ctx.accounts.config.total_supply;\r\n    let current_total_holders = ctx.accounts.config.total_holders;\r\n    let new_balance = current_balance.checked_sub(amount).unwrap();\r\n    \r\n    // Burn tokens using Token-2022 first\r\n    let seeds = \u0026[\r\n        VEVCOIN_CONFIG_SEED,\r\n        \u0026[config_bump],\r\n    ];\r\n    let signer_seeds = \u0026[\u0026seeds[..]];\r\n    \r\n    token_2022::burn(\r\n        CpiContext::new_with_signer(\r\n            ctx.accounts.token_program.to_account_info(),\r\n            token_2022::Burn {\r\n                mint: ctx.accounts.mint.to_account_info(),\r\n                from: ctx.accounts.user_token_account.to_account_info(),\r\n                authority: ctx.accounts.config.to_account_info(),\r\n            },\r\n            signer_seeds,\r\n        ),\r\n        amount,\r\n    )?;\r\n    \r\n    // Now update state\r\n    let user_account = \u0026mut ctx.accounts.user_account;\r\n    let config = \u0026mut ctx.accounts.config;\r\n    \r\n    // Update balances\r\n    user_account.balance = new_balance;\r\n    user_account.last_update_at = clock.unix_timestamp;\r\n    config.total_supply = current_total_supply.checked_sub(amount).unwrap();\r\n    \r\n    // Update holder count if balance is now zero\r\n    if new_balance == 0 {\r\n        config.total_holders = current_total_holders.checked_sub(1).unwrap();\r\n    }\r\n    \r\n    msg!(\"Burned {} veVCoin from {}\", amount, ctx.accounts.user.key());\r\n    msg!(\"New balance: {}\", user_account.balance);\r\n    \r\n    Ok(())\r\n}\r\n\r\n","traces":[{"line":10,"address":[],"length":0,"stats":{"Line":0}},{"line":12,"address":[],"length":0,"stats":{"Line":0}},{"line":15,"address":[],"length":0,"stats":{"Line":0}},{"line":16,"address":[],"length":0,"stats":{"Line":0}},{"line":17,"address":[],"length":0,"stats":{"Line":0}},{"line":20,"address":[],"length":0,"stats":{"Line":0}},{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":34},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","vevcoin-token","src","instructions","token","get_balance.rs"],"content":"use anchor_lang::prelude::*;\r\n\r\nuse crate::contexts::GetBalance;\r\n\r\n/// Get user's veVCoin balance (view function)\r\npub fn handler(ctx: Context\u003cGetBalance\u003e) -\u003e Result\u003cu64\u003e {\r\n    Ok(ctx.accounts.user_account.balance)\r\n}\r\n\r\n","traces":[{"line":6,"address":[],"length":0,"stats":{"Line":0}},{"line":7,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":2},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","vevcoin-token","src","instructions","token","mint.rs"],"content":"use anchor_lang::prelude::*;\r\nuse anchor_spl::token_2022;\r\n\r\nuse crate::constants::VEVCOIN_CONFIG_SEED;\r\nuse crate::contexts::MintVeVCoin;\r\nuse crate::errors::VeVCoinError;\r\n\r\n/// Mint veVCoin to a user (only callable by staking protocol)\r\n/// Called when user stakes VCoin\r\npub fn handler(ctx: Context\u003cMintVeVCoin\u003e, amount: u64) -\u003e Result\u003c()\u003e {\r\n    // Get bump from context\r\n    let config_bump = ctx.bumps.config;\r\n    let user_account_bump = ctx.bumps.user_account;\r\n    \r\n    // Only staking protocol can mint\r\n    require!(\r\n        ctx.accounts.staking_protocol.key() == ctx.accounts.config.staking_protocol,\r\n        VeVCoinError::Unauthorized\r\n    );\r\n    \r\n    require!(amount \u003e 0, VeVCoinError::ZeroAmount);\r\n    \r\n    let clock = Clock::get()?;\r\n    let now = clock.unix_timestamp;\r\n    \r\n    // Check if first time user\r\n    let is_new_user = ctx.accounts.user_account.balance == 0;\r\n    let current_balance = ctx.accounts.user_account.balance;\r\n    let current_total_supply = ctx.accounts.config.total_supply;\r\n    let current_total_holders = ctx.accounts.config.total_holders;\r\n    \r\n    // Mint tokens using Token-2022 first\r\n    let seeds = \u0026[\r\n        VEVCOIN_CONFIG_SEED,\r\n        \u0026[config_bump],\r\n    ];\r\n    let signer_seeds = \u0026[\u0026seeds[..]];\r\n    \r\n    token_2022::mint_to(\r\n        CpiContext::new_with_signer(\r\n            ctx.accounts.token_program.to_account_info(),\r\n            token_2022::MintTo {\r\n                mint: ctx.accounts.mint.to_account_info(),\r\n                to: ctx.accounts.user_token_account.to_account_info(),\r\n                authority: ctx.accounts.config.to_account_info(),\r\n            },\r\n            signer_seeds,\r\n        ),\r\n        amount,\r\n    )?;\r\n    \r\n    // Now update state\r\n    let user_account = \u0026mut ctx.accounts.user_account;\r\n    let config = \u0026mut ctx.accounts.config;\r\n    \r\n    // Initialize user account if first time\r\n    if is_new_user {\r\n        user_account.owner = ctx.accounts.user.key();\r\n        user_account.first_mint_at = now;\r\n        user_account.bump = user_account_bump;\r\n        config.total_holders = current_total_holders.checked_add(1).unwrap();\r\n    }\r\n    \r\n    // Update balances\r\n    user_account.balance = current_balance.checked_add(amount).unwrap();\r\n    user_account.last_update_at = now;\r\n    config.total_supply = current_total_supply.checked_add(amount).unwrap();\r\n    \r\n    msg!(\"Minted {} veVCoin to {}\", amount, ctx.accounts.user.key());\r\n    msg!(\"New balance: {}\", user_account.balance);\r\n    \r\n    Ok(())\r\n}\r\n\r\n","traces":[{"line":10,"address":[],"length":0,"stats":{"Line":0}},{"line":12,"address":[],"length":0,"stats":{"Line":0}},{"line":13,"address":[],"length":0,"stats":{"Line":0}},{"line":16,"address":[],"length":0,"stats":{"Line":0}},{"line":17,"address":[],"length":0,"stats":{"Line":0}},{"line":18,"address":[],"length":0,"stats":{"Line":0}},{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":38},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","vevcoin-token","src","instructions","token","mod.rs"],"content":"/// Token instructions\r\npub mod mint;\r\npub mod burn;\r\npub mod get_balance;\r\n\r\npub use mint::*;\r\npub use burn::*;\r\npub use get_balance::*;\r\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","vevcoin-token","src","lib.rs"],"content":"use anchor_lang::prelude::*;\r\n\r\npub mod constants;\r\npub mod contexts;\r\npub mod errors;\r\npub mod instructions;\r\npub mod state;\r\n\r\n#[cfg(test)]\r\nmod tests;\r\n\r\nuse contexts::*;\r\n\r\ndeclare_id!(\"FB39ae9x53FxVL3pER9LqCPEx2TRnEnQP55i838Upnjx\");\r\n\r\n/// veVCoin Token - Vote-Escrowed VCoin (Soulbound)\r\n/// \r\n/// Token-2022 with Non-Transferable extension making it truly soulbound.\r\n/// Users receive veVCoin when they stake VCoin, representing their voting power.\r\n/// \r\n/// Key Properties:\r\n/// - Non-Transferable: Cannot be traded on secondary markets\r\n/// - Mint Authority: Only Staking Protocol can mint\r\n/// - Burn Authority: Only Staking Protocol can burn (on unstake)\r\n/// - Prevents governance power markets\r\n\r\n#[program]\r\npub mod vevcoin_token {\r\n    use super::*;\r\n\r\n    /// Initialize the veVCoin mint with Token-2022 Non-Transferable extension\r\n    pub fn initialize_mint(\r\n        ctx: Context\u003cInitializeMint\u003e,\r\n        staking_protocol: Pubkey,\r\n    ) -\u003e Result\u003c()\u003e {\r\n        instructions::admin::initialize::handler(ctx, staking_protocol)\r\n    }\r\n\r\n    /// Mint veVCoin to a user (only callable by staking protocol)\r\n    pub fn mint_vevcoin(ctx: Context\u003cMintVeVCoin\u003e, amount: u64) -\u003e Result\u003c()\u003e {\r\n        instructions::token::mint::handler(ctx, amount)\r\n    }\r\n\r\n    /// Burn veVCoin from a user (only callable by staking protocol)\r\n    pub fn burn_vevcoin(ctx: Context\u003cBurnVeVCoin\u003e, amount: u64) -\u003e Result\u003c()\u003e {\r\n        instructions::token::burn::handler(ctx, amount)\r\n    }\r\n\r\n    /// Update the staking protocol address (only authority)\r\n    pub fn update_staking_protocol(\r\n        ctx: Context\u003cUpdateConfig\u003e,\r\n        new_staking_protocol: Pubkey,\r\n    ) -\u003e Result\u003c()\u003e {\r\n        instructions::admin::update_staking_protocol::handler(ctx, new_staking_protocol)\r\n    }\r\n\r\n    /// Update the authority\r\n    pub fn update_authority(ctx: Context\u003cUpdateConfig\u003e, new_authority: Pubkey) -\u003e Result\u003c()\u003e {\r\n        instructions::admin::update_authority::handler(ctx, new_authority)\r\n    }\r\n\r\n    /// Get user's veVCoin balance (view function)\r\n    pub fn get_balance(ctx: Context\u003cGetBalance\u003e) -\u003e Result\u003cu64\u003e {\r\n        instructions::token::get_balance::handler(ctx)\r\n    }\r\n}\r\n","traces":[{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":12},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","vevcoin-token","src","state","config.rs"],"content":"use anchor_lang::prelude::*;\r\n\r\n/// veVCoin Configuration Account (Singleton PDA)\r\n#[account]\r\n#[derive(Default)]\r\npub struct VeVCoinConfig {\r\n    /// The admin authority (can update staking protocol address)\r\n    pub authority: Pubkey,\r\n    /// The veVCoin mint address\r\n    pub mint: Pubkey,\r\n    /// The authorized staking protocol that can mint/burn\r\n    pub staking_protocol: Pubkey,\r\n    /// Total veVCoin currently in circulation\r\n    pub total_supply: u64,\r\n    /// Total unique holders\r\n    pub total_holders: u64,\r\n    /// Bump seed for PDA\r\n    pub bump: u8,\r\n}\r\n\r\nimpl VeVCoinConfig {\r\n    pub const LEN: usize = 8 + // discriminator\r\n        32 + // authority\r\n        32 + // mint\r\n        32 + // staking_protocol\r\n        8 +  // total_supply\r\n        8 +  // total_holders\r\n        1;   // bump\r\n}\r\n\r\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","vevcoin-token","src","state","mod.rs"],"content":"/// State module - Account structures\r\nmod config;\r\nmod user;\r\n\r\npub use config::*;\r\npub use user::*;\r\n\r\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","vevcoin-token","src","state","user.rs"],"content":"use anchor_lang::prelude::*;\r\n\r\nuse crate::constants::USER_VEVCOIN_SEED;\r\n\r\n/// User veVCoin Account (PDA per user)\r\n/// Tracks individual veVCoin balance and metadata\r\n#[account]\r\n#[derive(Default)]\r\npub struct UserVeVCoin {\r\n    /// The user's wallet address\r\n    pub owner: Pubkey,\r\n    /// Current veVCoin balance\r\n    pub balance: u64,\r\n    /// When veVCoin was first minted to this user\r\n    pub first_mint_at: i64,\r\n    /// When veVCoin was last updated\r\n    pub last_update_at: i64,\r\n    /// Bump seed for PDA\r\n    pub bump: u8,\r\n}\r\n\r\nimpl UserVeVCoin {\r\n    pub const LEN: usize = 8 + // discriminator\r\n        32 + // owner\r\n        8 +  // balance\r\n        8 +  // first_mint_at\r\n        8 +  // last_update_at\r\n        1;   // bump\r\n        \r\n    pub const SEED: \u0026'static [u8] = USER_VEVCOIN_SEED;\r\n}\r\n\r\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","vevcoin-token","src","tests.rs"],"content":"//! Unit tests for veVCoin Token (Soulbound)\r\n//!\r\n//! These tests run against the ACTUAL program code.\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n    use crate::constants::*;\r\n    use crate::state::{VeVCoinConfig, UserVeVCoin};\r\n    use anchor_lang::prelude::Pubkey;\r\n\r\n    // ========================================================================\r\n    // Constants Tests\r\n    // ========================================================================\r\n\r\n    #[test]\r\n    fn test_vevcoin_decimals() {\r\n        assert_eq!(VEVCOIN_DECIMALS, 9, \"veVCoin should have 9 decimals\");\r\n    }\r\n\r\n    #[test]\r\n    fn test_four_years_seconds() {\r\n        let expected = 4 * 365 * 24 * 60 * 60;\r\n        assert_eq!(FOUR_YEARS_SECONDS, expected, \"4 years in seconds\");\r\n    }\r\n\r\n    #[test]\r\n    fn test_token_metadata() {\r\n        assert_eq!(TOKEN_NAME, \"veVCoin\");\r\n        assert_eq!(TOKEN_SYMBOL, \"veVIWO\");\r\n        assert!(TOKEN_URI.starts_with(\"https://\"), \"URI should be HTTPS\");\r\n    }\r\n\r\n    // ========================================================================\r\n    // PDA Derivation Tests\r\n    // ========================================================================\r\n\r\n    #[test]\r\n    fn test_config_pda_seed() {\r\n        assert_eq!(VEVCOIN_CONFIG_SEED, b\"vevcoin-config\");\r\n    }\r\n\r\n    #[test]\r\n    fn test_user_pda_seed() {\r\n        assert_eq!(USER_VEVCOIN_SEED, b\"user-vevcoin\");\r\n    }\r\n\r\n    #[test]\r\n    fn test_config_pda_derivation() {\r\n        let program_id = Pubkey::new_unique();\r\n        let (pda, bump) = Pubkey::find_program_address(\r\n            \u0026[VEVCOIN_CONFIG_SEED],\r\n            \u0026program_id\r\n        );\r\n        \r\n        assert!(bump \u003c= 255);\r\n        assert_ne!(pda, Pubkey::default());\r\n    }\r\n\r\n    #[test]\r\n    fn test_user_pda_derivation() {\r\n        let program_id = Pubkey::new_unique();\r\n        let user = Pubkey::new_unique();\r\n        \r\n        let (pda, bump) = Pubkey::find_program_address(\r\n            \u0026[USER_VEVCOIN_SEED, user.as_ref()],\r\n            \u0026program_id\r\n        );\r\n        \r\n        assert!(bump \u003c= 255);\r\n        assert_ne!(pda, Pubkey::default());\r\n    }\r\n\r\n    // ========================================================================\r\n    // State Tests\r\n    // ========================================================================\r\n\r\n    #[test]\r\n    fn test_vevcoin_config_size() {\r\n        let expected_size = 8 + 32 + 32 + 32 + 8 + 8 + 1;\r\n        assert_eq!(VeVCoinConfig::LEN, expected_size, \"Config size mismatch\");\r\n    }\r\n\r\n    #[test]\r\n    fn test_user_vevcoin_size() {\r\n        let expected_size = 8 + 32 + 8 + 8 + 8 + 1;\r\n        assert_eq!(UserVeVCoin::LEN, expected_size, \"User account size mismatch\");\r\n    }\r\n\r\n    #[test]\r\n    fn test_config_default() {\r\n        let config = VeVCoinConfig::default();\r\n        assert_eq!(config.total_supply, 0);\r\n        assert_eq!(config.total_holders, 0);\r\n        assert_eq!(config.bump, 0);\r\n    }\r\n\r\n    #[test]\r\n    fn test_user_vevcoin_default() {\r\n        let user = UserVeVCoin::default();\r\n        assert_eq!(user.balance, 0);\r\n        assert_eq!(user.first_mint_at, 0);\r\n        assert_eq!(user.last_update_at, 0);\r\n    }\r\n\r\n    // ========================================================================\r\n    // Mint/Burn Logic Tests\r\n    // ========================================================================\r\n\r\n    #[test]\r\n    fn test_mint_increases_balance() {\r\n        let mut user = UserVeVCoin::default();\r\n        let mint_amount = 1000u64 * 1_000_000_000u64; // 1000 veVCoin\r\n        \r\n        // Simulate mint\r\n        user.balance = user.balance.checked_add(mint_amount).unwrap();\r\n        \r\n        assert_eq!(user.balance, mint_amount);\r\n    }\r\n\r\n    #[test]\r\n    fn test_burn_decreases_balance() {\r\n        let mut user = UserVeVCoin::default();\r\n        user.balance = 1000u64 * 1_000_000_000u64;\r\n        \r\n        let burn_amount = 400u64 * 1_000_000_000u64;\r\n        user.balance = user.balance.checked_sub(burn_amount).unwrap();\r\n        \r\n        assert_eq!(user.balance, 600u64 * 1_000_000_000u64);\r\n    }\r\n\r\n    #[test]\r\n    fn test_burn_exact_balance() {\r\n        let mut user = UserVeVCoin::default();\r\n        user.balance = 1000u64 * 1_000_000_000u64;\r\n        \r\n        // Burn everything\r\n        user.balance = user.balance.checked_sub(user.balance).unwrap();\r\n        \r\n        assert_eq!(user.balance, 0);\r\n    }\r\n\r\n    #[test]\r\n    fn test_burn_more_than_balance_fails() {\r\n        let user = UserVeVCoin::default();\r\n        // user.balance is 0\r\n        \r\n        let burn_amount = 100u64;\r\n        let result = user.balance.checked_sub(burn_amount);\r\n        \r\n        assert!(result.is_none(), \"Burning more than balance should fail\");\r\n    }\r\n\r\n    // ========================================================================\r\n    // Total Supply Tracking Tests\r\n    // ========================================================================\r\n\r\n    #[test]\r\n    fn test_total_supply_increases_on_mint() {\r\n        let mut config = VeVCoinConfig::default();\r\n        \r\n        let mint1 = 1000u64 * 1_000_000_000u64;\r\n        let mint2 = 500u64 * 1_000_000_000u64;\r\n        \r\n        config.total_supply = config.total_supply.checked_add(mint1).unwrap();\r\n        config.total_supply = config.total_supply.checked_add(mint2).unwrap();\r\n        \r\n        assert_eq!(config.total_supply, 1500u64 * 1_000_000_000u64);\r\n    }\r\n\r\n    #[test]\r\n    fn test_total_supply_decreases_on_burn() {\r\n        let mut config = VeVCoinConfig::default();\r\n        config.total_supply = 2000u64 * 1_000_000_000u64;\r\n        \r\n        let burn = 500u64 * 1_000_000_000u64;\r\n        config.total_supply = config.total_supply.checked_sub(burn).unwrap();\r\n        \r\n        assert_eq!(config.total_supply, 1500u64 * 1_000_000_000u64);\r\n    }\r\n\r\n    // ========================================================================\r\n    // Total Holders Tracking Tests\r\n    // ========================================================================\r\n\r\n    #[test]\r\n    fn test_holder_count_on_first_mint() {\r\n        let mut config = VeVCoinConfig::default();\r\n        let user = UserVeVCoin::default();\r\n        \r\n        // First mint to a new user should increment holders\r\n        if user.balance == 0 {\r\n            config.total_holders = config.total_holders.checked_add(1).unwrap();\r\n        }\r\n        \r\n        assert_eq!(config.total_holders, 1);\r\n    }\r\n\r\n    #[test]\r\n    fn test_holder_count_on_full_burn() {\r\n        let mut config = VeVCoinConfig::default();\r\n        config.total_holders = 5;\r\n        \r\n        let mut user = UserVeVCoin::default();\r\n        user.balance = 1000u64 * 1_000_000_000u64;\r\n        \r\n        // Full burn should decrement holders\r\n        user.balance = 0;\r\n        if user.balance == 0 {\r\n            config.total_holders = config.total_holders.checked_sub(1).unwrap();\r\n        }\r\n        \r\n        assert_eq!(config.total_holders, 4);\r\n    }\r\n\r\n    // ========================================================================\r\n    // Invariant Tests\r\n    // ========================================================================\r\n\r\n    #[test]\r\n    fn test_invariant_total_supply_equals_sum_of_balances() {\r\n        // In a real scenario:\r\n        // config.total_supply == sum(all user.balance)\r\n        \r\n        let config_supply = 3000u64 * 1_000_000_000u64;\r\n        let user1_balance = 1000u64 * 1_000_000_000u64;\r\n        let user2_balance = 2000u64 * 1_000_000_000u64;\r\n        \r\n        assert_eq!(config_supply, user1_balance + user2_balance);\r\n    }\r\n\r\n    // ========================================================================\r\n    // Soulbound Property Tests\r\n    // ========================================================================\r\n\r\n    #[test]\r\n    fn test_soulbound_property() {\r\n        // veVCoin is non-transferable\r\n        // This is enforced by Token-2022 NonTransferable extension\r\n        // Here we just verify the concept\r\n        \r\n        let user1 = Pubkey::new_unique();\r\n        let user2 = Pubkey::new_unique();\r\n        \r\n        // Different users should have different PDAs\r\n        let program_id = Pubkey::new_unique();\r\n        \r\n        let (pda1, _) = Pubkey::find_program_address(\r\n            \u0026[USER_VEVCOIN_SEED, user1.as_ref()],\r\n            \u0026program_id\r\n        );\r\n        \r\n        let (pda2, _) = Pubkey::find_program_address(\r\n            \u0026[USER_VEVCOIN_SEED, user2.as_ref()],\r\n            \u0026program_id\r\n        );\r\n        \r\n        assert_ne!(pda1, pda2, \"Each user should have unique veVCoin account\");\r\n    }\r\n}\r\n\r\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","vevcoin-token","tests","admin.rs"],"content":"//! Integration tests for vevcoin-token admin instructions\r\n\r\nmod common;\r\n\r\nuse common::*;\r\nuse solana_sdk::signature::{Keypair, Signer};\r\n\r\n// ============================================================================\r\n// update_staking_protocol tests\r\n// ============================================================================\r\n\r\n/// Test update staking protocol success\r\n#[tokio::test]\r\nasync fn test_update_staking_protocol_success() {\r\n    let mut ctx = TestContext::new().await;\r\n    \r\n    let (config_pda, _bump) = ctx.get_config_pda();\r\n    let mint = Keypair::new();\r\n    let staking_protocol = Keypair::new();\r\n    \r\n    let init_ix = create_initialize_mint_ix(\r\n        \u0026ctx.program_id,\r\n        \u0026ctx.payer.pubkey(),\r\n        \u0026config_pda,\r\n        \u0026mint.pubkey(),\r\n        \u0026staking_protocol.pubkey(),\r\n    );\r\n    \r\n    ctx.process_transaction(\u0026[init_ix], \u0026[]).await.unwrap();\r\n    \r\n    let new_staking_protocol = Keypair::new();\r\n    let update_ix = create_update_staking_protocol_ix(\r\n        \u0026ctx.program_id,\r\n        \u0026ctx.payer.pubkey(),\r\n        \u0026config_pda,\r\n        \u0026new_staking_protocol.pubkey(),\r\n    );\r\n    \r\n    let result = ctx.process_transaction(\u0026[update_ix], \u0026[]).await;\r\n    assert!(result.is_ok());\r\n}\r\n\r\n/// Test update staking protocol unauthorized\r\n#[tokio::test]\r\nasync fn test_update_staking_protocol_unauthorized() {\r\n    let mut ctx = TestContext::new().await;\r\n    \r\n    let (config_pda, _bump) = ctx.get_config_pda();\r\n    let mint = Keypair::new();\r\n    let staking_protocol = Keypair::new();\r\n    \r\n    let init_ix = create_initialize_mint_ix(\r\n        \u0026ctx.program_id,\r\n        \u0026ctx.payer.pubkey(),\r\n        \u0026config_pda,\r\n        \u0026mint.pubkey(),\r\n        \u0026staking_protocol.pubkey(),\r\n    );\r\n    \r\n    ctx.process_transaction(\u0026[init_ix], \u0026[]).await.unwrap();\r\n    \r\n    let unauthorized = Keypair::new();\r\n    let new_staking_protocol = Keypair::new();\r\n    let update_ix = create_update_staking_protocol_ix(\r\n        \u0026ctx.program_id,\r\n        \u0026unauthorized.pubkey(),\r\n        \u0026config_pda,\r\n        \u0026new_staking_protocol.pubkey(),\r\n    );\r\n    \r\n    assert_eq!(update_ix.accounts[0].pubkey, unauthorized.pubkey());\r\n}\r\n\r\n/// Test update staking protocol multiple times\r\n#[tokio::test]\r\nasync fn test_update_staking_protocol_multiple() {\r\n    let mut ctx = TestContext::new().await;\r\n    \r\n    let (config_pda, _bump) = ctx.get_config_pda();\r\n    let mint = Keypair::new();\r\n    let staking_protocol = Keypair::new();\r\n    \r\n    let init_ix = create_initialize_mint_ix(\r\n        \u0026ctx.program_id,\r\n        \u0026ctx.payer.pubkey(),\r\n        \u0026config_pda,\r\n        \u0026mint.pubkey(),\r\n        \u0026staking_protocol.pubkey(),\r\n    );\r\n    \r\n    ctx.process_transaction(\u0026[init_ix], \u0026[]).await.unwrap();\r\n    \r\n    for i in 0..3 {\r\n        let new_staking_protocol = Keypair::new();\r\n        let update_ix = create_update_staking_protocol_ix(\r\n            \u0026ctx.program_id,\r\n            \u0026ctx.payer.pubkey(),\r\n            \u0026config_pda,\r\n            \u0026new_staking_protocol.pubkey(),\r\n        );\r\n        \r\n        let result = ctx.process_transaction(\u0026[update_ix], \u0026[]).await;\r\n        assert!(result.is_ok(), \"Update #{} should succeed\", i + 1);\r\n    }\r\n}\r\n\r\n// ============================================================================\r\n// update_authority tests\r\n// ============================================================================\r\n\r\n/// Test update authority success\r\n#[tokio::test]\r\nasync fn test_update_authority_success() {\r\n    let mut ctx = TestContext::new().await;\r\n    \r\n    let (config_pda, _bump) = ctx.get_config_pda();\r\n    let mint = Keypair::new();\r\n    let staking_protocol = Keypair::new();\r\n    \r\n    let init_ix = create_initialize_mint_ix(\r\n        \u0026ctx.program_id,\r\n        \u0026ctx.payer.pubkey(),\r\n        \u0026config_pda,\r\n        \u0026mint.pubkey(),\r\n        \u0026staking_protocol.pubkey(),\r\n    );\r\n    \r\n    ctx.process_transaction(\u0026[init_ix], \u0026[]).await.unwrap();\r\n    \r\n    let new_authority = Keypair::new();\r\n    let update_ix = create_update_authority_ix(\r\n        \u0026ctx.program_id,\r\n        \u0026ctx.payer.pubkey(),\r\n        \u0026config_pda,\r\n        \u0026new_authority.pubkey(),\r\n    );\r\n    \r\n    let result = ctx.process_transaction(\u0026[update_ix], \u0026[]).await;\r\n    assert!(result.is_ok());\r\n}\r\n\r\n/// Test update authority unauthorized\r\n#[tokio::test]\r\nasync fn test_update_authority_unauthorized() {\r\n    let mut ctx = TestContext::new().await;\r\n    \r\n    let (config_pda, _bump) = ctx.get_config_pda();\r\n    let mint = Keypair::new();\r\n    let staking_protocol = Keypair::new();\r\n    \r\n    let init_ix = create_initialize_mint_ix(\r\n        \u0026ctx.program_id,\r\n        \u0026ctx.payer.pubkey(),\r\n        \u0026config_pda,\r\n        \u0026mint.pubkey(),\r\n        \u0026staking_protocol.pubkey(),\r\n    );\r\n    \r\n    ctx.process_transaction(\u0026[init_ix], \u0026[]).await.unwrap();\r\n    \r\n    let unauthorized = Keypair::new();\r\n    let new_authority = Keypair::new();\r\n    let update_ix = create_update_authority_ix(\r\n        \u0026ctx.program_id,\r\n        \u0026unauthorized.pubkey(),\r\n        \u0026config_pda,\r\n        \u0026new_authority.pubkey(),\r\n    );\r\n    \r\n    assert_eq!(update_ix.accounts[0].pubkey, unauthorized.pubkey());\r\n}\r\n\r\n/// Test update authority to self\r\n#[tokio::test]\r\nasync fn test_update_authority_to_self() {\r\n    let mut ctx = TestContext::new().await;\r\n    \r\n    let (config_pda, _bump) = ctx.get_config_pda();\r\n    let mint = Keypair::new();\r\n    let staking_protocol = Keypair::new();\r\n    \r\n    let init_ix = create_initialize_mint_ix(\r\n        \u0026ctx.program_id,\r\n        \u0026ctx.payer.pubkey(),\r\n        \u0026config_pda,\r\n        \u0026mint.pubkey(),\r\n        \u0026staking_protocol.pubkey(),\r\n    );\r\n    \r\n    ctx.process_transaction(\u0026[init_ix], \u0026[]).await.unwrap();\r\n    \r\n    let update_ix = create_update_authority_ix(\r\n        \u0026ctx.program_id,\r\n        \u0026ctx.payer.pubkey(),\r\n        \u0026config_pda,\r\n        \u0026ctx.payer.pubkey(),\r\n    );\r\n    \r\n    let result = ctx.process_transaction(\u0026[update_ix], \u0026[]).await;\r\n    assert!(result.is_ok());\r\n}\r\n\r\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","vevcoin-token","tests","burn.rs"],"content":"//! Integration tests for vevcoin-token burn_vevcoin instruction\r\n\r\nmod common;\r\n\r\nuse common::*;\r\nuse solana_sdk::signature::{Keypair, Signer};\r\n\r\n/// Test burn vevcoin instruction format\r\n#[tokio::test]\r\nasync fn test_burn_vevcoin_instruction_format() {\r\n    let ctx = TestContext::new().await;\r\n    \r\n    let (config_pda, _bump) = ctx.get_config_pda();\r\n    let mint = Keypair::new();\r\n    let staking_protocol = Keypair::new();\r\n    let source = Keypair::new();\r\n    let amount = 500u64;\r\n    \r\n    let ix = create_burn_vevcoin_ix(\r\n        \u0026ctx.program_id,\r\n        \u0026staking_protocol.pubkey(),\r\n        \u0026config_pda,\r\n        \u0026mint.pubkey(),\r\n        \u0026source.pubkey(),\r\n        amount,\r\n    );\r\n    \r\n    assert_eq!(ix.program_id, ctx.program_id);\r\n    assert_eq!(ix.accounts.len(), 5);\r\n    assert!(ix.accounts[0].is_signer);\r\n    assert_eq!(\u0026ix.data[8..16], \u0026amount.to_le_bytes());\r\n}\r\n\r\n/// Test burn vevcoin zero amount\r\n#[tokio::test]\r\nasync fn test_burn_vevcoin_zero_amount() {\r\n    let mut ctx = TestContext::new().await;\r\n    \r\n    let (config_pda, _bump) = ctx.get_config_pda();\r\n    let mint = Keypair::new();\r\n    let staking_protocol = Keypair::new();\r\n    \r\n    let init_ix = create_initialize_mint_ix(\r\n        \u0026ctx.program_id,\r\n        \u0026ctx.payer.pubkey(),\r\n        \u0026config_pda,\r\n        \u0026mint.pubkey(),\r\n        \u0026staking_protocol.pubkey(),\r\n    );\r\n    \r\n    ctx.process_transaction(\u0026[init_ix], \u0026[]).await.unwrap();\r\n    \r\n    let source = Keypair::new();\r\n    let ix = create_burn_vevcoin_ix(\r\n        \u0026ctx.program_id,\r\n        \u0026staking_protocol.pubkey(),\r\n        \u0026config_pda,\r\n        \u0026mint.pubkey(),\r\n        \u0026source.pubkey(),\r\n        0,\r\n    );\r\n    \r\n    assert_eq!(\u0026ix.data[8..16], \u00260u64.to_le_bytes());\r\n}\r\n\r\n/// Test burn vevcoin unauthorized\r\n#[tokio::test]\r\nasync fn test_burn_vevcoin_unauthorized() {\r\n    let mut ctx = TestContext::new().await;\r\n    \r\n    let (config_pda, _bump) = ctx.get_config_pda();\r\n    let mint = Keypair::new();\r\n    let staking_protocol = Keypair::new();\r\n    \r\n    let init_ix = create_initialize_mint_ix(\r\n        \u0026ctx.program_id,\r\n        \u0026ctx.payer.pubkey(),\r\n        \u0026config_pda,\r\n        \u0026mint.pubkey(),\r\n        \u0026staking_protocol.pubkey(),\r\n    );\r\n    \r\n    ctx.process_transaction(\u0026[init_ix], \u0026[]).await.unwrap();\r\n    \r\n    let unauthorized = Keypair::new();\r\n    let source = Keypair::new();\r\n    let ix = create_burn_vevcoin_ix(\r\n        \u0026ctx.program_id,\r\n        \u0026unauthorized.pubkey(),\r\n        \u0026config_pda,\r\n        \u0026mint.pubkey(),\r\n        \u0026source.pubkey(),\r\n        500,\r\n    );\r\n    \r\n    assert_eq!(ix.accounts[0].pubkey, unauthorized.pubkey());\r\n}\r\n\r\n/// Test burn vevcoin exceeds balance\r\n#[tokio::test]\r\nasync fn test_burn_vevcoin_exceeds_balance() {\r\n    let ctx = TestContext::new().await;\r\n    \r\n    let (config_pda, _bump) = ctx.get_config_pda();\r\n    let mint = Keypair::new();\r\n    let staking_protocol = Keypair::new();\r\n    let source = Keypair::new();\r\n    let excessive_amount = u64::MAX;\r\n    \r\n    let ix = create_burn_vevcoin_ix(\r\n        \u0026ctx.program_id,\r\n        \u0026staking_protocol.pubkey(),\r\n        \u0026config_pda,\r\n        \u0026mint.pubkey(),\r\n        \u0026source.pubkey(),\r\n        excessive_amount,\r\n    );\r\n    \r\n    assert_eq!(\u0026ix.data[8..16], \u0026excessive_amount.to_le_bytes());\r\n}\r\n\r\n/// Test burn vevcoin all balance\r\n#[tokio::test]\r\nasync fn test_burn_vevcoin_all_balance() {\r\n    let mut ctx = TestContext::new().await;\r\n    \r\n    let (config_pda, _bump) = ctx.get_config_pda();\r\n    let mint = Keypair::new();\r\n    let staking_protocol = Keypair::new();\r\n    \r\n    let init_ix = create_initialize_mint_ix(\r\n        \u0026ctx.program_id,\r\n        \u0026ctx.payer.pubkey(),\r\n        \u0026config_pda,\r\n        \u0026mint.pubkey(),\r\n        \u0026staking_protocol.pubkey(),\r\n    );\r\n    \r\n    ctx.process_transaction(\u0026[init_ix], \u0026[]).await.unwrap();\r\n    \r\n    let config = ctx.get_account(config_pda).await;\r\n    assert!(config.is_some());\r\n}\r\n\r\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","vevcoin-token","tests","common","mod.rs"],"content":"//! Common test utilities for vevcoin-token integration tests\r\n\r\nuse anchor_lang::prelude::*;\r\nuse solana_program_test::*;\r\nuse solana_sdk::{\r\n    account::Account,\r\n    hash::Hash,\r\n    instruction::{AccountMeta, Instruction},\r\n    pubkey::Pubkey,\r\n    signature::{Keypair, Signer},\r\n    system_instruction,\r\n    transaction::Transaction,\r\n};\r\n\r\n/// veVCoin configuration seed\r\npub const VEVCOIN_CONFIG_SEED: \u0026[u8] = b\"vevcoin-config\";\r\n\r\n/// Test context wrapper for vevcoin-token tests\r\npub struct TestContext {\r\n    pub banks_client: BanksClient,\r\n    pub payer: Keypair,\r\n    pub recent_blockhash: Hash,\r\n    pub program_id: Pubkey,\r\n}\r\n\r\nimpl TestContext {\r\n    pub async fn new() -\u003e Self {\r\n        let program_id = vevcoin_token::id();\r\n        let program_test = ProgramTest::new(\r\n            \"vevcoin_token\",\r\n            program_id,\r\n            processor!(vevcoin_token::entry),\r\n        );\r\n\r\n        let (banks_client, payer, recent_blockhash) = program_test.start().await;\r\n\r\n        Self {\r\n            banks_client,\r\n            payer,\r\n            recent_blockhash,\r\n            program_id,\r\n        }\r\n    }\r\n\r\n    pub async fn refresh_blockhash(\u0026mut self) {\r\n        self.recent_blockhash = self.banks_client.get_latest_blockhash().await.unwrap();\r\n    }\r\n\r\n    pub async fn get_account(\u0026mut self, pubkey: Pubkey) -\u003e Option\u003cAccount\u003e {\r\n        self.banks_client.get_account(pubkey).await.unwrap()\r\n    }\r\n\r\n    pub async fn airdrop(\u0026mut self, pubkey: \u0026Pubkey, lamports: u64) {\r\n        let ix = system_instruction::transfer(\u0026self.payer.pubkey(), pubkey, lamports);\r\n        let tx = Transaction::new_signed_with_payer(\r\n            \u0026[ix],\r\n            Some(\u0026self.payer.pubkey()),\r\n            \u0026[\u0026self.payer],\r\n            self.recent_blockhash,\r\n        );\r\n        self.banks_client.process_transaction(tx).await.unwrap();\r\n        self.refresh_blockhash().await;\r\n    }\r\n\r\n    pub fn get_config_pda(\u0026self) -\u003e (Pubkey, u8) {\r\n        Pubkey::find_program_address(\u0026[VEVCOIN_CONFIG_SEED], \u0026self.program_id)\r\n    }\r\n\r\n    pub async fn process_transaction(\r\n        \u0026mut self,\r\n        instructions: \u0026[Instruction],\r\n        signers: \u0026[\u0026Keypair],\r\n    ) -\u003e Result\u003c(), BanksClientError\u003e {\r\n        let mut all_signers = vec![\u0026self.payer];\r\n        all_signers.extend(signers);\r\n        \r\n        let tx = Transaction::new_signed_with_payer(\r\n            instructions,\r\n            Some(\u0026self.payer.pubkey()),\r\n            \u0026all_signers,\r\n            self.recent_blockhash,\r\n        );\r\n        \r\n        let result = self.banks_client.process_transaction(tx).await;\r\n        self.refresh_blockhash().await;\r\n        result\r\n    }\r\n}\r\n\r\n/// Helper to create an initialize_mint instruction\r\npub fn create_initialize_mint_ix(\r\n    program_id: \u0026Pubkey,\r\n    authority: \u0026Pubkey,\r\n    config: \u0026Pubkey,\r\n    mint: \u0026Pubkey,\r\n    staking_protocol: \u0026Pubkey,\r\n) -\u003e Instruction {\r\n    let mut data = vec![0u8; 8 + 32];\r\n    let discriminator = anchor_lang::solana_program::hash::hash(b\"global:initialize_mint\").to_bytes();\r\n    data[..8].copy_from_slice(\u0026discriminator[..8]);\r\n    data[8..40].copy_from_slice(staking_protocol.as_ref());\r\n\r\n    Instruction {\r\n        program_id: *program_id,\r\n        accounts: vec![\r\n            AccountMeta::new(*authority, true),\r\n            AccountMeta::new(*config, false),\r\n            AccountMeta::new(*mint, false),\r\n            AccountMeta::new_readonly(spl_token_2022::id(), false),\r\n            AccountMeta::new_readonly(solana_sdk::system_program::id(), false),\r\n            AccountMeta::new_readonly(solana_sdk::sysvar::rent::id(), false),\r\n        ],\r\n        data,\r\n    }\r\n}\r\n\r\n/// Helper to create a mint_vevcoin instruction\r\npub fn create_mint_vevcoin_ix(\r\n    program_id: \u0026Pubkey,\r\n    staking_protocol: \u0026Pubkey,\r\n    config: \u0026Pubkey,\r\n    mint: \u0026Pubkey,\r\n    destination: \u0026Pubkey,\r\n    amount: u64,\r\n) -\u003e Instruction {\r\n    let mut data = vec![0u8; 8 + 8];\r\n    let discriminator = anchor_lang::solana_program::hash::hash(b\"global:mint_vevcoin\").to_bytes();\r\n    data[..8].copy_from_slice(\u0026discriminator[..8]);\r\n    data[8..16].copy_from_slice(\u0026amount.to_le_bytes());\r\n\r\n    Instruction {\r\n        program_id: *program_id,\r\n        accounts: vec![\r\n            AccountMeta::new(*staking_protocol, true),\r\n            AccountMeta::new(*config, false),\r\n            AccountMeta::new(*mint, false),\r\n            AccountMeta::new(*destination, false),\r\n            AccountMeta::new_readonly(spl_token_2022::id(), false),\r\n        ],\r\n        data,\r\n    }\r\n}\r\n\r\n/// Helper to create a burn_vevcoin instruction\r\npub fn create_burn_vevcoin_ix(\r\n    program_id: \u0026Pubkey,\r\n    staking_protocol: \u0026Pubkey,\r\n    config: \u0026Pubkey,\r\n    mint: \u0026Pubkey,\r\n    source: \u0026Pubkey,\r\n    amount: u64,\r\n) -\u003e Instruction {\r\n    let mut data = vec![0u8; 8 + 8];\r\n    let discriminator = anchor_lang::solana_program::hash::hash(b\"global:burn_vevcoin\").to_bytes();\r\n    data[..8].copy_from_slice(\u0026discriminator[..8]);\r\n    data[8..16].copy_from_slice(\u0026amount.to_le_bytes());\r\n\r\n    Instruction {\r\n        program_id: *program_id,\r\n        accounts: vec![\r\n            AccountMeta::new(*staking_protocol, true),\r\n            AccountMeta::new(*config, false),\r\n            AccountMeta::new(*mint, false),\r\n            AccountMeta::new(*source, false),\r\n            AccountMeta::new_readonly(spl_token_2022::id(), false),\r\n        ],\r\n        data,\r\n    }\r\n}\r\n\r\n/// Helper to create an update_staking_protocol instruction\r\npub fn create_update_staking_protocol_ix(\r\n    program_id: \u0026Pubkey,\r\n    authority: \u0026Pubkey,\r\n    config: \u0026Pubkey,\r\n    new_staking_protocol: \u0026Pubkey,\r\n) -\u003e Instruction {\r\n    let mut data = vec![0u8; 8 + 32];\r\n    let discriminator = anchor_lang::solana_program::hash::hash(b\"global:update_staking_protocol\").to_bytes();\r\n    data[..8].copy_from_slice(\u0026discriminator[..8]);\r\n    data[8..40].copy_from_slice(new_staking_protocol.as_ref());\r\n\r\n    Instruction {\r\n        program_id: *program_id,\r\n        accounts: vec![\r\n            AccountMeta::new(*authority, true),\r\n            AccountMeta::new(*config, false),\r\n        ],\r\n        data,\r\n    }\r\n}\r\n\r\n/// Helper to create an update_authority instruction\r\npub fn create_update_authority_ix(\r\n    program_id: \u0026Pubkey,\r\n    authority: \u0026Pubkey,\r\n    config: \u0026Pubkey,\r\n    new_authority: \u0026Pubkey,\r\n) -\u003e Instruction {\r\n    let mut data = vec![0u8; 8 + 32];\r\n    let discriminator = anchor_lang::solana_program::hash::hash(b\"global:update_authority\").to_bytes();\r\n    data[..8].copy_from_slice(\u0026discriminator[..8]);\r\n    data[8..40].copy_from_slice(new_authority.as_ref());\r\n\r\n    Instruction {\r\n        program_id: *program_id,\r\n        accounts: vec![\r\n            AccountMeta::new(*authority, true),\r\n            AccountMeta::new(*config, false),\r\n        ],\r\n        data,\r\n    }\r\n}\r\n\r\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","vevcoin-token","tests","initialize.rs"],"content":"//! Integration tests for vevcoin-token initialize_mint instruction\r\n\r\nmod common;\r\n\r\nuse common::*;\r\nuse solana_sdk::signature::{Keypair, Signer};\r\n\r\n/// Test successful initialization\r\n#[tokio::test]\r\nasync fn test_initialize_mint_success() {\r\n    let mut ctx = TestContext::new().await;\r\n    \r\n    let (config_pda, _bump) = ctx.get_config_pda();\r\n    let mint = Keypair::new();\r\n    let staking_protocol = Keypair::new();\r\n    \r\n    let ix = create_initialize_mint_ix(\r\n        \u0026ctx.program_id,\r\n        \u0026ctx.payer.pubkey(),\r\n        \u0026config_pda,\r\n        \u0026mint.pubkey(),\r\n        \u0026staking_protocol.pubkey(),\r\n    );\r\n    \r\n    let result = ctx.process_transaction(\u0026[ix], \u0026[]).await;\r\n    assert!(result.is_ok(), \"Initialize should succeed\");\r\n    \r\n    let config_account = ctx.get_account(config_pda).await;\r\n    assert!(config_account.is_some(), \"Config account should exist\");\r\n}\r\n\r\n/// Test double initialization fails\r\n#[tokio::test]\r\nasync fn test_initialize_mint_already_initialized() {\r\n    let mut ctx = TestContext::new().await;\r\n    \r\n    let (config_pda, _bump) = ctx.get_config_pda();\r\n    let mint = Keypair::new();\r\n    let staking_protocol = Keypair::new();\r\n    \r\n    let ix = create_initialize_mint_ix(\r\n        \u0026ctx.program_id,\r\n        \u0026ctx.payer.pubkey(),\r\n        \u0026config_pda,\r\n        \u0026mint.pubkey(),\r\n        \u0026staking_protocol.pubkey(),\r\n    );\r\n    \r\n    ctx.process_transaction(\u0026[ix.clone()], \u0026[]).await.unwrap();\r\n    \r\n    let result = ctx.process_transaction(\u0026[ix], \u0026[]).await;\r\n    assert!(result.is_err(), \"Double initialization should fail\");\r\n}\r\n\r\n/// Test initialization with valid staking protocol\r\n#[tokio::test]\r\nasync fn test_initialize_with_staking_protocol() {\r\n    let mut ctx = TestContext::new().await;\r\n    \r\n    let (config_pda, _bump) = ctx.get_config_pda();\r\n    let mint = Keypair::new();\r\n    let staking_protocol = Keypair::new();\r\n    \r\n    let ix = create_initialize_mint_ix(\r\n        \u0026ctx.program_id,\r\n        \u0026ctx.payer.pubkey(),\r\n        \u0026config_pda,\r\n        \u0026mint.pubkey(),\r\n        \u0026staking_protocol.pubkey(),\r\n    );\r\n    \r\n    let result = ctx.process_transaction(\u0026[ix], \u0026[]).await;\r\n    assert!(result.is_ok());\r\n    \r\n    let config = ctx.get_account(config_pda).await;\r\n    assert!(config.is_some());\r\n}\r\n\r\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","vevcoin-token","tests","mint.rs"],"content":"//! Integration tests for vevcoin-token mint_vevcoin instruction\r\n\r\nmod common;\r\n\r\nuse common::*;\r\nuse solana_sdk::signature::{Keypair, Signer};\r\n\r\n/// Test mint vevcoin instruction format\r\n#[tokio::test]\r\nasync fn test_mint_vevcoin_instruction_format() {\r\n    let ctx = TestContext::new().await;\r\n    \r\n    let (config_pda, _bump) = ctx.get_config_pda();\r\n    let mint = Keypair::new();\r\n    let staking_protocol = Keypair::new();\r\n    let destination = Keypair::new();\r\n    let amount = 1000u64;\r\n    \r\n    let ix = create_mint_vevcoin_ix(\r\n        \u0026ctx.program_id,\r\n        \u0026staking_protocol.pubkey(),\r\n        \u0026config_pda,\r\n        \u0026mint.pubkey(),\r\n        \u0026destination.pubkey(),\r\n        amount,\r\n    );\r\n    \r\n    assert_eq!(ix.program_id, ctx.program_id);\r\n    assert_eq!(ix.accounts.len(), 5);\r\n    assert!(ix.accounts[0].is_signer);\r\n    assert_eq!(\u0026ix.data[8..16], \u0026amount.to_le_bytes());\r\n}\r\n\r\n/// Test mint vevcoin zero amount\r\n#[tokio::test]\r\nasync fn test_mint_vevcoin_zero_amount() {\r\n    let mut ctx = TestContext::new().await;\r\n    \r\n    let (config_pda, _bump) = ctx.get_config_pda();\r\n    let mint = Keypair::new();\r\n    let staking_protocol = Keypair::new();\r\n    \r\n    let init_ix = create_initialize_mint_ix(\r\n        \u0026ctx.program_id,\r\n        \u0026ctx.payer.pubkey(),\r\n        \u0026config_pda,\r\n        \u0026mint.pubkey(),\r\n        \u0026staking_protocol.pubkey(),\r\n    );\r\n    \r\n    ctx.process_transaction(\u0026[init_ix], \u0026[]).await.unwrap();\r\n    \r\n    let destination = Keypair::new();\r\n    let ix = create_mint_vevcoin_ix(\r\n        \u0026ctx.program_id,\r\n        \u0026staking_protocol.pubkey(),\r\n        \u0026config_pda,\r\n        \u0026mint.pubkey(),\r\n        \u0026destination.pubkey(),\r\n        0,\r\n    );\r\n    \r\n    assert_eq!(\u0026ix.data[8..16], \u00260u64.to_le_bytes());\r\n}\r\n\r\n/// Test mint vevcoin unauthorized\r\n#[tokio::test]\r\nasync fn test_mint_vevcoin_unauthorized() {\r\n    let mut ctx = TestContext::new().await;\r\n    \r\n    let (config_pda, _bump) = ctx.get_config_pda();\r\n    let mint = Keypair::new();\r\n    let staking_protocol = Keypair::new();\r\n    \r\n    let init_ix = create_initialize_mint_ix(\r\n        \u0026ctx.program_id,\r\n        \u0026ctx.payer.pubkey(),\r\n        \u0026config_pda,\r\n        \u0026mint.pubkey(),\r\n        \u0026staking_protocol.pubkey(),\r\n    );\r\n    \r\n    ctx.process_transaction(\u0026[init_ix], \u0026[]).await.unwrap();\r\n    \r\n    let unauthorized = Keypair::new();\r\n    let destination = Keypair::new();\r\n    let ix = create_mint_vevcoin_ix(\r\n        \u0026ctx.program_id,\r\n        \u0026unauthorized.pubkey(),\r\n        \u0026config_pda,\r\n        \u0026mint.pubkey(),\r\n        \u0026destination.pubkey(),\r\n        1000,\r\n    );\r\n    \r\n    assert_eq!(ix.accounts[0].pubkey, unauthorized.pubkey());\r\n}\r\n\r\n/// Test mint vevcoin large amount\r\n#[tokio::test]\r\nasync fn test_mint_vevcoin_large_amount() {\r\n    let ctx = TestContext::new().await;\r\n    \r\n    let (config_pda, _bump) = ctx.get_config_pda();\r\n    let mint = Keypair::new();\r\n    let staking_protocol = Keypair::new();\r\n    let destination = Keypair::new();\r\n    let large_amount = u64::MAX;\r\n    \r\n    let ix = create_mint_vevcoin_ix(\r\n        \u0026ctx.program_id,\r\n        \u0026staking_protocol.pubkey(),\r\n        \u0026config_pda,\r\n        \u0026mint.pubkey(),\r\n        \u0026destination.pubkey(),\r\n        large_amount,\r\n    );\r\n    \r\n    assert_eq!(\u0026ix.data[8..16], \u0026large_amount.to_le_bytes());\r\n}\r\n\r\n/// Test mint vevcoin multiple times\r\n#[tokio::test]\r\nasync fn test_mint_vevcoin_multiple() {\r\n    let mut ctx = TestContext::new().await;\r\n    \r\n    let (config_pda, _bump) = ctx.get_config_pda();\r\n    let mint = Keypair::new();\r\n    let staking_protocol = Keypair::new();\r\n    \r\n    let init_ix = create_initialize_mint_ix(\r\n        \u0026ctx.program_id,\r\n        \u0026ctx.payer.pubkey(),\r\n        \u0026config_pda,\r\n        \u0026mint.pubkey(),\r\n        \u0026staking_protocol.pubkey(),\r\n    );\r\n    \r\n    ctx.process_transaction(\u0026[init_ix], \u0026[]).await.unwrap();\r\n    \r\n    for i in 1..=5 {\r\n        let destination = Keypair::new();\r\n        let ix = create_mint_vevcoin_ix(\r\n            \u0026ctx.program_id,\r\n            \u0026staking_protocol.pubkey(),\r\n            \u0026config_pda,\r\n            \u0026mint.pubkey(),\r\n            \u0026destination.pubkey(),\r\n            i * 1000,\r\n        );\r\n        \r\n        assert_eq!(\u0026ix.data[8..16], \u0026(i * 1000u64).to_le_bytes());\r\n    }\r\n}\r\n\r\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","vilink-protocol","src","constants.rs"],"content":"/// Seeds\r\npub const CONFIG_SEED: \u0026[u8] = b\"vilink-config\";\r\npub const ACTION_SEED: \u0026[u8] = b\"action\";\r\npub const DAPP_REGISTRY_SEED: \u0026[u8] = b\"dapp\";\r\npub const USER_STATS_SEED: \u0026[u8] = b\"user-stats\";\r\npub const BATCH_SEED: \u0026[u8] = b\"batch\";\r\n\r\n/// Action types\r\npub const ACTION_TIP: u8 = 0;\r\npub const ACTION_VOUCH: u8 = 1;\r\npub const ACTION_FOLLOW: u8 = 2;\r\npub const ACTION_CHALLENGE: u8 = 3;\r\npub const ACTION_STAKE: u8 = 4;\r\npub const ACTION_CONTENT_REACT: u8 = 5;\r\npub const ACTION_DELEGATE: u8 = 6;\r\npub const ACTION_VOTE: u8 = 7;\r\n\r\n/// Limits\r\npub const MAX_ACTIONS_PER_BATCH: usize = 10;\r\npub const MAX_ACTION_EXPIRY: i64 = 7 * 24 * 60 * 60; // 7 days\r\npub const MIN_TIP_AMOUNT: u64 = 100_000_000; // 0.1 VCoin\r\npub const MAX_TIP_AMOUNT: u64 = 10_000_000_000_000; // 10,000 VCoin\r\n\r\n/// Fee configuration\r\npub const PLATFORM_FEE_BPS: u16 = 250; // 2.5%\r\n\r\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","vilink-protocol","src","errors.rs"],"content":"use anchor_lang::prelude::*;\r\n\r\n#[error_code]\r\npub enum ViLinkError {\r\n    #[msg(\"Unauthorized: Only the authority can perform this action\")]\r\n    Unauthorized,\r\n    #[msg(\"ViLink Protocol is paused\")]\r\n    ProtocolPaused,\r\n    #[msg(\"Action has expired\")]\r\n    ActionExpired,\r\n    #[msg(\"Action already executed\")]\r\n    ActionAlreadyExecuted,\r\n    #[msg(\"Invalid action type\")]\r\n    InvalidActionType,\r\n    #[msg(\"Invalid action amount\")]\r\n    InvalidAmount,\r\n    #[msg(\"Action creator cannot execute own action\")]\r\n    SelfExecutionNotAllowed,\r\n    #[msg(\"dApp not registered\")]\r\n    DAppNotRegistered,\r\n    #[msg(\"Batch size exceeds maximum\")]\r\n    BatchTooLarge,\r\n    #[msg(\"Action not found\")]\r\n    ActionNotFound,\r\n    #[msg(\"Insufficient balance\")]\r\n    InsufficientBalance,\r\n    #[msg(\"Action type disabled\")]\r\n    ActionTypeDisabled,\r\n    #[msg(\"Target user not valid\")]\r\n    InvalidTarget,\r\n    #[msg(\"Arithmetic overflow\")]\r\n    Overflow,\r\n    #[msg(\"Invalid token account owner\")]\r\n    InvalidTokenAccount,\r\n    #[msg(\"Invalid token mint\")]\r\n    InvalidMint,\r\n    #[msg(\"Invalid treasury account\")]\r\n    InvalidTreasury,\r\n}\r\n\r\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","vilink-protocol","src","events.rs"],"content":"use anchor_lang::prelude::*;\r\n\r\n#[event]\r\npub struct ViLinkConfigInitialized {\r\n    pub authority: Pubkey,\r\n    pub vcoin_mint: Pubkey,\r\n    pub enabled_actions: u8,\r\n}\r\n\r\n#[event]\r\npub struct ActionCreated {\r\n    pub action_id: [u8; 32],\r\n    pub creator: Pubkey,\r\n    pub target: Pubkey,\r\n    pub action_type: u8,\r\n    pub amount: u64,\r\n    pub expires_at: i64,\r\n}\r\n\r\n#[event]\r\npub struct ActionExecuted {\r\n    pub action_id: [u8; 32],\r\n    pub executor: Pubkey,\r\n    pub target: Pubkey,\r\n    pub action_type: u8,\r\n    pub amount: u64,\r\n    pub fee_paid: u64,\r\n}\r\n\r\n#[event]\r\npub struct DAppRegistered {\r\n    pub dapp_id: [u8; 32],\r\n    pub authority: Pubkey,\r\n    pub allowed_actions: u8,\r\n}\r\n\r\n#[event]\r\npub struct BatchCreated {\r\n    pub batch_id: [u8; 32],\r\n    pub creator: Pubkey,\r\n    pub action_count: u8,\r\n}\r\n\r\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","vilink-protocol","src","lib.rs"],"content":"use anchor_lang::prelude::*;\r\nuse anchor_spl::token_2022::{self, Token2022};\r\nuse anchor_spl::token_interface::{Mint, TokenAccount};\r\n\r\ndeclare_id!(\"CFGXTS2MueQwTYTMMTBQbRWzJtSTC2p4ZRuKPpLDmrv7\");\r\n\r\n/// ViLink Protocol - Cross-dApp Action Deep Links\r\n/// \r\n/// One-tap social actions with shareable URLs.\r\n/// \r\n/// Key Features:\r\n/// - Shareable action links (viwo://action/xxx)\r\n/// - Cross-dApp integration\r\n/// - Gasless execution via session keys\r\n/// - Action types: Tip, Vouch, Follow, Challenge, Stake\r\n/// \r\n/// URI Format:\r\n/// viwo://action/{action_id}?amount=X\u0026target=Y\r\n/// \r\n/// Flow:\r\n/// 1. Creator generates action link\r\n/// 2. User clicks link → app opens\r\n/// 3. Session key executes action (gasless)\r\n/// 4. User notified of result\r\n\r\npub mod constants;\r\npub mod errors;\r\npub mod events;\r\npub mod state;\r\n\r\n#[cfg(test)]\r\nmod tests;\r\n\r\nuse constants::*;\r\nuse errors::*;\r\nuse state::*;\r\nuse events::*;\r\n\r\n#[program]\r\npub mod vilink_protocol {\r\n    use super::*;\r\n\r\n    /// Initialize ViLink configuration\r\n    pub fn initialize(ctx: Context\u003cInitialize\u003e, treasury: Pubkey) -\u003e Result\u003c()\u003e {\r\n        let config = \u0026mut ctx.accounts.config;\r\n        \r\n        config.authority = ctx.accounts.authority.key();\r\n        config.vcoin_mint = ctx.accounts.vcoin_mint.key();\r\n        config.treasury = treasury;\r\n        config.five_a_program = Pubkey::default();\r\n        config.staking_program = Pubkey::default();\r\n        config.content_registry = Pubkey::default();\r\n        config.governance_program = Pubkey::default();\r\n        config.gasless_program = Pubkey::default();\r\n        config.enabled_actions = 0xFF;\r\n        config.total_actions_created = 0;\r\n        config.total_actions_executed = 0;\r\n        config.total_tip_volume = 0;\r\n        config.paused = false;\r\n        config.platform_fee_bps = PLATFORM_FEE_BPS;\r\n        config.bump = ctx.bumps.config;\r\n        \r\n        emit!(ViLinkConfigInitialized {\r\n            authority: config.authority,\r\n            vcoin_mint: config.vcoin_mint,\r\n            enabled_actions: config.enabled_actions,\r\n        });\r\n        \r\n        msg!(\"ViLink Protocol initialized\");\r\n        Ok(())\r\n    }\r\n    \r\n    /// Create a new action link\r\n    pub fn create_action(\r\n        ctx: Context\u003cCreateAction\u003e,\r\n        action_type: u8,\r\n        amount: u64,\r\n        target: Pubkey,\r\n        metadata_hash: [u8; 32],\r\n        expiry_seconds: i64,\r\n        one_time: bool,\r\n        max_executions: u32,\r\n        content_id: Option\u003c[u8; 32]\u003e,\r\n    ) -\u003e Result\u003c()\u003e {\r\n        let config = \u0026mut ctx.accounts.config;\r\n        let action = \u0026mut ctx.accounts.action;\r\n        let user_stats = \u0026mut ctx.accounts.user_stats;\r\n        \r\n        require!(!config.paused, ViLinkError::ProtocolPaused);\r\n        require!(action_type \u003c 8, ViLinkError::InvalidActionType);\r\n        require!(config.is_action_enabled(action_type), ViLinkError::ActionTypeDisabled);\r\n        \r\n        if action_type == ACTION_TIP {\r\n            require!(amount \u003e= MIN_TIP_AMOUNT, ViLinkError::InvalidAmount);\r\n            require!(amount \u003c= MAX_TIP_AMOUNT, ViLinkError::InvalidAmount);\r\n        }\r\n        \r\n        let expiry = if expiry_seconds \u003e 0 \u0026\u0026 expiry_seconds \u003c= MAX_ACTION_EXPIRY {\r\n            expiry_seconds\r\n        } else {\r\n            MAX_ACTION_EXPIRY\r\n        };\r\n        \r\n        let clock = Clock::get()?;\r\n        \r\n        let action_id = generate_action_id(\r\n            \u0026ctx.accounts.creator.key(),\r\n            \u0026target,\r\n            action_type,\r\n            amount,\r\n            clock.unix_timestamp,\r\n        );\r\n        \r\n        action.action_id = action_id;\r\n        action.creator = ctx.accounts.creator.key();\r\n        action.target = target;\r\n        action.action_type = action_type;\r\n        action.amount = amount;\r\n        action.metadata_hash = metadata_hash;\r\n        action.created_at = clock.unix_timestamp;\r\n        action.expires_at = clock.unix_timestamp + expiry;\r\n        action.executed = false;\r\n        action.executor = Pubkey::default();\r\n        action.executed_at = 0;\r\n        action.content_id = content_id;\r\n        action.source_dapp = Pubkey::default();\r\n        action.one_time = one_time;\r\n        action.execution_count = 0;\r\n        action.max_executions = max_executions;\r\n        action.bump = ctx.bumps.action;\r\n        \r\n        config.total_actions_created = config.total_actions_created.saturating_add(1);\r\n        \r\n        user_stats.user = ctx.accounts.creator.key();\r\n        user_stats.actions_created = user_stats.actions_created.saturating_add(1);\r\n        if user_stats.first_action_at == 0 {\r\n            user_stats.first_action_at = clock.unix_timestamp;\r\n        }\r\n        user_stats.last_action_at = clock.unix_timestamp;\r\n        user_stats.bump = ctx.bumps.user_stats;\r\n        \r\n        emit!(ActionCreated {\r\n            action_id,\r\n            creator: action.creator,\r\n            target,\r\n            action_type,\r\n            amount,\r\n            expires_at: action.expires_at,\r\n        });\r\n        \r\n        msg!(\"Action created: type={}, target={}\", action_type_name(action_type), target);\r\n        Ok(())\r\n    }\r\n    \r\n    /// Execute an action (tip execution with VCoin transfer)\r\n    pub fn execute_tip_action(ctx: Context\u003cExecuteTipAction\u003e) -\u003e Result\u003c()\u003e {\r\n        let config = \u0026mut ctx.accounts.config;\r\n        let action = \u0026mut ctx.accounts.action;\r\n        let executor_stats = \u0026mut ctx.accounts.executor_stats;\r\n        let target_stats = \u0026mut ctx.accounts.target_stats;\r\n        \r\n        require!(!config.paused, ViLinkError::ProtocolPaused);\r\n        \r\n        require!(ctx.accounts.executor_token_account.owner == ctx.accounts.executor.key(), ViLinkError::InvalidTokenAccount);\r\n        require!(ctx.accounts.executor_token_account.mint == config.vcoin_mint, ViLinkError::InvalidMint);\r\n        require!(ctx.accounts.target_token_account.owner == action.target, ViLinkError::InvalidTarget);\r\n        require!(ctx.accounts.target_token_account.mint == config.vcoin_mint, ViLinkError::InvalidMint);\r\n        require!(ctx.accounts.treasury_token_account.owner == config.treasury, ViLinkError::InvalidTreasury);\r\n        require!(ctx.accounts.treasury_token_account.mint == config.vcoin_mint, ViLinkError::InvalidMint);\r\n        \r\n        let clock = Clock::get()?;\r\n        \r\n        require!(!action.executed || !action.one_time, ViLinkError::ActionAlreadyExecuted);\r\n        require!(clock.unix_timestamp \u003c= action.expires_at, ViLinkError::ActionExpired);\r\n        require!(action.action_type == ACTION_TIP, ViLinkError::InvalidActionType);\r\n        \r\n        if action.max_executions \u003e 0 {\r\n            require!(action.execution_count \u003c action.max_executions, ViLinkError::ActionAlreadyExecuted);\r\n        }\r\n        \r\n        let executor_key = ctx.accounts.executor.key();\r\n        require!(executor_key != action.creator, ViLinkError::SelfExecutionNotAllowed);\r\n        \r\n        let fee = (action.amount as u128 * config.platform_fee_bps as u128 / 10000) as u64;\r\n        let net_amount = action.amount.saturating_sub(fee);\r\n        \r\n        token_2022::transfer_checked(\r\n            CpiContext::new(ctx.accounts.token_program.to_account_info(),\r\n                token_2022::TransferChecked {\r\n                    from: ctx.accounts.executor_token_account.to_account_info(),\r\n                    to: ctx.accounts.target_token_account.to_account_info(),\r\n                    authority: ctx.accounts.executor.to_account_info(),\r\n                    mint: ctx.accounts.vcoin_mint.to_account_info(),\r\n                },\r\n            ),\r\n            net_amount,\r\n            ctx.accounts.vcoin_mint.decimals,\r\n        )?;\r\n        \r\n        if fee \u003e 0 {\r\n            token_2022::transfer_checked(\r\n                CpiContext::new(ctx.accounts.token_program.to_account_info(),\r\n                    token_2022::TransferChecked {\r\n                        from: ctx.accounts.executor_token_account.to_account_info(),\r\n                        to: ctx.accounts.treasury_token_account.to_account_info(),\r\n                        authority: ctx.accounts.executor.to_account_info(),\r\n                        mint: ctx.accounts.vcoin_mint.to_account_info(),\r\n                    },\r\n                ),\r\n                fee,\r\n                ctx.accounts.vcoin_mint.decimals,\r\n            )?;\r\n        }\r\n        \r\n        action.execution_count = action.execution_count.saturating_add(1);\r\n        if action.one_time {\r\n            action.executed = true;\r\n        }\r\n        action.executor = executor_key;\r\n        action.executed_at = clock.unix_timestamp;\r\n        \r\n        config.total_actions_executed = config.total_actions_executed.saturating_add(1);\r\n        config.total_tip_volume = config.total_tip_volume.saturating_add(action.amount);\r\n        \r\n        executor_stats.user = executor_key;\r\n        executor_stats.actions_executed = executor_stats.actions_executed.saturating_add(1);\r\n        executor_stats.tips_sent = executor_stats.tips_sent.saturating_add(1);\r\n        executor_stats.vcoin_sent = executor_stats.vcoin_sent.saturating_add(action.amount);\r\n        executor_stats.last_action_at = clock.unix_timestamp;\r\n        executor_stats.bump = ctx.bumps.executor_stats;\r\n        \r\n        target_stats.user = action.target;\r\n        target_stats.tips_received = target_stats.tips_received.saturating_add(1);\r\n        target_stats.vcoin_received = target_stats.vcoin_received.saturating_add(net_amount);\r\n        target_stats.bump = ctx.bumps.target_stats;\r\n        \r\n        emit!(ActionExecuted {\r\n            action_id: action.action_id,\r\n            executor: executor_key,\r\n            target: action.target,\r\n            action_type: action.action_type,\r\n            amount: action.amount,\r\n            fee_paid: fee,\r\n        });\r\n        \r\n        msg!(\"Tip action executed: {} VCoin to {}\", action.amount, action.target);\r\n        Ok(())\r\n    }\r\n    \r\n    /// Execute a vouch action\r\n    pub fn execute_vouch_action(ctx: Context\u003cExecuteGenericAction\u003e) -\u003e Result\u003c()\u003e {\r\n        let config = \u0026mut ctx.accounts.config;\r\n        let action = \u0026mut ctx.accounts.action;\r\n        let executor_stats = \u0026mut ctx.accounts.executor_stats;\r\n        \r\n        require!(!config.paused, ViLinkError::ProtocolPaused);\r\n        require!(action.action_type == ACTION_VOUCH, ViLinkError::InvalidActionType);\r\n        \r\n        let clock = Clock::get()?;\r\n        \r\n        require!(!action.executed || !action.one_time, ViLinkError::ActionAlreadyExecuted);\r\n        require!(clock.unix_timestamp \u003c= action.expires_at, ViLinkError::ActionExpired);\r\n        \r\n        let executor_key = ctx.accounts.executor.key();\r\n        require!(executor_key != action.creator, ViLinkError::SelfExecutionNotAllowed);\r\n        \r\n        action.execution_count = action.execution_count.saturating_add(1);\r\n        if action.one_time {\r\n            action.executed = true;\r\n        }\r\n        action.executor = executor_key;\r\n        action.executed_at = clock.unix_timestamp;\r\n        \r\n        config.total_actions_executed = config.total_actions_executed.saturating_add(1);\r\n        \r\n        executor_stats.user = executor_key;\r\n        executor_stats.actions_executed = executor_stats.actions_executed.saturating_add(1);\r\n        executor_stats.vouches_given = executor_stats.vouches_given.saturating_add(1);\r\n        executor_stats.last_action_at = clock.unix_timestamp;\r\n        executor_stats.bump = ctx.bumps.executor_stats;\r\n        \r\n        emit!(ActionExecuted {\r\n            action_id: action.action_id,\r\n            executor: executor_key,\r\n            target: action.target,\r\n            action_type: action.action_type,\r\n            amount: 0,\r\n            fee_paid: 0,\r\n        });\r\n        \r\n        msg!(\"Vouch action executed for {}\", action.target);\r\n        Ok(())\r\n    }\r\n    \r\n    /// Execute a follow action\r\n    pub fn execute_follow_action(ctx: Context\u003cExecuteGenericAction\u003e) -\u003e Result\u003c()\u003e {\r\n        let config = \u0026mut ctx.accounts.config;\r\n        let action = \u0026mut ctx.accounts.action;\r\n        let executor_stats = \u0026mut ctx.accounts.executor_stats;\r\n        \r\n        require!(!config.paused, ViLinkError::ProtocolPaused);\r\n        require!(action.action_type == ACTION_FOLLOW, ViLinkError::InvalidActionType);\r\n        \r\n        let clock = Clock::get()?;\r\n        \r\n        require!(!action.executed || !action.one_time, ViLinkError::ActionAlreadyExecuted);\r\n        require!(clock.unix_timestamp \u003c= action.expires_at, ViLinkError::ActionExpired);\r\n        \r\n        let executor_key = ctx.accounts.executor.key();\r\n        require!(executor_key != action.creator, ViLinkError::SelfExecutionNotAllowed);\r\n        \r\n        action.execution_count = action.execution_count.saturating_add(1);\r\n        if action.one_time {\r\n            action.executed = true;\r\n        }\r\n        action.executor = executor_key;\r\n        action.executed_at = clock.unix_timestamp;\r\n        \r\n        config.total_actions_executed = config.total_actions_executed.saturating_add(1);\r\n        \r\n        executor_stats.user = executor_key;\r\n        executor_stats.actions_executed = executor_stats.actions_executed.saturating_add(1);\r\n        executor_stats.follows_given = executor_stats.follows_given.saturating_add(1);\r\n        executor_stats.last_action_at = clock.unix_timestamp;\r\n        executor_stats.bump = ctx.bumps.executor_stats;\r\n        \r\n        emit!(ActionExecuted {\r\n            action_id: action.action_id,\r\n            executor: executor_key,\r\n            target: action.target,\r\n            action_type: action.action_type,\r\n            amount: 0,\r\n            fee_paid: 0,\r\n        });\r\n        \r\n        msg!(\"Follow action executed for {}\", action.target);\r\n        Ok(())\r\n    }\r\n    \r\n    /// Register an external dApp\r\n    pub fn register_dapp(\r\n        ctx: Context\u003cRegisterDApp\u003e,\r\n        name: [u8; 32],\r\n        webhook_hash: [u8; 32],\r\n        allowed_actions: u8,\r\n        fee_share_bps: u16,\r\n    ) -\u003e Result\u003c()\u003e {\r\n        let config = \u0026ctx.accounts.config;\r\n        let dapp = \u0026mut ctx.accounts.dapp;\r\n        \r\n        require!(!config.paused, ViLinkError::ProtocolPaused);\r\n        \r\n        let clock = Clock::get()?;\r\n        \r\n        let dapp_id = generate_dapp_id(\u0026ctx.accounts.dapp_authority.key());\r\n        \r\n        dapp.dapp_id = dapp_id;\r\n        dapp.name = name;\r\n        dapp.authority = ctx.accounts.dapp_authority.key();\r\n        dapp.webhook_hash = webhook_hash;\r\n        dapp.is_active = true;\r\n        dapp.registered_at = clock.unix_timestamp;\r\n        dapp.action_count = 0;\r\n        dapp.allowed_actions = allowed_actions;\r\n        dapp.fee_share_bps = fee_share_bps;\r\n        dapp.bump = ctx.bumps.dapp;\r\n        \r\n        emit!(DAppRegistered {\r\n            dapp_id,\r\n            authority: dapp.authority,\r\n            allowed_actions,\r\n        });\r\n        \r\n        msg!(\"dApp registered: {:?}\", name);\r\n        Ok(())\r\n    }\r\n    \r\n    /// Create a batch of actions\r\n    pub fn create_batch(ctx: Context\u003cCreateBatch\u003e, action_ids: Vec\u003c[u8; 32]\u003e) -\u003e Result\u003c()\u003e {\r\n        let config = \u0026ctx.accounts.config;\r\n        let batch = \u0026mut ctx.accounts.batch;\r\n        \r\n        require!(!config.paused, ViLinkError::ProtocolPaused);\r\n        require!(action_ids.len() \u003c= MAX_ACTIONS_PER_BATCH, ViLinkError::BatchTooLarge);\r\n        \r\n        let clock = Clock::get()?;\r\n        \r\n        let batch_id = generate_batch_id(\u0026ctx.accounts.creator.key(), clock.unix_timestamp);\r\n        \r\n        batch.batch_id = batch_id;\r\n        batch.creator = ctx.accounts.creator.key();\r\n        batch.action_ids = action_ids.clone();\r\n        batch.created_at = clock.unix_timestamp;\r\n        batch.total_actions = action_ids.len() as u8;\r\n        batch.executed_count = 0;\r\n        batch.bump = ctx.bumps.batch;\r\n        \r\n        emit!(BatchCreated {\r\n            batch_id,\r\n            creator: batch.creator,\r\n            action_count: batch.total_actions,\r\n        });\r\n        \r\n        msg!(\"Batch created with {} actions\", action_ids.len());\r\n        Ok(())\r\n    }\r\n    \r\n    /// Update protocol programs\r\n    pub fn update_programs(\r\n        ctx: Context\u003cUpdateConfig\u003e,\r\n        five_a_program: Pubkey,\r\n        staking_program: Pubkey,\r\n        content_registry: Pubkey,\r\n        governance_program: Pubkey,\r\n        gasless_program: Pubkey,\r\n    ) -\u003e Result\u003c()\u003e {\r\n        let config = \u0026mut ctx.accounts.config;\r\n        \r\n        config.five_a_program = five_a_program;\r\n        config.staking_program = staking_program;\r\n        config.content_registry = content_registry;\r\n        config.governance_program = governance_program;\r\n        config.gasless_program = gasless_program;\r\n        \r\n        msg!(\"Protocol programs updated\");\r\n        Ok(())\r\n    }\r\n    \r\n    /// Enable/disable action types\r\n    pub fn set_enabled_actions(ctx: Context\u003cUpdateConfig\u003e, enabled_actions: u8) -\u003e Result\u003c()\u003e {\r\n        ctx.accounts.config.enabled_actions = enabled_actions;\r\n        msg!(\"Enabled actions updated: {:#010b}\", enabled_actions);\r\n        Ok(())\r\n    }\r\n    \r\n    /// Update platform fee\r\n    pub fn set_platform_fee(ctx: Context\u003cUpdateConfig\u003e, fee_bps: u16) -\u003e Result\u003c()\u003e {\r\n        ctx.accounts.config.platform_fee_bps = fee_bps;\r\n        msg!(\"Platform fee updated to {} bps\", fee_bps);\r\n        Ok(())\r\n    }\r\n    \r\n    /// Pause/unpause protocol\r\n    pub fn set_paused(ctx: Context\u003cUpdateConfig\u003e, paused: bool) -\u003e Result\u003c()\u003e {\r\n        ctx.accounts.config.paused = paused;\r\n        msg!(\"ViLink Protocol paused: {}\", paused);\r\n        Ok(())\r\n    }\r\n    \r\n    /// Update authority\r\n    pub fn update_authority(ctx: Context\u003cUpdateAuthority\u003e, new_authority: Pubkey) -\u003e Result\u003c()\u003e {\r\n        ctx.accounts.config.authority = new_authority;\r\n        msg!(\"Authority updated to: {}\", new_authority);\r\n        Ok(())\r\n    }\r\n    \r\n    /// Get action details\r\n    pub fn get_action(ctx: Context\u003cGetAction\u003e) -\u003e Result\u003c()\u003e {\r\n        let action = \u0026ctx.accounts.action;\r\n        msg!(\"Action ID: {:?}\", action.action_id);\r\n        msg!(\"Type: {}\", action_type_name(action.action_type));\r\n        msg!(\"Creator: {}\", action.creator);\r\n        msg!(\"Target: {}\", action.target);\r\n        msg!(\"Amount: {}\", action.amount);\r\n        msg!(\"Executed: {}\", action.executed);\r\n        msg!(\"Executions: {}/{}\", action.execution_count, action.max_executions);\r\n        Ok(())\r\n    }\r\n    \r\n    /// Get user stats\r\n    pub fn get_user_stats(ctx: Context\u003cGetUserStats\u003e) -\u003e Result\u003c()\u003e {\r\n        let stats = \u0026ctx.accounts.user_stats;\r\n        msg!(\"User: {}\", stats.user);\r\n        msg!(\"Actions created: {}\", stats.actions_created);\r\n        msg!(\"Actions executed: {}\", stats.actions_executed);\r\n        msg!(\"Tips sent: {}, VCoin: {}\", stats.tips_sent, stats.vcoin_sent);\r\n        msg!(\"Tips received: {}, VCoin: {}\", stats.tips_received, stats.vcoin_received);\r\n        Ok(())\r\n    }\r\n}\r\n\r\n// Account contexts\r\n\r\n#[derive(Accounts)]\r\npub struct Initialize\u003c'info\u003e {\r\n    #[account(init, payer = authority, space = ViLinkConfig::LEN, seeds = [CONFIG_SEED], bump)]\r\n    pub config: Account\u003c'info, ViLinkConfig\u003e,\r\n    pub vcoin_mint: InterfaceAccount\u003c'info, Mint\u003e,\r\n    #[account(mut)]\r\n    pub authority: Signer\u003c'info\u003e,\r\n    pub system_program: Program\u003c'info, System\u003e,\r\n}\r\n\r\n#[derive(Accounts)]\r\npub struct CreateAction\u003c'info\u003e {\r\n    #[account(mut, seeds = [CONFIG_SEED], bump = config.bump)]\r\n    pub config: Account\u003c'info, ViLinkConfig\u003e,\r\n    #[account(init, payer = creator, space = ViLinkAction::LEN, seeds = [ACTION_SEED, creator.key().as_ref(), \u0026Clock::get()?.unix_timestamp.to_le_bytes()], bump)]\r\n    pub action: Account\u003c'info, ViLinkAction\u003e,\r\n    #[account(init_if_needed, payer = creator, space = UserActionStats::LEN, seeds = [USER_STATS_SEED, creator.key().as_ref()], bump)]\r\n    pub user_stats: Account\u003c'info, UserActionStats\u003e,\r\n    #[account(mut)]\r\n    pub creator: Signer\u003c'info\u003e,\r\n    pub system_program: Program\u003c'info, System\u003e,\r\n}\r\n\r\n#[derive(Accounts)]\r\npub struct ExecuteTipAction\u003c'info\u003e {\r\n    #[account(mut, seeds = [CONFIG_SEED], bump = config.bump)]\r\n    pub config: Account\u003c'info, ViLinkConfig\u003e,\r\n    #[account(mut, seeds = [ACTION_SEED, action.creator.as_ref(), \u0026action.created_at.to_le_bytes()], bump = action.bump)]\r\n    pub action: Account\u003c'info, ViLinkAction\u003e,\r\n    #[account(init_if_needed, payer = executor, space = UserActionStats::LEN, seeds = [USER_STATS_SEED, executor.key().as_ref()], bump)]\r\n    pub executor_stats: Account\u003c'info, UserActionStats\u003e,\r\n    #[account(init_if_needed, payer = executor, space = UserActionStats::LEN, seeds = [USER_STATS_SEED, action.target.as_ref()], bump)]\r\n    pub target_stats: Account\u003c'info, UserActionStats\u003e,\r\n    #[account(constraint = vcoin_mint.key() == config.vcoin_mint @ ViLinkError::InvalidMint)]\r\n    pub vcoin_mint: InterfaceAccount\u003c'info, Mint\u003e,\r\n    #[account(mut)]\r\n    pub executor_token_account: InterfaceAccount\u003c'info, TokenAccount\u003e,\r\n    #[account(mut)]\r\n    pub target_token_account: InterfaceAccount\u003c'info, TokenAccount\u003e,\r\n    #[account(mut)]\r\n    pub treasury_token_account: InterfaceAccount\u003c'info, TokenAccount\u003e,\r\n    #[account(mut)]\r\n    pub executor: Signer\u003c'info\u003e,\r\n    pub token_program: Program\u003c'info, Token2022\u003e,\r\n    pub system_program: Program\u003c'info, System\u003e,\r\n}\r\n\r\n#[derive(Accounts)]\r\npub struct ExecuteGenericAction\u003c'info\u003e {\r\n    #[account(mut, seeds = [CONFIG_SEED], bump = config.bump)]\r\n    pub config: Account\u003c'info, ViLinkConfig\u003e,\r\n    #[account(mut, seeds = [ACTION_SEED, action.creator.as_ref(), \u0026action.created_at.to_le_bytes()], bump = action.bump)]\r\n    pub action: Account\u003c'info, ViLinkAction\u003e,\r\n    #[account(init_if_needed, payer = executor, space = UserActionStats::LEN, seeds = [USER_STATS_SEED, executor.key().as_ref()], bump)]\r\n    pub executor_stats: Account\u003c'info, UserActionStats\u003e,\r\n    #[account(mut)]\r\n    pub executor: Signer\u003c'info\u003e,\r\n    pub system_program: Program\u003c'info, System\u003e,\r\n}\r\n\r\n#[derive(Accounts)]\r\npub struct RegisterDApp\u003c'info\u003e {\r\n    #[account(seeds = [CONFIG_SEED], bump = config.bump, has_one = authority @ ViLinkError::Unauthorized)]\r\n    pub config: Account\u003c'info, ViLinkConfig\u003e,\r\n    #[account(init, payer = authority, space = RegisteredDApp::LEN, seeds = [DAPP_REGISTRY_SEED, dapp_authority.key().as_ref()], bump)]\r\n    pub dapp: Account\u003c'info, RegisteredDApp\u003e,\r\n    /// CHECK: dApp authority being registered\r\n    pub dapp_authority: AccountInfo\u003c'info\u003e,\r\n    #[account(mut)]\r\n    pub authority: Signer\u003c'info\u003e,\r\n    pub system_program: Program\u003c'info, System\u003e,\r\n}\r\n\r\n#[derive(Accounts)]\r\npub struct CreateBatch\u003c'info\u003e {\r\n    #[account(seeds = [CONFIG_SEED], bump = config.bump)]\r\n    pub config: Account\u003c'info, ViLinkConfig\u003e,\r\n    #[account(init, payer = creator, space = ActionBatch::LEN, seeds = [BATCH_SEED, creator.key().as_ref(), \u0026Clock::get()?.unix_timestamp.to_le_bytes()], bump)]\r\n    pub batch: Account\u003c'info, ActionBatch\u003e,\r\n    #[account(mut)]\r\n    pub creator: Signer\u003c'info\u003e,\r\n    pub system_program: Program\u003c'info, System\u003e,\r\n}\r\n\r\n#[derive(Accounts)]\r\npub struct UpdateConfig\u003c'info\u003e {\r\n    #[account(mut, seeds = [CONFIG_SEED], bump = config.bump, has_one = authority @ ViLinkError::Unauthorized)]\r\n    pub config: Account\u003c'info, ViLinkConfig\u003e,\r\n    pub authority: Signer\u003c'info\u003e,\r\n}\r\n\r\n#[derive(Accounts)]\r\npub struct UpdateAuthority\u003c'info\u003e {\r\n    #[account(mut, seeds = [CONFIG_SEED], bump = config.bump, has_one = authority @ ViLinkError::Unauthorized)]\r\n    pub config: Account\u003c'info, ViLinkConfig\u003e,\r\n    pub authority: Signer\u003c'info\u003e,\r\n}\r\n\r\n#[derive(Accounts)]\r\npub struct GetAction\u003c'info\u003e {\r\n    #[account(seeds = [ACTION_SEED, action.creator.as_ref(), \u0026action.created_at.to_le_bytes()], bump = action.bump)]\r\n    pub action: Account\u003c'info, ViLinkAction\u003e,\r\n}\r\n\r\n#[derive(Accounts)]\r\npub struct GetUserStats\u003c'info\u003e {\r\n    #[account(seeds = [USER_STATS_SEED, user_stats.user.as_ref()], bump = user_stats.bump)]\r\n    pub user_stats: Account\u003c'info, UserActionStats\u003e,\r\n}\r\n","traces":[{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":98,"address":[],"length":0,"stats":{"Line":0}},{"line":99,"address":[],"length":0,"stats":{"Line":0}},{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":0}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":0}},{"line":118,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":0}},{"line":122,"address":[],"length":0,"stats":{"Line":0}},{"line":123,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":125,"address":[],"length":0,"stats":{"Line":0}},{"line":126,"address":[],"length":0,"stats":{"Line":0}},{"line":127,"address":[],"length":0,"stats":{"Line":0}},{"line":128,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":130,"address":[],"length":0,"stats":{"Line":0}},{"line":132,"address":[],"length":0,"stats":{"Line":0}},{"line":134,"address":[],"length":0,"stats":{"Line":0}},{"line":135,"address":[],"length":0,"stats":{"Line":0}},{"line":136,"address":[],"length":0,"stats":{"Line":0}},{"line":137,"address":[],"length":0,"stats":{"Line":0}},{"line":139,"address":[],"length":0,"stats":{"Line":0}},{"line":140,"address":[],"length":0,"stats":{"Line":0}},{"line":142,"address":[],"length":0,"stats":{"Line":0}},{"line":143,"address":[],"length":0,"stats":{"Line":0}},{"line":144,"address":[],"length":0,"stats":{"Line":0}},{"line":145,"address":[],"length":0,"stats":{"Line":0}},{"line":146,"address":[],"length":0,"stats":{"Line":0}},{"line":147,"address":[],"length":0,"stats":{"Line":0}},{"line":148,"address":[],"length":0,"stats":{"Line":0}},{"line":151,"address":[],"length":0,"stats":{"Line":0}},{"line":152,"address":[],"length":0,"stats":{"Line":0}},{"line":156,"address":[],"length":0,"stats":{"Line":0}},{"line":157,"address":[],"length":0,"stats":{"Line":0}},{"line":158,"address":[],"length":0,"stats":{"Line":0}},{"line":159,"address":[],"length":0,"stats":{"Line":0}},{"line":160,"address":[],"length":0,"stats":{"Line":0}},{"line":162,"address":[],"length":0,"stats":{"Line":0}},{"line":164,"address":[],"length":0,"stats":{"Line":0}},{"line":165,"address":[],"length":0,"stats":{"Line":0}},{"line":166,"address":[],"length":0,"stats":{"Line":0}},{"line":167,"address":[],"length":0,"stats":{"Line":0}},{"line":168,"address":[],"length":0,"stats":{"Line":0}},{"line":169,"address":[],"length":0,"stats":{"Line":0}},{"line":171,"address":[],"length":0,"stats":{"Line":0}},{"line":173,"address":[],"length":0,"stats":{"Line":0}},{"line":174,"address":[],"length":0,"stats":{"Line":0}},{"line":175,"address":[],"length":0,"stats":{"Line":0}},{"line":177,"address":[],"length":0,"stats":{"Line":0}},{"line":178,"address":[],"length":0,"stats":{"Line":0}},{"line":181,"address":[],"length":0,"stats":{"Line":0}},{"line":182,"address":[],"length":0,"stats":{"Line":0}},{"line":184,"address":[],"length":0,"stats":{"Line":0}},{"line":185,"address":[],"length":0,"stats":{"Line":0}},{"line":188,"address":[],"length":0,"stats":{"Line":0}},{"line":189,"address":[],"length":0,"stats":{"Line":0}},{"line":190,"address":[],"length":0,"stats":{"Line":0}},{"line":191,"address":[],"length":0,"stats":{"Line":0}},{"line":192,"address":[],"length":0,"stats":{"Line":0}},{"line":193,"address":[],"length":0,"stats":{"Line":0}},{"line":196,"address":[],"length":0,"stats":{"Line":0}},{"line":197,"address":[],"length":0,"stats":{"Line":0}},{"line":200,"address":[],"length":0,"stats":{"Line":0}},{"line":202,"address":[],"length":0,"stats":{"Line":0}},{"line":203,"address":[],"length":0,"stats":{"Line":0}},{"line":204,"address":[],"length":0,"stats":{"Line":0}},{"line":205,"address":[],"length":0,"stats":{"Line":0}},{"line":206,"address":[],"length":0,"stats":{"Line":0}},{"line":207,"address":[],"length":0,"stats":{"Line":0}},{"line":210,"address":[],"length":0,"stats":{"Line":0}},{"line":211,"address":[],"length":0,"stats":{"Line":0}},{"line":215,"address":[],"length":0,"stats":{"Line":0}},{"line":216,"address":[],"length":0,"stats":{"Line":0}},{"line":217,"address":[],"length":0,"stats":{"Line":0}},{"line":219,"address":[],"length":0,"stats":{"Line":0}},{"line":220,"address":[],"length":0,"stats":{"Line":0}},{"line":222,"address":[],"length":0,"stats":{"Line":0}},{"line":223,"address":[],"length":0,"stats":{"Line":0}},{"line":225,"address":[],"length":0,"stats":{"Line":0}},{"line":226,"address":[],"length":0,"stats":{"Line":0}},{"line":227,"address":[],"length":0,"stats":{"Line":0}},{"line":228,"address":[],"length":0,"stats":{"Line":0}},{"line":229,"address":[],"length":0,"stats":{"Line":0}},{"line":230,"address":[],"length":0,"stats":{"Line":0}},{"line":232,"address":[],"length":0,"stats":{"Line":0}},{"line":233,"address":[],"length":0,"stats":{"Line":0}},{"line":234,"address":[],"length":0,"stats":{"Line":0}},{"line":235,"address":[],"length":0,"stats":{"Line":0}},{"line":237,"address":[],"length":0,"stats":{"Line":0}},{"line":238,"address":[],"length":0,"stats":{"Line":0}},{"line":239,"address":[],"length":0,"stats":{"Line":0}},{"line":240,"address":[],"length":0,"stats":{"Line":0}},{"line":241,"address":[],"length":0,"stats":{"Line":0}},{"line":242,"address":[],"length":0,"stats":{"Line":0}},{"line":243,"address":[],"length":0,"stats":{"Line":0}},{"line":246,"address":[],"length":0,"stats":{"Line":0}},{"line":247,"address":[],"length":0,"stats":{"Line":0}},{"line":251,"address":[],"length":0,"stats":{"Line":0}},{"line":252,"address":[],"length":0,"stats":{"Line":0}},{"line":253,"address":[],"length":0,"stats":{"Line":0}},{"line":254,"address":[],"length":0,"stats":{"Line":0}},{"line":256,"address":[],"length":0,"stats":{"Line":0}},{"line":257,"address":[],"length":0,"stats":{"Line":0}},{"line":259,"address":[],"length":0,"stats":{"Line":0}},{"line":261,"address":[],"length":0,"stats":{"Line":0}},{"line":262,"address":[],"length":0,"stats":{"Line":0}},{"line":264,"address":[],"length":0,"stats":{"Line":0}},{"line":265,"address":[],"length":0,"stats":{"Line":0}},{"line":267,"address":[],"length":0,"stats":{"Line":0}},{"line":268,"address":[],"length":0,"stats":{"Line":0}},{"line":269,"address":[],"length":0,"stats":{"Line":0}},{"line":271,"address":[],"length":0,"stats":{"Line":0}},{"line":272,"address":[],"length":0,"stats":{"Line":0}},{"line":274,"address":[],"length":0,"stats":{"Line":0}},{"line":276,"address":[],"length":0,"stats":{"Line":0}},{"line":277,"address":[],"length":0,"stats":{"Line":0}},{"line":278,"address":[],"length":0,"stats":{"Line":0}},{"line":279,"address":[],"length":0,"stats":{"Line":0}},{"line":280,"address":[],"length":0,"stats":{"Line":0}},{"line":282,"address":[],"length":0,"stats":{"Line":0}},{"line":283,"address":[],"length":0,"stats":{"Line":0}},{"line":284,"address":[],"length":0,"stats":{"Line":0}},{"line":285,"address":[],"length":0,"stats":{"Line":0}},{"line":286,"address":[],"length":0,"stats":{"Line":0}},{"line":287,"address":[],"length":0,"stats":{"Line":0}},{"line":288,"address":[],"length":0,"stats":{"Line":0}},{"line":291,"address":[],"length":0,"stats":{"Line":0}},{"line":292,"address":[],"length":0,"stats":{"Line":0}},{"line":296,"address":[],"length":0,"stats":{"Line":0}},{"line":297,"address":[],"length":0,"stats":{"Line":0}},{"line":298,"address":[],"length":0,"stats":{"Line":0}},{"line":299,"address":[],"length":0,"stats":{"Line":0}},{"line":301,"address":[],"length":0,"stats":{"Line":0}},{"line":302,"address":[],"length":0,"stats":{"Line":0}},{"line":304,"address":[],"length":0,"stats":{"Line":0}},{"line":306,"address":[],"length":0,"stats":{"Line":0}},{"line":307,"address":[],"length":0,"stats":{"Line":0}},{"line":309,"address":[],"length":0,"stats":{"Line":0}},{"line":310,"address":[],"length":0,"stats":{"Line":0}},{"line":312,"address":[],"length":0,"stats":{"Line":0}},{"line":313,"address":[],"length":0,"stats":{"Line":0}},{"line":314,"address":[],"length":0,"stats":{"Line":0}},{"line":316,"address":[],"length":0,"stats":{"Line":0}},{"line":317,"address":[],"length":0,"stats":{"Line":0}},{"line":319,"address":[],"length":0,"stats":{"Line":0}},{"line":321,"address":[],"length":0,"stats":{"Line":0}},{"line":322,"address":[],"length":0,"stats":{"Line":0}},{"line":323,"address":[],"length":0,"stats":{"Line":0}},{"line":324,"address":[],"length":0,"stats":{"Line":0}},{"line":325,"address":[],"length":0,"stats":{"Line":0}},{"line":327,"address":[],"length":0,"stats":{"Line":0}},{"line":328,"address":[],"length":0,"stats":{"Line":0}},{"line":329,"address":[],"length":0,"stats":{"Line":0}},{"line":330,"address":[],"length":0,"stats":{"Line":0}},{"line":331,"address":[],"length":0,"stats":{"Line":0}},{"line":332,"address":[],"length":0,"stats":{"Line":0}},{"line":333,"address":[],"length":0,"stats":{"Line":0}},{"line":336,"address":[],"length":0,"stats":{"Line":0}},{"line":337,"address":[],"length":0,"stats":{"Line":0}},{"line":341,"address":[],"length":0,"stats":{"Line":0}},{"line":348,"address":[],"length":0,"stats":{"Line":0}},{"line":349,"address":[],"length":0,"stats":{"Line":0}},{"line":351,"address":[],"length":0,"stats":{"Line":0}},{"line":353,"address":[],"length":0,"stats":{"Line":0}},{"line":355,"address":[],"length":0,"stats":{"Line":0}},{"line":357,"address":[],"length":0,"stats":{"Line":0}},{"line":358,"address":[],"length":0,"stats":{"Line":0}},{"line":359,"address":[],"length":0,"stats":{"Line":0}},{"line":360,"address":[],"length":0,"stats":{"Line":0}},{"line":361,"address":[],"length":0,"stats":{"Line":0}},{"line":362,"address":[],"length":0,"stats":{"Line":0}},{"line":363,"address":[],"length":0,"stats":{"Line":0}},{"line":364,"address":[],"length":0,"stats":{"Line":0}},{"line":365,"address":[],"length":0,"stats":{"Line":0}},{"line":366,"address":[],"length":0,"stats":{"Line":0}},{"line":368,"address":[],"length":0,"stats":{"Line":0}},{"line":369,"address":[],"length":0,"stats":{"Line":0}},{"line":370,"address":[],"length":0,"stats":{"Line":0}},{"line":371,"address":[],"length":0,"stats":{"Line":0}},{"line":374,"address":[],"length":0,"stats":{"Line":0}},{"line":375,"address":[],"length":0,"stats":{"Line":0}},{"line":379,"address":[],"length":0,"stats":{"Line":0}},{"line":380,"address":[],"length":0,"stats":{"Line":0}},{"line":381,"address":[],"length":0,"stats":{"Line":0}},{"line":383,"address":[],"length":0,"stats":{"Line":0}},{"line":384,"address":[],"length":0,"stats":{"Line":0}},{"line":386,"address":[],"length":0,"stats":{"Line":0}},{"line":388,"address":[],"length":0,"stats":{"Line":0}},{"line":390,"address":[],"length":0,"stats":{"Line":0}},{"line":391,"address":[],"length":0,"stats":{"Line":0}},{"line":392,"address":[],"length":0,"stats":{"Line":0}},{"line":393,"address":[],"length":0,"stats":{"Line":0}},{"line":394,"address":[],"length":0,"stats":{"Line":0}},{"line":395,"address":[],"length":0,"stats":{"Line":0}},{"line":396,"address":[],"length":0,"stats":{"Line":0}},{"line":398,"address":[],"length":0,"stats":{"Line":0}},{"line":399,"address":[],"length":0,"stats":{"Line":0}},{"line":400,"address":[],"length":0,"stats":{"Line":0}},{"line":401,"address":[],"length":0,"stats":{"Line":0}},{"line":404,"address":[],"length":0,"stats":{"Line":0}},{"line":405,"address":[],"length":0,"stats":{"Line":0}},{"line":409,"address":[],"length":0,"stats":{"Line":0}},{"line":417,"address":[],"length":0,"stats":{"Line":0}},{"line":419,"address":[],"length":0,"stats":{"Line":0}},{"line":420,"address":[],"length":0,"stats":{"Line":0}},{"line":421,"address":[],"length":0,"stats":{"Line":0}},{"line":422,"address":[],"length":0,"stats":{"Line":0}},{"line":423,"address":[],"length":0,"stats":{"Line":0}},{"line":425,"address":[],"length":0,"stats":{"Line":0}},{"line":426,"address":[],"length":0,"stats":{"Line":0}},{"line":430,"address":[],"length":0,"stats":{"Line":0}},{"line":431,"address":[],"length":0,"stats":{"Line":0}},{"line":432,"address":[],"length":0,"stats":{"Line":0}},{"line":433,"address":[],"length":0,"stats":{"Line":0}},{"line":437,"address":[],"length":0,"stats":{"Line":0}},{"line":438,"address":[],"length":0,"stats":{"Line":0}},{"line":439,"address":[],"length":0,"stats":{"Line":0}},{"line":440,"address":[],"length":0,"stats":{"Line":0}},{"line":444,"address":[],"length":0,"stats":{"Line":0}},{"line":445,"address":[],"length":0,"stats":{"Line":0}},{"line":446,"address":[],"length":0,"stats":{"Line":0}},{"line":447,"address":[],"length":0,"stats":{"Line":0}},{"line":451,"address":[],"length":0,"stats":{"Line":0}},{"line":452,"address":[],"length":0,"stats":{"Line":0}},{"line":453,"address":[],"length":0,"stats":{"Line":0}},{"line":454,"address":[],"length":0,"stats":{"Line":0}},{"line":458,"address":[],"length":0,"stats":{"Line":0}},{"line":459,"address":[],"length":0,"stats":{"Line":0}},{"line":460,"address":[],"length":0,"stats":{"Line":0}},{"line":461,"address":[],"length":0,"stats":{"Line":0}},{"line":462,"address":[],"length":0,"stats":{"Line":0}},{"line":463,"address":[],"length":0,"stats":{"Line":0}},{"line":464,"address":[],"length":0,"stats":{"Line":0}},{"line":465,"address":[],"length":0,"stats":{"Line":0}},{"line":466,"address":[],"length":0,"stats":{"Line":0}},{"line":467,"address":[],"length":0,"stats":{"Line":0}},{"line":471,"address":[],"length":0,"stats":{"Line":0}},{"line":472,"address":[],"length":0,"stats":{"Line":0}},{"line":473,"address":[],"length":0,"stats":{"Line":0}},{"line":474,"address":[],"length":0,"stats":{"Line":0}},{"line":475,"address":[],"length":0,"stats":{"Line":0}},{"line":476,"address":[],"length":0,"stats":{"Line":0}},{"line":477,"address":[],"length":0,"stats":{"Line":0}},{"line":478,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":287},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","vilink-protocol","src","state","action_batch.rs"],"content":"use anchor_lang::prelude::*;\r\n\r\n/// Batch action container\r\n#[account]\r\n#[derive(Default)]\r\npub struct ActionBatch {\r\n    /// Batch ID\r\n    pub batch_id: [u8; 32],\r\n    /// Creator\r\n    pub creator: Pubkey,\r\n    /// Action IDs in this batch\r\n    pub action_ids: Vec\u003c[u8; 32]\u003e,\r\n    /// Batch created timestamp\r\n    pub created_at: i64,\r\n    /// Total actions in batch\r\n    pub total_actions: u8,\r\n    /// Executed actions count\r\n    pub executed_count: u8,\r\n    /// PDA bump\r\n    pub bump: u8,\r\n}\r\n\r\nimpl ActionBatch {\r\n    pub const LEN: usize = 8 + // discriminator\r\n        32 + // batch_id\r\n        32 + // creator\r\n        4 + (32 * 10) + // action_ids (Vec with max 10)\r\n        8 +  // created_at\r\n        1 +  // total_actions\r\n        1 +  // executed_count\r\n        1;   // bump\r\n}\r\n\r\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","vilink-protocol","src","state","mod.rs"],"content":"pub mod vilink_config;\r\npub mod vilink_action;\r\npub mod registered_dapp;\r\npub mod user_action_stats;\r\npub mod action_batch;\r\npub mod utils;\r\n\r\npub use vilink_config::*;\r\npub use vilink_action::*;\r\npub use registered_dapp::*;\r\npub use user_action_stats::*;\r\npub use action_batch::*;\r\npub use utils::*;\r\n\r\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","vilink-protocol","src","state","registered_dapp.rs"],"content":"use anchor_lang::prelude::*;\r\n\r\n/// Registered external dApp\r\n#[account]\r\n#[derive(Default)]\r\npub struct RegisteredDApp {\r\n    /// dApp identifier (domain hash or pubkey)\r\n    pub dapp_id: [u8; 32],\r\n    /// dApp name\r\n    pub name: [u8; 32],\r\n    /// dApp authority\r\n    pub authority: Pubkey,\r\n    /// dApp webhook URL hash\r\n    pub webhook_hash: [u8; 32],\r\n    /// Whether dApp is active\r\n    pub is_active: bool,\r\n    /// Registration timestamp\r\n    pub registered_at: i64,\r\n    /// Total actions from this dApp\r\n    pub action_count: u64,\r\n    /// Allowed action types bitmap\r\n    pub allowed_actions: u8,\r\n    /// Fee share (for affiliate model)\r\n    pub fee_share_bps: u16,\r\n    /// PDA bump\r\n    pub bump: u8,\r\n}\r\n\r\nimpl RegisteredDApp {\r\n    pub const LEN: usize = 8 + // discriminator\r\n        32 + // dapp_id\r\n        32 + // name\r\n        32 + // authority\r\n        32 + // webhook_hash\r\n        1 +  // is_active\r\n        8 +  // registered_at\r\n        8 +  // action_count\r\n        1 +  // allowed_actions\r\n        2 +  // fee_share_bps\r\n        1;   // bump\r\n}\r\n\r\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","vilink-protocol","src","state","user_action_stats.rs"],"content":"use anchor_lang::prelude::*;\r\n\r\n/// User action statistics\r\n#[account]\r\n#[derive(Default)]\r\npub struct UserActionStats {\r\n    /// User wallet\r\n    pub user: Pubkey,\r\n    /// Total actions created\r\n    pub actions_created: u64,\r\n    /// Total actions executed\r\n    pub actions_executed: u64,\r\n    /// Total tips sent\r\n    pub tips_sent: u64,\r\n    /// Total tips received\r\n    pub tips_received: u64,\r\n    /// Total VCoin sent via tips\r\n    pub vcoin_sent: u64,\r\n    /// Total VCoin received via tips\r\n    pub vcoin_received: u64,\r\n    /// Total vouches given via actions\r\n    pub vouches_given: u64,\r\n    /// Total follows via actions\r\n    pub follows_given: u64,\r\n    /// First action timestamp\r\n    pub first_action_at: i64,\r\n    /// Last action timestamp\r\n    pub last_action_at: i64,\r\n    /// PDA bump\r\n    pub bump: u8,\r\n}\r\n\r\nimpl UserActionStats {\r\n    pub const LEN: usize = 8 + // discriminator\r\n        32 + // user\r\n        8 +  // actions_created\r\n        8 +  // actions_executed\r\n        8 +  // tips_sent\r\n        8 +  // tips_received\r\n        8 +  // vcoin_sent\r\n        8 +  // vcoin_received\r\n        8 +  // vouches_given\r\n        8 +  // follows_given\r\n        8 +  // first_action_at\r\n        8 +  // last_action_at\r\n        1;   // bump\r\n}\r\n\r\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","vilink-protocol","src","state","utils.rs"],"content":"use anchor_lang::prelude::*;\r\n\r\n/// Get action type name\r\npub fn action_type_name(action_type: u8) -\u003e \u0026'static str {\r\n    match action_type {\r\n        0 =\u003e \"Tip\",\r\n        1 =\u003e \"Vouch\",\r\n        2 =\u003e \"Follow\",\r\n        3 =\u003e \"Challenge\",\r\n        4 =\u003e \"Stake\",\r\n        5 =\u003e \"ContentReact\",\r\n        6 =\u003e \"Delegate\",\r\n        7 =\u003e \"Vote\",\r\n        _ =\u003e \"Unknown\",\r\n    }\r\n}\r\n\r\n/// Generate action ID from inputs\r\npub fn generate_action_id(\r\n    creator: \u0026Pubkey,\r\n    target: \u0026Pubkey,\r\n    action_type: u8,\r\n    amount: u64,\r\n    timestamp: i64,\r\n) -\u003e [u8; 32] {\r\n    use solana_program::keccak;\r\n    \r\n    let mut data = Vec::with_capacity(81);\r\n    data.extend_from_slice(creator.as_ref());\r\n    data.extend_from_slice(target.as_ref());\r\n    data.push(action_type);\r\n    data.extend_from_slice(\u0026amount.to_le_bytes());\r\n    data.extend_from_slice(\u0026timestamp.to_le_bytes());\r\n    \r\n    keccak::hash(\u0026data).to_bytes()\r\n}\r\n\r\n/// Generate dApp ID from authority\r\npub fn generate_dapp_id(authority: \u0026Pubkey) -\u003e [u8; 32] {\r\n    use solana_program::keccak;\r\n    \r\n    let mut data = Vec::with_capacity(40);\r\n    data.extend_from_slice(b\"vilink-dapp\");\r\n    data.extend_from_slice(authority.as_ref());\r\n    \r\n    keccak::hash(\u0026data).to_bytes()\r\n}\r\n\r\n/// Generate batch ID\r\npub fn generate_batch_id(creator: \u0026Pubkey, timestamp: i64) -\u003e [u8; 32] {\r\n    use solana_program::keccak;\r\n    \r\n    let mut data = Vec::with_capacity(48);\r\n    data.extend_from_slice(b\"vilink-batch\");\r\n    data.extend_from_slice(creator.as_ref());\r\n    data.extend_from_slice(\u0026timestamp.to_le_bytes());\r\n    \r\n    keccak::hash(\u0026data).to_bytes()\r\n}\r\n\r\n","traces":[{"line":4,"address":[],"length":0,"stats":{"Line":720575940379279360}},{"line":5,"address":[],"length":0,"stats":{"Line":720575940379279360}},{"line":6,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":7,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":8,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":9,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":10,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":11,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":12,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":13,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":14,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":19,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":28,"address":[],"length":0,"stats":{"Line":720575940379279360}},{"line":29,"address":[],"length":0,"stats":{"Line":1080863910568919040}},{"line":30,"address":[],"length":0,"stats":{"Line":1080863910568919040}},{"line":31,"address":[],"length":0,"stats":{"Line":1080863910568919040}},{"line":32,"address":[],"length":0,"stats":{"Line":1080863910568919040}},{"line":33,"address":[],"length":0,"stats":{"Line":1080863910568919040}},{"line":35,"address":[],"length":0,"stats":{"Line":1080863910568919040}},{"line":39,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":42,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":43,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":44,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":46,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":50,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":53,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":54,"address":[],"length":0,"stats":{"Line":648518346341351424}},{"line":55,"address":[],"length":0,"stats":{"Line":648518346341351424}},{"line":56,"address":[],"length":0,"stats":{"Line":648518346341351424}},{"line":58,"address":[],"length":0,"stats":{"Line":648518346341351424}}],"covered":30,"coverable":30},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","vilink-protocol","src","state","vilink_action.rs"],"content":"use anchor_lang::prelude::*;\r\n\r\n/// Individual action link\r\n#[account]\r\n#[derive(Default)]\r\npub struct ViLinkAction {\r\n    /// Unique action ID (hash)\r\n    pub action_id: [u8; 32],\r\n    /// Action creator\r\n    pub creator: Pubkey,\r\n    /// Target user (recipient of tip, vouch target, etc.)\r\n    pub target: Pubkey,\r\n    /// Action type\r\n    pub action_type: u8,\r\n    /// Amount (for tips, stakes)\r\n    pub amount: u64,\r\n    /// Optional metadata hash (IPFS CID, etc.)\r\n    pub metadata_hash: [u8; 32],\r\n    /// Creation timestamp\r\n    pub created_at: i64,\r\n    /// Expiry timestamp\r\n    pub expires_at: i64,\r\n    /// Whether action has been executed\r\n    pub executed: bool,\r\n    /// Executor (who executed the action)\r\n    pub executor: Pubkey,\r\n    /// Execution timestamp\r\n    pub executed_at: i64,\r\n    /// Associated content ID (for content reactions)\r\n    pub content_id: Option\u003c[u8; 32]\u003e,\r\n    /// Source dApp\r\n    pub source_dapp: Pubkey,\r\n    /// One-time use?\r\n    pub one_time: bool,\r\n    /// Execution count (for reusable actions)\r\n    pub execution_count: u32,\r\n    /// Max executions (0 = unlimited)\r\n    pub max_executions: u32,\r\n    /// PDA bump\r\n    pub bump: u8,\r\n}\r\n\r\nimpl ViLinkAction {\r\n    pub const LEN: usize = 8 + // discriminator\r\n        32 + // action_id\r\n        32 + // creator\r\n        32 + // target\r\n        1 +  // action_type\r\n        8 +  // amount\r\n        32 + // metadata_hash\r\n        8 +  // created_at\r\n        8 +  // expires_at\r\n        1 +  // executed\r\n        32 + // executor\r\n        8 +  // executed_at\r\n        (1 + 32) + // content_id (Option)\r\n        32 + // source_dapp\r\n        1 +  // one_time\r\n        4 +  // execution_count\r\n        4 +  // max_executions\r\n        1;   // bump\r\n}\r\n\r\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","vilink-protocol","src","state","vilink_config.rs"],"content":"use anchor_lang::prelude::*;\r\n\r\n/// Global ViLink configuration\r\n#[account]\r\n#[derive(Default)]\r\npub struct ViLinkConfig {\r\n    /// Admin authority\r\n    pub authority: Pubkey,\r\n    /// VCoin mint\r\n    pub vcoin_mint: Pubkey,\r\n    /// Treasury for platform fees\r\n    pub treasury: Pubkey,\r\n    /// 5A Protocol for vouch integration\r\n    pub five_a_program: Pubkey,\r\n    /// Staking protocol for stake actions\r\n    pub staking_program: Pubkey,\r\n    /// Content registry for react actions\r\n    pub content_registry: Pubkey,\r\n    /// Governance protocol for vote/delegate actions\r\n    pub governance_program: Pubkey,\r\n    /// Gasless protocol for session key execution\r\n    pub gasless_program: Pubkey,\r\n    /// Enabled action types bitmap (8 bits, one per action type)\r\n    pub enabled_actions: u8,\r\n    /// Total actions created\r\n    pub total_actions_created: u64,\r\n    /// Total actions executed\r\n    pub total_actions_executed: u64,\r\n    /// Total VCoin volume through tips\r\n    pub total_tip_volume: u64,\r\n    /// Whether protocol is paused\r\n    pub paused: bool,\r\n    /// Platform fee in basis points\r\n    pub platform_fee_bps: u16,\r\n    /// PDA bump\r\n    pub bump: u8,\r\n}\r\n\r\nimpl ViLinkConfig {\r\n    pub const LEN: usize = 8 + // discriminator\r\n        32 + // authority\r\n        32 + // vcoin_mint\r\n        32 + // treasury\r\n        32 + // five_a_program\r\n        32 + // staking_program\r\n        32 + // content_registry\r\n        32 + // governance_program\r\n        32 + // gasless_program\r\n        1 +  // enabled_actions\r\n        8 +  // total_actions_created\r\n        8 +  // total_actions_executed\r\n        8 +  // total_tip_volume\r\n        1 +  // paused\r\n        2 +  // platform_fee_bps\r\n        1;   // bump\r\n    \r\n    /// Check if action type is enabled\r\n    pub fn is_action_enabled(\u0026self, action_type: u8) -\u003e bool {\r\n        (self.enabled_actions \u0026 (1 \u003c\u003c action_type)) != 0\r\n    }\r\n}\r\n\r\n","traces":[{"line":58,"address":[],"length":0,"stats":{"Line":1441151880758558720}},{"line":59,"address":[],"length":0,"stats":{"Line":1441151880758558720}}],"covered":2,"coverable":2},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","vilink-protocol","src","tests.rs"],"content":"//! Unit tests for ViLink Protocol\r\n//!\r\n//! These tests run against the ACTUAL program code.\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n    use crate::constants::*;\r\n    use crate::state::{ViLinkConfig, ViLinkAction, UserActionStats};\r\n    use crate::state::utils::{action_type_name, generate_action_id, generate_dapp_id, generate_batch_id};\r\n    use anchor_lang::prelude::Pubkey;\r\n\r\n    // ========================================================================\r\n    // Constants Tests\r\n    // ========================================================================\r\n\r\n    #[test]\r\n    fn test_pda_seeds() {\r\n        assert_eq!(CONFIG_SEED, b\"vilink-config\");\r\n        assert_eq!(ACTION_SEED, b\"action\");\r\n        assert_eq!(DAPP_REGISTRY_SEED, b\"dapp\");\r\n        assert_eq!(USER_STATS_SEED, b\"user-stats\");\r\n        assert_eq!(BATCH_SEED, b\"batch\");\r\n    }\r\n\r\n    #[test]\r\n    fn test_action_types() {\r\n        assert_eq!(ACTION_TIP, 0);\r\n        assert_eq!(ACTION_VOUCH, 1);\r\n        assert_eq!(ACTION_FOLLOW, 2);\r\n        assert_eq!(ACTION_CHALLENGE, 3);\r\n        assert_eq!(ACTION_STAKE, 4);\r\n        assert_eq!(ACTION_CONTENT_REACT, 5);\r\n        assert_eq!(ACTION_DELEGATE, 6);\r\n        assert_eq!(ACTION_VOTE, 7);\r\n    }\r\n\r\n    #[test]\r\n    fn test_action_limits() {\r\n        assert_eq!(MAX_ACTIONS_PER_BATCH, 10);\r\n        assert_eq!(MAX_ACTION_EXPIRY, 7 * 24 * 60 * 60, \"7 days\");\r\n        assert_eq!(MIN_TIP_AMOUNT, 100_000_000, \"0.1 VCoin\");\r\n        assert_eq!(MAX_TIP_AMOUNT, 10_000_000_000_000, \"10,000 VCoin\");\r\n    }\r\n\r\n    #[test]\r\n    fn test_platform_fee() {\r\n        assert_eq!(PLATFORM_FEE_BPS, 250, \"2.5%\");\r\n    }\r\n\r\n    // ========================================================================\r\n    // State Size Tests\r\n    // ========================================================================\r\n\r\n    #[test]\r\n    fn test_vilink_config_size() {\r\n        let expected = 8 + 32 + 32 + 32 + 32 + 32 + 32 + 32 + 32 + 1 + 8 + 8 + 8 + 1 + 2 + 1;\r\n        assert_eq!(ViLinkConfig::LEN, expected, \"Config size mismatch\");\r\n    }\r\n\r\n    #[test]\r\n    fn test_vilink_action_size() {\r\n        let expected = 8 + 32 + 32 + 32 + 1 + 8 + 32 + 8 + 8 + 1 + 32 + 8 + (1 + 32) + 32 + 1 + 4 + 4 + 1;\r\n        assert_eq!(ViLinkAction::LEN, expected, \"Action size mismatch\");\r\n    }\r\n\r\n    #[test]\r\n    fn test_user_action_stats_size() {\r\n        let expected = 8 + 32 + 8 + 8 + 8 + 8 + 8 + 8 + 8 + 8 + 8 + 8 + 1;\r\n        assert_eq!(UserActionStats::LEN, expected, \"Stats size mismatch\");\r\n    }\r\n\r\n    // ========================================================================\r\n    // Action Type Name Tests\r\n    // ========================================================================\r\n\r\n    #[test]\r\n    fn test_action_type_names() {\r\n        assert_eq!(action_type_name(0), \"Tip\");\r\n        assert_eq!(action_type_name(1), \"Vouch\");\r\n        assert_eq!(action_type_name(2), \"Follow\");\r\n        assert_eq!(action_type_name(3), \"Challenge\");\r\n        assert_eq!(action_type_name(4), \"Stake\");\r\n        assert_eq!(action_type_name(5), \"ContentReact\");\r\n        assert_eq!(action_type_name(6), \"Delegate\");\r\n        assert_eq!(action_type_name(7), \"Vote\");\r\n        assert_eq!(action_type_name(8), \"Unknown\");\r\n        assert_eq!(action_type_name(255), \"Unknown\");\r\n    }\r\n\r\n    // ========================================================================\r\n    // Action ID Generation Tests\r\n    // ========================================================================\r\n\r\n    #[test]\r\n    fn test_action_id_generation() {\r\n        let creator = Pubkey::new_unique();\r\n        let target = Pubkey::new_unique();\r\n        \r\n        let action_id = generate_action_id(\u0026creator, \u0026target, ACTION_TIP, 1000, 12345);\r\n        \r\n        // Verify it's deterministic\r\n        let action_id_2 = generate_action_id(\u0026creator, \u0026target, ACTION_TIP, 1000, 12345);\r\n        assert_eq!(action_id, action_id_2);\r\n    }\r\n\r\n    #[test]\r\n    fn test_action_id_unique() {\r\n        let creator = Pubkey::new_unique();\r\n        let target = Pubkey::new_unique();\r\n        \r\n        let id1 = generate_action_id(\u0026creator, \u0026target, ACTION_TIP, 1000, 12345);\r\n        let id2 = generate_action_id(\u0026creator, \u0026target, ACTION_TIP, 2000, 12345);\r\n        let id3 = generate_action_id(\u0026creator, \u0026target, ACTION_TIP, 1000, 12346);\r\n        \r\n        assert_ne!(id1, id2, \"Different amounts should produce different IDs\");\r\n        assert_ne!(id1, id3, \"Different timestamps should produce different IDs\");\r\n    }\r\n\r\n    #[test]\r\n    fn test_dapp_id_generation() {\r\n        let authority = Pubkey::new_unique();\r\n        \r\n        let dapp_id = generate_dapp_id(\u0026authority);\r\n        \r\n        // Verify deterministic\r\n        let dapp_id_2 = generate_dapp_id(\u0026authority);\r\n        assert_eq!(dapp_id, dapp_id_2);\r\n    }\r\n\r\n    #[test]\r\n    fn test_batch_id_generation() {\r\n        let creator = Pubkey::new_unique();\r\n        \r\n        let batch_id = generate_batch_id(\u0026creator, 12345);\r\n        \r\n        // Verify deterministic\r\n        let batch_id_2 = generate_batch_id(\u0026creator, 12345);\r\n        assert_eq!(batch_id, batch_id_2);\r\n        \r\n        // Different timestamp = different batch\r\n        let batch_id_3 = generate_batch_id(\u0026creator, 12346);\r\n        assert_ne!(batch_id, batch_id_3);\r\n    }\r\n\r\n    // ========================================================================\r\n    // Config Action Enabled Tests\r\n    // ========================================================================\r\n\r\n    #[test]\r\n    fn test_action_enabled_all() {\r\n        let config = ViLinkConfig {\r\n            enabled_actions: 0xFF, // All enabled\r\n            ..Default::default()\r\n        };\r\n        \r\n        for action_type in 0..8 {\r\n            assert!(config.is_action_enabled(action_type), \"Action {} should be enabled\", action_type);\r\n        }\r\n    }\r\n\r\n    #[test]\r\n    fn test_action_enabled_none() {\r\n        let config = ViLinkConfig {\r\n            enabled_actions: 0x00, // None enabled\r\n            ..Default::default()\r\n        };\r\n        \r\n        for action_type in 0..8 {\r\n            assert!(!config.is_action_enabled(action_type), \"Action {} should be disabled\", action_type);\r\n        }\r\n    }\r\n\r\n    #[test]\r\n    fn test_action_enabled_selective() {\r\n        let config = ViLinkConfig {\r\n            enabled_actions: 0b00000101, // Only Tip (0) and Follow (2)\r\n            ..Default::default()\r\n        };\r\n        \r\n        assert!(config.is_action_enabled(ACTION_TIP));\r\n        assert!(!config.is_action_enabled(ACTION_VOUCH));\r\n        assert!(config.is_action_enabled(ACTION_FOLLOW));\r\n        assert!(!config.is_action_enabled(ACTION_CHALLENGE));\r\n    }\r\n\r\n    // ========================================================================\r\n    // Fee Calculation Tests\r\n    // ========================================================================\r\n\r\n    #[test]\r\n    fn test_platform_fee_calculation() {\r\n        let amount = 100_000_000_000u64; // 100 VCoin\r\n        let fee = (amount as u128 * PLATFORM_FEE_BPS as u128 / 10000) as u64;\r\n        \r\n        // 2.5% of 100 VCoin = 2.5 VCoin\r\n        assert_eq!(fee, 2_500_000_000);\r\n    }\r\n\r\n    #[test]\r\n    fn test_min_tip_fee() {\r\n        let amount = MIN_TIP_AMOUNT; // 0.1 VCoin\r\n        let fee = (amount as u128 * PLATFORM_FEE_BPS as u128 / 10000) as u64;\r\n        \r\n        // 2.5% of 0.1 VCoin = 0.0025 VCoin\r\n        assert_eq!(fee, 2_500_000);\r\n    }\r\n\r\n    // ========================================================================\r\n    // Action State Tests\r\n    // ========================================================================\r\n\r\n    #[test]\r\n    fn test_action_default() {\r\n        let action = ViLinkAction::default();\r\n        \r\n        assert!(!action.executed);\r\n        assert_eq!(action.execution_count, 0);\r\n        assert!(!action.one_time);\r\n    }\r\n\r\n    #[test]\r\n    fn test_action_one_time() {\r\n        let mut action = ViLinkAction::default();\r\n        action.one_time = true;\r\n        action.executed = true;\r\n        \r\n        // One-time action that's been executed\r\n        assert!(action.one_time \u0026\u0026 action.executed);\r\n    }\r\n\r\n    #[test]\r\n    fn test_action_multi_execution() {\r\n        let mut action = ViLinkAction::default();\r\n        action.one_time = false;\r\n        action.max_executions = 10;\r\n        action.execution_count = 5;\r\n        \r\n        // Can still execute\r\n        assert!(action.execution_count \u003c action.max_executions);\r\n    }\r\n\r\n    // ========================================================================\r\n    // PDA Derivation Tests\r\n    // ========================================================================\r\n\r\n    #[test]\r\n    fn test_action_pda_unique() {\r\n        let program_id = Pubkey::new_unique();\r\n        let creator = Pubkey::new_unique();\r\n        let ts1 = 1000i64;\r\n        let ts2 = 2000i64;\r\n        \r\n        let (pda1, _) = Pubkey::find_program_address(\r\n            \u0026[ACTION_SEED, creator.as_ref(), \u0026ts1.to_le_bytes()],\r\n            \u0026program_id\r\n        );\r\n        \r\n        let (pda2, _) = Pubkey::find_program_address(\r\n            \u0026[ACTION_SEED, creator.as_ref(), \u0026ts2.to_le_bytes()],\r\n            \u0026program_id\r\n        );\r\n        \r\n        assert_ne!(pda1, pda2);\r\n    }\r\n\r\n    // ========================================================================\r\n    // Invariant Tests\r\n    // ========================================================================\r\n\r\n    #[test]\r\n    fn test_invariant_execution_count_bounded() {\r\n        let action = ViLinkAction {\r\n            max_executions: 10,\r\n            execution_count: 10,\r\n            ..Default::default()\r\n        };\r\n        \r\n        // execution_count should not exceed max_executions\r\n        assert!(action.execution_count \u003c= action.max_executions);\r\n    }\r\n\r\n    #[test]\r\n    fn test_invariant_tip_amount_bounded() {\r\n        let amount = 5_000_000_000_000u64; // 5000 VCoin\r\n        \r\n        assert!(amount \u003e= MIN_TIP_AMOUNT);\r\n        assert!(amount \u003c= MAX_TIP_AMOUNT);\r\n    }\r\n}\r\n\r\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","vilink-protocol","tests","action.rs"],"content":"//! Integration tests for vilink-protocol action instructions\r\n\r\nmod common;\r\n\r\nuse common::*;\r\nuse solana_sdk::signature::{Keypair, Signer};\r\n\r\n#[tokio::test]\r\nasync fn test_create_action_instruction_format() {\r\n    let ctx = TestContext::new().await;\r\n    \r\n    let (config_pda, _bump) = ctx.get_config_pda();\r\n    let creator = Keypair::new();\r\n    let action = Keypair::new();\r\n    let target = Keypair::new();\r\n    \r\n    let ix = create_action_ix(\r\n        \u0026ctx.program_id,\r\n        \u0026creator.pubkey(),\r\n        \u0026config_pda,\r\n        \u0026action.pubkey(),\r\n        0, // tip\r\n        1_000_000_000,\r\n        \u0026target.pubkey(),\r\n    );\r\n    \r\n    assert_eq!(ix.program_id, ctx.program_id);\r\n    assert_eq!(ix.accounts.len(), 4);\r\n}\r\n\r\n#[tokio::test]\r\nasync fn test_create_action_tip() {\r\n    let ctx = TestContext::new().await;\r\n    \r\n    let (config_pda, _bump) = ctx.get_config_pda();\r\n    let creator = Keypair::new();\r\n    let action = Keypair::new();\r\n    let target = Keypair::new();\r\n    \r\n    let ix = create_action_ix(\r\n        \u0026ctx.program_id,\r\n        \u0026creator.pubkey(),\r\n        \u0026config_pda,\r\n        \u0026action.pubkey(),\r\n        0, // ACTION_TIP\r\n        1_000_000_000,\r\n        \u0026target.pubkey(),\r\n    );\r\n    \r\n    assert_eq!(ix.data[8], 0);\r\n}\r\n\r\n#[tokio::test]\r\nasync fn test_create_action_vouch() {\r\n    let ctx = TestContext::new().await;\r\n    \r\n    let (config_pda, _bump) = ctx.get_config_pda();\r\n    let creator = Keypair::new();\r\n    let action = Keypair::new();\r\n    let target = Keypair::new();\r\n    \r\n    let ix = create_action_ix(\r\n        \u0026ctx.program_id,\r\n        \u0026creator.pubkey(),\r\n        \u0026config_pda,\r\n        \u0026action.pubkey(),\r\n        1, // ACTION_VOUCH\r\n        0,\r\n        \u0026target.pubkey(),\r\n    );\r\n    \r\n    assert_eq!(ix.data[8], 1);\r\n}\r\n\r\n#[tokio::test]\r\nasync fn test_create_action_follow() {\r\n    let ctx = TestContext::new().await;\r\n    \r\n    let (config_pda, _bump) = ctx.get_config_pda();\r\n    let creator = Keypair::new();\r\n    let action = Keypair::new();\r\n    let target = Keypair::new();\r\n    \r\n    let ix = create_action_ix(\r\n        \u0026ctx.program_id,\r\n        \u0026creator.pubkey(),\r\n        \u0026config_pda,\r\n        \u0026action.pubkey(),\r\n        2, // ACTION_FOLLOW\r\n        0,\r\n        \u0026target.pubkey(),\r\n    );\r\n    \r\n    assert_eq!(ix.data[8], 2);\r\n}\r\n\r\n#[tokio::test]\r\nasync fn test_create_action_different_amounts() {\r\n    let ctx = TestContext::new().await;\r\n    \r\n    let (config_pda, _bump) = ctx.get_config_pda();\r\n    let creator = Keypair::new();\r\n    let target = Keypair::new();\r\n    \r\n    for amount in [100_000_000u64, 1_000_000_000, 10_000_000_000] {\r\n        let action = Keypair::new();\r\n        \r\n        let ix = create_action_ix(\r\n            \u0026ctx.program_id,\r\n            \u0026creator.pubkey(),\r\n            \u0026config_pda,\r\n            \u0026action.pubkey(),\r\n            0, // tip\r\n            amount,\r\n            \u0026target.pubkey(),\r\n        );\r\n        \r\n        assert_eq!(\u0026ix.data[9..17], \u0026amount.to_le_bytes());\r\n    }\r\n}\r\n\r\n#[tokio::test]\r\nasync fn test_create_action_all_types() {\r\n    let ctx = TestContext::new().await;\r\n    \r\n    let (config_pda, _bump) = ctx.get_config_pda();\r\n    let creator = Keypair::new();\r\n    let target = Keypair::new();\r\n    \r\n    for action_type in 0..=7 {\r\n        let action = Keypair::new();\r\n        \r\n        let ix = create_action_ix(\r\n            \u0026ctx.program_id,\r\n            \u0026creator.pubkey(),\r\n            \u0026config_pda,\r\n            \u0026action.pubkey(),\r\n            action_type,\r\n            if action_type == 0 { 1_000_000_000 } else { 0 },\r\n            \u0026target.pubkey(),\r\n        );\r\n        \r\n        assert_eq!(ix.data[8], action_type);\r\n    }\r\n}\r\n\r\n#[tokio::test]\r\nasync fn test_create_action_multiple_creators() {\r\n    let ctx = TestContext::new().await;\r\n    \r\n    let (config_pda, _bump) = ctx.get_config_pda();\r\n    let target = Keypair::new();\r\n    \r\n    for _ in 0..5 {\r\n        let creator = Keypair::new();\r\n        let action = Keypair::new();\r\n        \r\n        let ix = create_action_ix(\r\n            \u0026ctx.program_id,\r\n            \u0026creator.pubkey(),\r\n            \u0026config_pda,\r\n            \u0026action.pubkey(),\r\n            0,\r\n            1_000_000_000,\r\n            \u0026target.pubkey(),\r\n        );\r\n        \r\n        assert_eq!(ix.accounts[2].pubkey, creator.pubkey());\r\n    }\r\n}\r\n\r\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","vilink-protocol","tests","admin.rs"],"content":"//! Integration tests for vilink-protocol admin instructions\r\n\r\nmod common;\r\n\r\nuse common::*;\r\nuse solana_sdk::signature::{Keypair, Signer};\r\n\r\n#[tokio::test]\r\nasync fn test_set_paused_true() {\r\n    let ctx = TestContext::new().await;\r\n    \r\n    let (config_pda, _bump) = ctx.get_config_pda();\r\n    \r\n    let ix = create_set_paused_ix(\r\n        \u0026ctx.program_id,\r\n        \u0026ctx.payer.pubkey(),\r\n        \u0026config_pda,\r\n        true,\r\n    );\r\n    \r\n    assert_eq!(ix.data[8], 1);\r\n}\r\n\r\n#[tokio::test]\r\nasync fn test_set_paused_false() {\r\n    let ctx = TestContext::new().await;\r\n    \r\n    let (config_pda, _bump) = ctx.get_config_pda();\r\n    \r\n    let ix = create_set_paused_ix(\r\n        \u0026ctx.program_id,\r\n        \u0026ctx.payer.pubkey(),\r\n        \u0026config_pda,\r\n        false,\r\n    );\r\n    \r\n    assert_eq!(ix.data[8], 0);\r\n}\r\n\r\n#[tokio::test]\r\nasync fn test_set_paused_unauthorized() {\r\n    let ctx = TestContext::new().await;\r\n    \r\n    let (config_pda, _bump) = ctx.get_config_pda();\r\n    let unauthorized = Keypair::new();\r\n    \r\n    let ix = create_set_paused_ix(\r\n        \u0026ctx.program_id,\r\n        \u0026unauthorized.pubkey(),\r\n        \u0026config_pda,\r\n        true,\r\n    );\r\n    \r\n    assert_eq!(ix.accounts[1].pubkey, unauthorized.pubkey());\r\n}\r\n\r\n#[tokio::test]\r\nasync fn test_set_paused_toggle() {\r\n    let ctx = TestContext::new().await;\r\n    \r\n    let (config_pda, _bump) = ctx.get_config_pda();\r\n    \r\n    for paused in [true, false, true, false] {\r\n        let ix = create_set_paused_ix(\r\n            \u0026ctx.program_id,\r\n            \u0026ctx.payer.pubkey(),\r\n            \u0026config_pda,\r\n            paused,\r\n        );\r\n        \r\n        assert_eq!(ix.data[8], if paused { 1 } else { 0 });\r\n    }\r\n}\r\n\r\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","vilink-protocol","tests","common","mod.rs"],"content":"//! Common test utilities for vilink-protocol integration tests\r\n\r\nuse anchor_lang::prelude::*;\r\nuse solana_program_test::*;\r\nuse solana_sdk::{\r\n    account::Account,\r\n    hash::Hash,\r\n    instruction::{AccountMeta, Instruction},\r\n    pubkey::Pubkey,\r\n    signature::{Keypair, Signer},\r\n    transaction::Transaction,\r\n};\r\n\r\npub const CONFIG_SEED: \u0026[u8] = b\"vilink-config\";\r\npub const ACTION_SEED: \u0026[u8] = b\"action\";\r\npub const DAPP_REGISTRY_SEED: \u0026[u8] = b\"dapp\";\r\npub const BATCH_SEED: \u0026[u8] = b\"batch\";\r\n\r\npub struct TestContext {\r\n    pub banks_client: BanksClient,\r\n    pub payer: Keypair,\r\n    pub recent_blockhash: Hash,\r\n    pub program_id: Pubkey,\r\n}\r\n\r\nimpl TestContext {\r\n    pub async fn new() -\u003e Self {\r\n        let program_id = vilink_protocol::id();\r\n        let program_test = ProgramTest::new(\r\n            \"vilink_protocol\",\r\n            program_id,\r\n            processor!(vilink_protocol::entry),\r\n        );\r\n\r\n        let (banks_client, payer, recent_blockhash) = program_test.start().await;\r\n\r\n        Self {\r\n            banks_client,\r\n            payer,\r\n            recent_blockhash,\r\n            program_id,\r\n        }\r\n    }\r\n\r\n    pub async fn refresh_blockhash(\u0026mut self) {\r\n        self.recent_blockhash = self.banks_client.get_latest_blockhash().await.unwrap();\r\n    }\r\n\r\n    pub async fn get_account(\u0026mut self, pubkey: Pubkey) -\u003e Option\u003cAccount\u003e {\r\n        self.banks_client.get_account(pubkey).await.unwrap()\r\n    }\r\n\r\n    pub fn get_config_pda(\u0026self) -\u003e (Pubkey, u8) {\r\n        Pubkey::find_program_address(\u0026[CONFIG_SEED], \u0026self.program_id)\r\n    }\r\n\r\n    pub fn get_dapp_pda(\u0026self, authority: \u0026Pubkey) -\u003e (Pubkey, u8) {\r\n        Pubkey::find_program_address(\u0026[DAPP_REGISTRY_SEED, authority.as_ref()], \u0026self.program_id)\r\n    }\r\n\r\n    pub async fn process_transaction(\r\n        \u0026mut self,\r\n        instructions: \u0026[Instruction],\r\n        signers: \u0026[\u0026Keypair],\r\n    ) -\u003e Result\u003c(), BanksClientError\u003e {\r\n        let mut all_signers = vec![\u0026self.payer];\r\n        all_signers.extend(signers);\r\n        \r\n        let tx = Transaction::new_signed_with_payer(\r\n            instructions,\r\n            Some(\u0026self.payer.pubkey()),\r\n            \u0026all_signers,\r\n            self.recent_blockhash,\r\n        );\r\n        \r\n        let result = self.banks_client.process_transaction(tx).await;\r\n        self.refresh_blockhash().await;\r\n        result\r\n    }\r\n}\r\n\r\npub fn create_initialize_ix(\r\n    program_id: \u0026Pubkey,\r\n    authority: \u0026Pubkey,\r\n    config: \u0026Pubkey,\r\n    vcoin_mint: \u0026Pubkey,\r\n    treasury: \u0026Pubkey,\r\n) -\u003e Instruction {\r\n    let mut data = vec![0u8; 8 + 32];\r\n    let discriminator = anchor_lang::solana_program::hash::hash(b\"global:initialize\").to_bytes();\r\n    data[..8].copy_from_slice(\u0026discriminator[..8]);\r\n    data[8..40].copy_from_slice(treasury.as_ref());\r\n\r\n    Instruction {\r\n        program_id: *program_id,\r\n        accounts: vec![\r\n            AccountMeta::new(*config, false),\r\n            AccountMeta::new_readonly(*vcoin_mint, false),\r\n            AccountMeta::new(*authority, true),\r\n            AccountMeta::new_readonly(solana_sdk::system_program::id(), false),\r\n        ],\r\n        data,\r\n    }\r\n}\r\n\r\npub fn create_action_ix(\r\n    program_id: \u0026Pubkey,\r\n    creator: \u0026Pubkey,\r\n    config: \u0026Pubkey,\r\n    action: \u0026Pubkey,\r\n    action_type: u8,\r\n    amount: u64,\r\n    target: \u0026Pubkey,\r\n) -\u003e Instruction {\r\n    let metadata_hash = [0u8; 32];\r\n    let expiry_seconds = 7 * 24 * 60 * 60i64;\r\n    let mut data = vec![0u8; 8 + 1 + 8 + 32 + 32 + 8 + 1 + 4 + 1 + 32];\r\n    let discriminator = anchor_lang::solana_program::hash::hash(b\"global:create_action\").to_bytes();\r\n    data[..8].copy_from_slice(\u0026discriminator[..8]);\r\n    data[8] = action_type;\r\n    data[9..17].copy_from_slice(\u0026amount.to_le_bytes());\r\n    data[17..49].copy_from_slice(target.as_ref());\r\n    data[49..81].copy_from_slice(\u0026metadata_hash);\r\n    data[81..89].copy_from_slice(\u0026expiry_seconds.to_le_bytes());\r\n    data[89] = 0; // one_time = false\r\n    data[90..94].copy_from_slice(\u00260u32.to_le_bytes()); // max_executions\r\n    data[94] = 0; // None for content_id\r\n\r\n    Instruction {\r\n        program_id: *program_id,\r\n        accounts: vec![\r\n            AccountMeta::new(*config, false),\r\n            AccountMeta::new(*action, false),\r\n            AccountMeta::new(*creator, true),\r\n            AccountMeta::new_readonly(solana_sdk::system_program::id(), false),\r\n        ],\r\n        data,\r\n    }\r\n}\r\n\r\npub fn create_register_dapp_ix(\r\n    program_id: \u0026Pubkey,\r\n    authority: \u0026Pubkey,\r\n    config: \u0026Pubkey,\r\n    dapp: \u0026Pubkey,\r\n    dapp_authority: \u0026Pubkey,\r\n    name: [u8; 32],\r\n    allowed_actions: u8,\r\n    fee_share_bps: u16,\r\n) -\u003e Instruction {\r\n    let webhook_hash = [0u8; 32];\r\n    let mut data = vec![0u8; 8 + 32 + 32 + 1 + 2];\r\n    let discriminator = anchor_lang::solana_program::hash::hash(b\"global:register_dapp\").to_bytes();\r\n    data[..8].copy_from_slice(\u0026discriminator[..8]);\r\n    data[8..40].copy_from_slice(\u0026name);\r\n    data[40..72].copy_from_slice(\u0026webhook_hash);\r\n    data[72] = allowed_actions;\r\n    data[73..75].copy_from_slice(\u0026fee_share_bps.to_le_bytes());\r\n\r\n    Instruction {\r\n        program_id: *program_id,\r\n        accounts: vec![\r\n            AccountMeta::new_readonly(*config, false),\r\n            AccountMeta::new(*dapp, false),\r\n            AccountMeta::new_readonly(*dapp_authority, false),\r\n            AccountMeta::new(*authority, true),\r\n            AccountMeta::new_readonly(solana_sdk::system_program::id(), false),\r\n        ],\r\n        data,\r\n    }\r\n}\r\n\r\npub fn create_set_paused_ix(\r\n    program_id: \u0026Pubkey,\r\n    authority: \u0026Pubkey,\r\n    config: \u0026Pubkey,\r\n    paused: bool,\r\n) -\u003e Instruction {\r\n    let mut data = vec![0u8; 8 + 1];\r\n    let discriminator = anchor_lang::solana_program::hash::hash(b\"global:set_paused\").to_bytes();\r\n    data[..8].copy_from_slice(\u0026discriminator[..8]);\r\n    data[8] = if paused { 1 } else { 0 };\r\n\r\n    Instruction {\r\n        program_id: *program_id,\r\n        accounts: vec![\r\n            AccountMeta::new(*config, false),\r\n            AccountMeta::new(*authority, true),\r\n        ],\r\n        data,\r\n    }\r\n}\r\n\r\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","vilink-protocol","tests","dapp.rs"],"content":"//! Integration tests for vilink-protocol dapp instructions\r\n\r\nmod common;\r\n\r\nuse common::*;\r\nuse solana_sdk::signature::{Keypair, Signer};\r\n\r\n#[tokio::test]\r\nasync fn test_register_dapp_instruction_format() {\r\n    let ctx = TestContext::new().await;\r\n    \r\n    let (config_pda, _bump) = ctx.get_config_pda();\r\n    let dapp_authority = Keypair::new();\r\n    let (dapp_pda, _) = ctx.get_dapp_pda(\u0026dapp_authority.pubkey());\r\n    let name = [b'T', b'e', b's', b't', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];\r\n    \r\n    let ix = create_register_dapp_ix(\r\n        \u0026ctx.program_id,\r\n        \u0026ctx.payer.pubkey(),\r\n        \u0026config_pda,\r\n        \u0026dapp_pda,\r\n        \u0026dapp_authority.pubkey(),\r\n        name,\r\n        0xFF,\r\n        250,\r\n    );\r\n    \r\n    assert_eq!(ix.program_id, ctx.program_id);\r\n    assert_eq!(ix.accounts.len(), 5);\r\n}\r\n\r\n#[tokio::test]\r\nasync fn test_register_dapp_different_allowed_actions() {\r\n    let ctx = TestContext::new().await;\r\n    \r\n    let (config_pda, _bump) = ctx.get_config_pda();\r\n    \r\n    for allowed_actions in [0x01u8, 0x03, 0x0F, 0xFF] {\r\n        let dapp_authority = Keypair::new();\r\n        let (dapp_pda, _) = ctx.get_dapp_pda(\u0026dapp_authority.pubkey());\r\n        let name = [0u8; 32];\r\n        \r\n        let ix = create_register_dapp_ix(\r\n            \u0026ctx.program_id,\r\n            \u0026ctx.payer.pubkey(),\r\n            \u0026config_pda,\r\n            \u0026dapp_pda,\r\n            \u0026dapp_authority.pubkey(),\r\n            name,\r\n            allowed_actions,\r\n            250,\r\n        );\r\n        \r\n        assert_eq!(ix.data[72], allowed_actions);\r\n    }\r\n}\r\n\r\n#[tokio::test]\r\nasync fn test_register_dapp_different_fee_shares() {\r\n    let ctx = TestContext::new().await;\r\n    \r\n    let (config_pda, _bump) = ctx.get_config_pda();\r\n    \r\n    for fee_share in [0u16, 100, 250, 500, 1000] {\r\n        let dapp_authority = Keypair::new();\r\n        let (dapp_pda, _) = ctx.get_dapp_pda(\u0026dapp_authority.pubkey());\r\n        let name = [0u8; 32];\r\n        \r\n        let ix = create_register_dapp_ix(\r\n            \u0026ctx.program_id,\r\n            \u0026ctx.payer.pubkey(),\r\n            \u0026config_pda,\r\n            \u0026dapp_pda,\r\n            \u0026dapp_authority.pubkey(),\r\n            name,\r\n            0xFF,\r\n            fee_share,\r\n        );\r\n        \r\n        assert_eq!(\u0026ix.data[73..75], \u0026fee_share.to_le_bytes());\r\n    }\r\n}\r\n\r\n#[tokio::test]\r\nasync fn test_register_dapp_multiple_dapps() {\r\n    let ctx = TestContext::new().await;\r\n    \r\n    let (config_pda, _bump) = ctx.get_config_pda();\r\n    \r\n    for i in 0..5 {\r\n        let dapp_authority = Keypair::new();\r\n        let (dapp_pda, _) = ctx.get_dapp_pda(\u0026dapp_authority.pubkey());\r\n        let mut name = [0u8; 32];\r\n        name[0] = b'D';\r\n        name[1] = b'a';\r\n        name[2] = b'p';\r\n        name[3] = b'p';\r\n        name[4] = b'0' + i;\r\n        \r\n        let ix = create_register_dapp_ix(\r\n            \u0026ctx.program_id,\r\n            \u0026ctx.payer.pubkey(),\r\n            \u0026config_pda,\r\n            \u0026dapp_pda,\r\n            \u0026dapp_authority.pubkey(),\r\n            name,\r\n            0xFF,\r\n            250,\r\n        );\r\n        \r\n        assert_eq!(ix.accounts[2].pubkey, dapp_authority.pubkey());\r\n    }\r\n}\r\n\r\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","programs","vilink-protocol","tests","initialize.rs"],"content":"//! Integration tests for vilink-protocol initialize instruction\r\n\r\nmod common;\r\n\r\nuse common::*;\r\nuse solana_sdk::signature::{Keypair, Signer};\r\n\r\n#[tokio::test]\r\nasync fn test_initialize_success() {\r\n    let ctx = TestContext::new().await;\r\n    \r\n    let (config_pda, _bump) = ctx.get_config_pda();\r\n    let vcoin_mint = Keypair::new();\r\n    let treasury = Keypair::new();\r\n    \r\n    let ix = create_initialize_ix(\r\n        \u0026ctx.program_id,\r\n        \u0026ctx.payer.pubkey(),\r\n        \u0026config_pda,\r\n        \u0026vcoin_mint.pubkey(),\r\n        \u0026treasury.pubkey(),\r\n    );\r\n    \r\n    assert_eq!(ix.program_id, ctx.program_id);\r\n    assert_eq!(ix.accounts.len(), 4);\r\n}\r\n\r\n#[tokio::test]\r\nasync fn test_initialize_with_treasury() {\r\n    let ctx = TestContext::new().await;\r\n    \r\n    let (config_pda, _bump) = ctx.get_config_pda();\r\n    let vcoin_mint = Keypair::new();\r\n    let treasury = Keypair::new();\r\n    \r\n    let ix = create_initialize_ix(\r\n        \u0026ctx.program_id,\r\n        \u0026ctx.payer.pubkey(),\r\n        \u0026config_pda,\r\n        \u0026vcoin_mint.pubkey(),\r\n        \u0026treasury.pubkey(),\r\n    );\r\n    \r\n    assert_eq!(\u0026ix.data[8..40], treasury.pubkey().as_ref());\r\n}\r\n\r\n#[tokio::test]\r\nasync fn test_initialize_different_mints() {\r\n    let ctx = TestContext::new().await;\r\n    \r\n    let (config_pda, _bump) = ctx.get_config_pda();\r\n    let treasury = Keypair::new();\r\n    \r\n    for _ in 0..3 {\r\n        let vcoin_mint = Keypair::new();\r\n        \r\n        let ix = create_initialize_ix(\r\n            \u0026ctx.program_id,\r\n            \u0026ctx.payer.pubkey(),\r\n            \u0026config_pda,\r\n            \u0026vcoin_mint.pubkey(),\r\n            \u0026treasury.pubkey(),\r\n        );\r\n        \r\n        assert!(ix.data.len() \u003e 8);\r\n    }\r\n}\r\n\r\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","trident-tests","src","accounts_snapshots.rs"],"content":"//! Account snapshots for fuzz testing\r\n//!\r\n//! Captures account state before and after operations for invariant checking.\r\n\r\nuse anchor_lang::prelude::*;\r\nuse std::collections::HashMap;\r\n\r\n/// Snapshot of account state\r\n#[derive(Debug, Clone)]\r\npub struct AccountSnapshot {\r\n    pub pubkey: Pubkey,\r\n    pub lamports: u64,\r\n    pub data: Vec\u003cu8\u003e,\r\n    pub owner: Pubkey,\r\n}\r\n\r\n/// Snapshot of the entire test state\r\n#[derive(Debug, Clone, Default)]\r\npub struct StateSnapshot {\r\n    pub accounts: HashMap\u003cPubkey, AccountSnapshot\u003e,\r\n    pub slot: u64,\r\n    pub timestamp: i64,\r\n}\r\n\r\nimpl StateSnapshot {\r\n    pub fn new() -\u003e Self {\r\n        Self::default()\r\n    }\r\n    \r\n    /// Add an account to the snapshot\r\n    pub fn add_account(\u0026mut self, pubkey: Pubkey, lamports: u64, data: Vec\u003cu8\u003e, owner: Pubkey) {\r\n        self.accounts.insert(pubkey, AccountSnapshot {\r\n            pubkey,\r\n            lamports,\r\n            data,\r\n            owner,\r\n        });\r\n    }\r\n    \r\n    /// Get total lamports across all accounts\r\n    pub fn total_lamports(\u0026self) -\u003e u64 {\r\n        self.accounts.values().map(|a| a.lamports).sum()\r\n    }\r\n    \r\n    /// Compare with another snapshot\r\n    pub fn compare(\u0026self, other: \u0026StateSnapshot) -\u003e Vec\u003cString\u003e {\r\n        let mut differences = Vec::new();\r\n        \r\n        // Check for added accounts\r\n        for key in other.accounts.keys() {\r\n            if !self.accounts.contains_key(key) {\r\n                differences.push(format!(\"Account added: {}\", key));\r\n            }\r\n        }\r\n        \r\n        // Check for removed accounts\r\n        for key in self.accounts.keys() {\r\n            if !other.accounts.contains_key(key) {\r\n                differences.push(format!(\"Account removed: {}\", key));\r\n            }\r\n        }\r\n        \r\n        // Check for modified accounts\r\n        for (key, account) in \u0026self.accounts {\r\n            if let Some(other_account) = other.accounts.get(key) {\r\n                if account.lamports != other_account.lamports {\r\n                    differences.push(format!(\r\n                        \"Account {} lamports changed: {} -\u003e {}\",\r\n                        key, account.lamports, other_account.lamports\r\n                    ));\r\n                }\r\n                if account.data != other_account.data {\r\n                    differences.push(format!(\"Account {} data changed\", key));\r\n                }\r\n            }\r\n        }\r\n        \r\n        differences\r\n    }\r\n}\r\n\r\n/// Token balance snapshot\r\n#[derive(Debug, Clone, Default)]\r\npub struct TokenBalanceSnapshot {\r\n    pub balances: HashMap\u003cPubkey, u64\u003e,\r\n    pub total_supply: u64,\r\n}\r\n\r\nimpl TokenBalanceSnapshot {\r\n    pub fn new() -\u003e Self {\r\n        Self::default()\r\n    }\r\n    \r\n    pub fn add_balance(\u0026mut self, account: Pubkey, balance: u64) {\r\n        self.balances.insert(account, balance);\r\n    }\r\n    \r\n    pub fn total(\u0026self) -\u003e u64 {\r\n        self.balances.values().sum()\r\n    }\r\n    \r\n    /// Verify conservation of tokens\r\n    pub fn verify_conservation(\u0026self, other: \u0026TokenBalanceSnapshot) -\u003e bool {\r\n        // In a closed system, total should be conserved\r\n        // (unless minting/burning occurred)\r\n        self.total() == other.total()\r\n    }\r\n}\r\n\r\n/// Staking state snapshot\r\n#[derive(Debug, Clone, Default)]\r\npub struct StakingSnapshot {\r\n    pub total_staked: u64,\r\n    pub total_stakers: u64,\r\n    pub vault_balance: u64,\r\n    pub user_stakes: HashMap\u003cPubkey, u64\u003e,\r\n}\r\n\r\nimpl StakingSnapshot {\r\n    /// Verify staking invariants\r\n    pub fn verify_invariants(\u0026self) -\u003e Result\u003c(), String\u003e {\r\n        // Vault balance should \u003e= total staked\r\n        if self.vault_balance \u003c self.total_staked {\r\n            return Err(format!(\r\n                \"Vault {} \u003c total staked {}\",\r\n                self.vault_balance, self.total_staked\r\n            ));\r\n        }\r\n        \r\n        // Sum of user stakes should == total staked\r\n        let sum: u64 = self.user_stakes.values().sum();\r\n        if sum != self.total_staked {\r\n            return Err(format!(\r\n                \"Sum of stakes {} != total staked {}\",\r\n                sum, self.total_staked\r\n            ));\r\n        }\r\n        \r\n        // Staker count should match\r\n        let actual_stakers = self.user_stakes.values().filter(|\u0026\u0026s| s \u003e 0).count() as u64;\r\n        if actual_stakers != self.total_stakers {\r\n            return Err(format!(\r\n                \"Actual stakers {} != total stakers {}\",\r\n                actual_stakers, self.total_stakers\r\n            ));\r\n        }\r\n        \r\n        Ok(())\r\n    }\r\n}\r\n\r\n/// Governance state snapshot\r\n#[derive(Debug, Clone, Default)]\r\npub struct GovernanceSnapshot {\r\n    pub proposal_count: u64,\r\n    pub total_delegated: u64,\r\n    pub active_proposals: Vec\u003cu64\u003e,\r\n}\r\n\r\nimpl GovernanceSnapshot {\r\n    /// Verify governance invariants\r\n    pub fn verify_invariants(\u0026self) -\u003e Result\u003c(), String\u003e {\r\n        // Active proposals should be subset of all proposals\r\n        for \u0026id in \u0026self.active_proposals {\r\n            if id \u003e self.proposal_count {\r\n                return Err(format!(\r\n                    \"Active proposal {} \u003e total count {}\",\r\n                    id, self.proposal_count\r\n                ));\r\n            }\r\n        }\r\n        \r\n        Ok(())\r\n    }\r\n}\r\n\r\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","trident-tests","src","fuzz_5a.rs"],"content":"//! Fuzz target for 5A protocol\r\n\r\nuse trident_tests::fuzz_instructions::*;\r\nuse trident_tests::accounts_snapshots::*;\r\n\r\n/// Main fuzz entry point for 5A protocol\r\nfn main() {\r\n    println!(\"5A Protocol fuzz target\");\r\n    println!(\"Run with: trident fuzz run fuzz_5a\");\r\n    \r\n    // Fuzz test scenarios:\r\n    // 1. Random valid scores\r\n    // 2. Edge case scores (0, 10000)\r\n    // 3. Composite calculation verification\r\n    // 4. Reward multiplier bounds\r\n    \r\n    let test_cases = vec![\r\n        // All zeros\r\n        Fuzz5AScoreData { authenticity: 0, accuracy: 0, agility: 0, activity: 0, approved: 0 },\r\n        // All max\r\n        Fuzz5AScoreData { authenticity: 10000, accuracy: 10000, agility: 10000, activity: 10000, approved: 10000 },\r\n        // Mixed\r\n        Fuzz5AScoreData { authenticity: 8000, accuracy: 7000, agility: 6000, activity: 9000, approved: 5000 },\r\n    ];\r\n    \r\n    for (i, data) in test_cases.iter().enumerate() {\r\n        println!(\"Test case {}: composite={}, valid={}\", \r\n            i, data.composite(), data.is_valid());\r\n    }\r\n}\r\n\r\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","trident-tests","src","fuzz_governance.rs"],"content":"//! Fuzz target for governance protocol\r\n\r\nuse trident_tests::fuzz_instructions::*;\r\nuse trident_tests::accounts_snapshots::*;\r\n\r\n/// Main fuzz entry point for governance\r\nfn main() {\r\n    println!(\"Governance fuzz target\");\r\n    println!(\"Run with: trident fuzz run fuzz_governance\");\r\n    \r\n    // Fuzz test scenarios:\r\n    // 1. Random vote choices and weights\r\n    // 2. Voting power edge cases\r\n    // 3. Proposal state transitions\r\n    // 4. Delegation edge cases\r\n    // 5. Quorum calculations\r\n    // 6. Timelock scenarios\r\n    \r\n    let test_cases = vec![\r\n        // Minimum voter\r\n        FuzzVoteData { choice: 1, vevcoin_balance: 1, five_a_score: 0, tier: 0 },\r\n        // Maximum voter\r\n        FuzzVoteData { choice: 1, vevcoin_balance: u64::MAX / 2, five_a_score: 10000, tier: 4 },\r\n        // Edge case: all abstain\r\n        FuzzVoteData { choice: 3, vevcoin_balance: 1000, five_a_score: 5000, tier: 2 },\r\n    ];\r\n    \r\n    for (i, data) in test_cases.iter().enumerate() {\r\n        println!(\"Test case {}: choice={}, balance={}, score={}, tier={}, valid={}\", \r\n            i, data.choice, data.vevcoin_balance, data.five_a_score, data.tier, data.is_valid());\r\n    }\r\n}\r\n\r\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","trident-tests","src","fuzz_instructions.rs"],"content":"//! Fuzz instruction definitions\r\n//!\r\n//! Defines the instruction data types for fuzzing.\r\n\r\nuse anchor_lang::prelude::*;\r\nuse borsh::{BorshDeserialize, BorshSerialize};\r\n\r\n/// Fuzz data for staking operations\r\n#[derive(Debug, Clone, BorshSerialize, BorshDeserialize)]\r\npub struct FuzzStakeData {\r\n    pub amount: u64,\r\n    pub lock_duration: i64,\r\n}\r\n\r\nimpl FuzzStakeData {\r\n    /// Validate stake data is within bounds\r\n    pub fn is_valid(\u0026self) -\u003e bool {\r\n        // Minimum lock: 1 week\r\n        const MIN_LOCK: i64 = 7 * 24 * 60 * 60;\r\n        // Maximum lock: 4 years\r\n        const MAX_LOCK: i64 = 4 * 365 * 24 * 60 * 60;\r\n        \r\n        self.amount \u003e 0 \u0026\u0026 \r\n        self.lock_duration \u003e= MIN_LOCK \u0026\u0026 \r\n        self.lock_duration \u003c= MAX_LOCK\r\n    }\r\n}\r\n\r\n/// Fuzz data for governance voting\r\n#[derive(Debug, Clone, BorshSerialize, BorshDeserialize)]\r\npub struct FuzzVoteData {\r\n    pub choice: u8,\r\n    pub vevcoin_balance: u64,\r\n    pub five_a_score: u16,\r\n    pub tier: u8,\r\n}\r\n\r\nimpl FuzzVoteData {\r\n    /// Validate vote data is within bounds\r\n    pub fn is_valid(\u0026self) -\u003e bool {\r\n        // Choice: 1=For, 2=Against, 3=Abstain\r\n        let valid_choice = self.choice \u003e= 1 \u0026\u0026 self.choice \u003c= 3;\r\n        // 5A score: 0-10000\r\n        let valid_score = self.five_a_score \u003c= 10000;\r\n        // Tier: 0-4\r\n        let valid_tier = self.tier \u003c= 4;\r\n        \r\n        valid_choice \u0026\u0026 valid_score \u0026\u0026 valid_tier \u0026\u0026 self.vevcoin_balance \u003e 0\r\n    }\r\n}\r\n\r\n/// Fuzz data for 5A score submission\r\n#[derive(Debug, Clone, BorshSerialize, BorshDeserialize)]\r\npub struct Fuzz5AScoreData {\r\n    pub authenticity: u16,\r\n    pub accuracy: u16,\r\n    pub agility: u16,\r\n    pub activity: u16,\r\n    pub approved: u16,\r\n}\r\n\r\nimpl Fuzz5AScoreData {\r\n    /// Validate all scores are within bounds\r\n    pub fn is_valid(\u0026self) -\u003e bool {\r\n        const MAX: u16 = 10000;\r\n        self.authenticity \u003c= MAX \u0026\u0026\r\n        self.accuracy \u003c= MAX \u0026\u0026\r\n        self.agility \u003c= MAX \u0026\u0026\r\n        self.activity \u003c= MAX \u0026\u0026\r\n        self.approved \u003c= MAX\r\n    }\r\n    \r\n    /// Calculate composite score\r\n    pub fn composite(\u0026self) -\u003e u16 {\r\n        // Weights: Auth=25%, Acc=20%, Agi=15%, Act=25%, App=15%\r\n        let weighted = \r\n            self.authenticity as u32 * 2500 +\r\n            self.accuracy as u32 * 2000 +\r\n            self.agility as u32 * 1500 +\r\n            self.activity as u32 * 2500 +\r\n            self.approved as u32 * 1500;\r\n        (weighted / 10000) as u16\r\n    }\r\n}\r\n\r\n/// Fuzz data for proposal creation\r\n#[derive(Debug, Clone, BorshSerialize, BorshDeserialize)]\r\npub struct FuzzProposalData {\r\n    pub title_hash: [u8; 32],\r\n    pub proposal_type: u8,\r\n    pub enable_private_voting: bool,\r\n}\r\n\r\nimpl FuzzProposalData {\r\n    pub fn is_valid(\u0026self) -\u003e bool {\r\n        // Proposal type: 0-3\r\n        self.proposal_type \u003c= 3\r\n    }\r\n}\r\n\r\n/// Fuzz data for merkle claim\r\n#[derive(Debug, Clone, BorshSerialize, BorshDeserialize)]\r\npub struct FuzzClaimData {\r\n    pub amount: u64,\r\n    pub epoch: u64,\r\n    pub merkle_proof: Vec\u003c[u8; 32]\u003e,\r\n}\r\n\r\nimpl FuzzClaimData {\r\n    pub fn is_valid(\u0026self) -\u003e bool {\r\n        self.amount \u003e 0 \u0026\u0026 \r\n        self.epoch \u003e 0 \u0026\u0026 \r\n        self.merkle_proof.len() \u003c= 32 // Max tree depth\r\n    }\r\n}\r\n\r\n/// Fuzz instruction types\r\n#[derive(Debug, Clone)]\r\npub enum FuzzInstruction {\r\n    // Staking\r\n    Stake(FuzzStakeData),\r\n    ExtendLock { new_duration: i64 },\r\n    Unstake { amount: u64 },\r\n    \r\n    // Governance\r\n    CreateProposal(FuzzProposalData),\r\n    CastVote(FuzzVoteData),\r\n    DelegateVotes { amount: u64, delegate: Pubkey },\r\n    \r\n    // 5A Protocol\r\n    SubmitScore(Fuzz5AScoreData),\r\n    \r\n    // SSCRE\r\n    ClaimRewards(FuzzClaimData),\r\n    \r\n    // Admin\r\n    SetPaused(bool),\r\n}\r\n\r\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","trident-tests","src","fuzz_staking.rs"],"content":"//! Fuzz target for staking protocol\r\n\r\nuse trident_tests::fuzz_instructions::*;\r\nuse trident_tests::accounts_snapshots::*;\r\n\r\n/// Main fuzz entry point for staking\r\nfn main() {\r\n    println!(\"Staking fuzz target\");\r\n    println!(\"Run with: trident fuzz run fuzz_staking\");\r\n    \r\n    // Fuzz test scenarios to cover:\r\n    // 1. Random stake amounts within valid range\r\n    // 2. Random lock durations within valid range\r\n    // 3. Edge cases: minimum stake, maximum stake\r\n    // 4. Edge cases: minimum lock, maximum lock\r\n    // 5. Sequential stake -\u003e extend -\u003e unstake\r\n    // 6. Multiple users staking simultaneously\r\n    // 7. Tier boundary transitions\r\n    \r\n    let test_cases = vec![\r\n        // Minimum stake\r\n        FuzzStakeData { amount: 1, lock_duration: 7 * 24 * 60 * 60 },\r\n        // Bronze threshold\r\n        FuzzStakeData { amount: 1_000_000_000_000, lock_duration: 365 * 24 * 60 * 60 },\r\n        // Maximum lock\r\n        FuzzStakeData { amount: 100_000_000_000_000, lock_duration: 4 * 365 * 24 * 60 * 60 },\r\n    ];\r\n    \r\n    for (i, data) in test_cases.iter().enumerate() {\r\n        println!(\"Test case {}: amount={}, duration={}, valid={}\", \r\n            i, data.amount, data.lock_duration, data.is_valid());\r\n    }\r\n}\r\n\r\n","traces":[],"covered":0,"coverable":0},{"path":["D:","\\","Projects","VCoin","VCoinContract","vcoin_workspace","trident-tests","src","lib.rs"],"content":"//! # Trident Fuzz Tests for ViWoApp\r\n//!\r\n//! This module provides fuzz testing capabilities using the Trident framework.\r\n//! Fuzz testing helps discover edge cases and vulnerabilities by automatically\r\n//! generating random but valid inputs.\r\n//!\r\n//! ## Running Fuzz Tests\r\n//!\r\n//! ```bash\r\n//! # Install Trident CLI\r\n//! cargo install trident-cli\r\n//!\r\n//! # Initialize Trident in the workspace\r\n//! trident init\r\n//!\r\n//! # Run fuzz tests\r\n//! trident fuzz run fuzz_staking\r\n//! trident fuzz run fuzz_governance\r\n//! trident fuzz run fuzz_5a\r\n//!\r\n//! # Run with custom iterations\r\n//! trident fuzz run fuzz_staking --iterations 10000\r\n//!\r\n//! # Run with timeout\r\n//! trident fuzz run fuzz_staking --timeout 3600\r\n//! ```\r\n//!\r\n//! ## Fuzz Targets\r\n//!\r\n//! - `fuzz_staking`: Tests staking protocol edge cases\r\n//! - `fuzz_governance`: Tests governance voting and proposals\r\n//! - `fuzz_5a`: Tests 5A score calculations\r\n//!\r\n//! ## Invariants Checked\r\n//!\r\n//! - No arithmetic overflows\r\n//! - State consistency after operations\r\n//! - Access control enforcement\r\n//! - Balance conservation\r\n\r\npub mod fuzz_instructions;\r\npub mod accounts_snapshots;\r\n\r\n","traces":[],"covered":0,"coverable":0}]};
        var previousData = null;
    </script>
    <script crossorigin>/** @license React v16.13.1
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
'use strict';(function(d,r){"object"===typeof exports&&"undefined"!==typeof module?r(exports):"function"===typeof define&&define.amd?define(["exports"],r):(d=d||self,r(d.React={}))})(this,function(d){function r(a){for(var b="https://reactjs.org/docs/error-decoder.html?invariant="+a,c=1;c<arguments.length;c++)b+="&args[]="+encodeURIComponent(arguments[c]);return"Minified React error #"+a+"; visit "+b+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}
function w(a,b,c){this.props=a;this.context=b;this.refs=ba;this.updater=c||ca}function da(){}function L(a,b,c){this.props=a;this.context=b;this.refs=ba;this.updater=c||ca}function ea(a,b,c){var g,e={},fa=null,d=null;if(null!=b)for(g in void 0!==b.ref&&(d=b.ref),void 0!==b.key&&(fa=""+b.key),b)ha.call(b,g)&&!ia.hasOwnProperty(g)&&(e[g]=b[g]);var h=arguments.length-2;if(1===h)e.children=c;else if(1<h){for(var k=Array(h),f=0;f<h;f++)k[f]=arguments[f+2];e.children=k}if(a&&a.defaultProps)for(g in h=a.defaultProps,
h)void 0===e[g]&&(e[g]=h[g]);return{$$typeof:x,type:a,key:fa,ref:d,props:e,_owner:M.current}}function va(a,b){return{$$typeof:x,type:a.type,key:b,ref:a.ref,props:a.props,_owner:a._owner}}function N(a){return"object"===typeof a&&null!==a&&a.$$typeof===x}function wa(a){var b={"=":"=0",":":"=2"};return"$"+(""+a).replace(/[=:]/g,function(a){return b[a]})}function ja(a,b,c,g){if(C.length){var e=C.pop();e.result=a;e.keyPrefix=b;e.func=c;e.context=g;e.count=0;return e}return{result:a,keyPrefix:b,func:c,
context:g,count:0}}function ka(a){a.result=null;a.keyPrefix=null;a.func=null;a.context=null;a.count=0;10>C.length&&C.push(a)}function O(a,b,c,g){var e=typeof a;if("undefined"===e||"boolean"===e)a=null;var d=!1;if(null===a)d=!0;else switch(e){case "string":case "number":d=!0;break;case "object":switch(a.$$typeof){case x:case xa:d=!0}}if(d)return c(g,a,""===b?"."+P(a,0):b),1;d=0;b=""===b?".":b+":";if(Array.isArray(a))for(var f=0;f<a.length;f++){e=a[f];var h=b+P(e,f);d+=O(e,h,c,g)}else if(null===a||
"object"!==typeof a?h=null:(h=la&&a[la]||a["@@iterator"],h="function"===typeof h?h:null),"function"===typeof h)for(a=h.call(a),f=0;!(e=a.next()).done;)e=e.value,h=b+P(e,f++),d+=O(e,h,c,g);else if("object"===e)throw c=""+a,Error(r(31,"[object Object]"===c?"object with keys {"+Object.keys(a).join(", ")+"}":c,""));return d}function Q(a,b,c){return null==a?0:O(a,"",b,c)}function P(a,b){return"object"===typeof a&&null!==a&&null!=a.key?wa(a.key):b.toString(36)}function ya(a,b,c){a.func.call(a.context,b,
a.count++)}function za(a,b,c){var g=a.result,e=a.keyPrefix;a=a.func.call(a.context,b,a.count++);Array.isArray(a)?R(a,g,c,function(a){return a}):null!=a&&(N(a)&&(a=va(a,e+(!a.key||b&&b.key===a.key?"":(""+a.key).replace(ma,"$&/")+"/")+c)),g.push(a))}function R(a,b,c,g,e){var d="";null!=c&&(d=(""+c).replace(ma,"$&/")+"/");b=ja(b,d,g,e);Q(a,za,b);ka(b)}function t(){var a=na.current;if(null===a)throw Error(r(321));return a}function S(a,b){var c=a.length;a.push(b);a:for(;;){var g=c-1>>>1,e=a[g];if(void 0!==
e&&0<D(e,b))a[g]=b,a[c]=e,c=g;else break a}}function n(a){a=a[0];return void 0===a?null:a}function E(a){var b=a[0];if(void 0!==b){var c=a.pop();if(c!==b){a[0]=c;a:for(var g=0,e=a.length;g<e;){var d=2*(g+1)-1,f=a[d],h=d+1,k=a[h];if(void 0!==f&&0>D(f,c))void 0!==k&&0>D(k,f)?(a[g]=k,a[h]=c,g=h):(a[g]=f,a[d]=c,g=d);else if(void 0!==k&&0>D(k,c))a[g]=k,a[h]=c,g=h;else break a}}return b}return null}function D(a,b){var c=a.sortIndex-b.sortIndex;return 0!==c?c:a.id-b.id}function F(a){for(var b=n(u);null!==
b;){if(null===b.callback)E(u);else if(b.startTime<=a)E(u),b.sortIndex=b.expirationTime,S(p,b);else break;b=n(u)}}function T(a){y=!1;F(a);if(!v)if(null!==n(p))v=!0,z(U);else{var b=n(u);null!==b&&G(T,b.startTime-a)}}function U(a,b){v=!1;y&&(y=!1,V());H=!0;var c=m;try{F(b);for(l=n(p);null!==l&&(!(l.expirationTime>b)||a&&!W());){var g=l.callback;if(null!==g){l.callback=null;m=l.priorityLevel;var e=g(l.expirationTime<=b);b=q();"function"===typeof e?l.callback=e:l===n(p)&&E(p);F(b)}else E(p);l=n(p)}if(null!==
l)var d=!0;else{var f=n(u);null!==f&&G(T,f.startTime-b);d=!1}return d}finally{l=null,m=c,H=!1}}function oa(a){switch(a){case 1:return-1;case 2:return 250;case 5:return 1073741823;case 4:return 1E4;default:return 5E3}}var f="function"===typeof Symbol&&Symbol.for,x=f?Symbol.for("react.element"):60103,xa=f?Symbol.for("react.portal"):60106,Aa=f?Symbol.for("react.fragment"):60107,Ba=f?Symbol.for("react.strict_mode"):60108,Ca=f?Symbol.for("react.profiler"):60114,Da=f?Symbol.for("react.provider"):60109,
Ea=f?Symbol.for("react.context"):60110,Fa=f?Symbol.for("react.forward_ref"):60112,Ga=f?Symbol.for("react.suspense"):60113,Ha=f?Symbol.for("react.memo"):60115,Ia=f?Symbol.for("react.lazy"):60116,la="function"===typeof Symbol&&Symbol.iterator,pa=Object.getOwnPropertySymbols,Ja=Object.prototype.hasOwnProperty,Ka=Object.prototype.propertyIsEnumerable,I=function(){try{if(!Object.assign)return!1;var a=new String("abc");a[5]="de";if("5"===Object.getOwnPropertyNames(a)[0])return!1;var b={};for(a=0;10>a;a++)b["_"+
String.fromCharCode(a)]=a;if("0123456789"!==Object.getOwnPropertyNames(b).map(function(a){return b[a]}).join(""))return!1;var c={};"abcdefghijklmnopqrst".split("").forEach(function(a){c[a]=a});return"abcdefghijklmnopqrst"!==Object.keys(Object.assign({},c)).join("")?!1:!0}catch(g){return!1}}()?Object.assign:function(a,b){if(null===a||void 0===a)throw new TypeError("Object.assign cannot be called with null or undefined");var c=Object(a);for(var g,e=1;e<arguments.length;e++){var d=Object(arguments[e]);
for(var f in d)Ja.call(d,f)&&(c[f]=d[f]);if(pa){g=pa(d);for(var h=0;h<g.length;h++)Ka.call(d,g[h])&&(c[g[h]]=d[g[h]])}}return c},ca={isMounted:function(a){return!1},enqueueForceUpdate:function(a,b,c){},enqueueReplaceState:function(a,b,c,d){},enqueueSetState:function(a,b,c,d){}},ba={};w.prototype.isReactComponent={};w.prototype.setState=function(a,b){if("object"!==typeof a&&"function"!==typeof a&&null!=a)throw Error(r(85));this.updater.enqueueSetState(this,a,b,"setState")};w.prototype.forceUpdate=
function(a){this.updater.enqueueForceUpdate(this,a,"forceUpdate")};da.prototype=w.prototype;f=L.prototype=new da;f.constructor=L;I(f,w.prototype);f.isPureReactComponent=!0;var M={current:null},ha=Object.prototype.hasOwnProperty,ia={key:!0,ref:!0,__self:!0,__source:!0},ma=/\/+/g,C=[],na={current:null},X;if("undefined"===typeof window||"function"!==typeof MessageChannel){var A=null,qa=null,ra=function(){if(null!==A)try{var a=q();A(!0,a);A=null}catch(b){throw setTimeout(ra,0),b;}},La=Date.now();var q=
function(){return Date.now()-La};var z=function(a){null!==A?setTimeout(z,0,a):(A=a,setTimeout(ra,0))};var G=function(a,b){qa=setTimeout(a,b)};var V=function(){clearTimeout(qa)};var W=function(){return!1};f=X=function(){}}else{var Y=window.performance,sa=window.Date,Ma=window.setTimeout,Na=window.clearTimeout;"undefined"!==typeof console&&(f=window.cancelAnimationFrame,"function"!==typeof window.requestAnimationFrame&&console.error("This browser doesn't support requestAnimationFrame. Make sure that you load a polyfill in older browsers. https://fb.me/react-polyfills"),
"function"!==typeof f&&console.error("This browser doesn't support cancelAnimationFrame. Make sure that you load a polyfill in older browsers. https://fb.me/react-polyfills"));if("object"===typeof Y&&"function"===typeof Y.now)q=function(){return Y.now()};else{var Oa=sa.now();q=function(){return sa.now()-Oa}}var J=!1,K=null,Z=-1,ta=5,ua=0;W=function(){return q()>=ua};f=function(){};X=function(a){0>a||125<a?console.error("forceFrameRate takes a positive int between 0 and 125, forcing framerates higher than 125 fps is not unsupported"):
ta=0<a?Math.floor(1E3/a):5};var B=new MessageChannel,aa=B.port2;B.port1.onmessage=function(){if(null!==K){var a=q();ua=a+ta;try{K(!0,a)?aa.postMessage(null):(J=!1,K=null)}catch(b){throw aa.postMessage(null),b;}}else J=!1};z=function(a){K=a;J||(J=!0,aa.postMessage(null))};G=function(a,b){Z=Ma(function(){a(q())},b)};V=function(){Na(Z);Z=-1}}var p=[],u=[],Pa=1,l=null,m=3,H=!1,v=!1,y=!1,Qa=0;B={ReactCurrentDispatcher:na,ReactCurrentOwner:M,IsSomeRendererActing:{current:!1},assign:I};I(B,{Scheduler:{__proto__:null,
unstable_ImmediatePriority:1,unstable_UserBlockingPriority:2,unstable_NormalPriority:3,unstable_IdlePriority:5,unstable_LowPriority:4,unstable_runWithPriority:function(a,b){switch(a){case 1:case 2:case 3:case 4:case 5:break;default:a=3}var c=m;m=a;try{return b()}finally{m=c}},unstable_next:function(a){switch(m){case 1:case 2:case 3:var b=3;break;default:b=m}var c=m;m=b;try{return a()}finally{m=c}},unstable_scheduleCallback:function(a,b,c){var d=q();if("object"===typeof c&&null!==c){var e=c.delay;
e="number"===typeof e&&0<e?d+e:d;c="number"===typeof c.timeout?c.timeout:oa(a)}else c=oa(a),e=d;c=e+c;a={id:Pa++,callback:b,priorityLevel:a,startTime:e,expirationTime:c,sortIndex:-1};e>d?(a.sortIndex=e,S(u,a),null===n(p)&&a===n(u)&&(y?V():y=!0,G(T,e-d))):(a.sortIndex=c,S(p,a),v||H||(v=!0,z(U)));return a},unstable_cancelCallback:function(a){a.callback=null},unstable_wrapCallback:function(a){var b=m;return function(){var c=m;m=b;try{return a.apply(this,arguments)}finally{m=c}}},unstable_getCurrentPriorityLevel:function(){return m},
unstable_shouldYield:function(){var a=q();F(a);var b=n(p);return b!==l&&null!==l&&null!==b&&null!==b.callback&&b.startTime<=a&&b.expirationTime<l.expirationTime||W()},unstable_requestPaint:f,unstable_continueExecution:function(){v||H||(v=!0,z(U))},unstable_pauseExecution:function(){},unstable_getFirstCallbackNode:function(){return n(p)},get unstable_now(){return q},get unstable_forceFrameRate(){return X},unstable_Profiling:null},SchedulerTracing:{__proto__:null,__interactionsRef:null,__subscriberRef:null,
unstable_clear:function(a){return a()},unstable_getCurrent:function(){return null},unstable_getThreadID:function(){return++Qa},unstable_trace:function(a,b,c){return c()},unstable_wrap:function(a){return a},unstable_subscribe:function(a){},unstable_unsubscribe:function(a){}}});d.Children={map:function(a,b,c){if(null==a)return a;var d=[];R(a,d,null,b,c);return d},forEach:function(a,b,c){if(null==a)return a;b=ja(null,null,b,c);Q(a,ya,b);ka(b)},count:function(a){return Q(a,function(){return null},null)},
toArray:function(a){var b=[];R(a,b,null,function(a){return a});return b},only:function(a){if(!N(a))throw Error(r(143));return a}};d.Component=w;d.Fragment=Aa;d.Profiler=Ca;d.PureComponent=L;d.StrictMode=Ba;d.Suspense=Ga;d.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=B;d.cloneElement=function(a,b,c){if(null===a||void 0===a)throw Error(r(267,a));var d=I({},a.props),e=a.key,f=a.ref,m=a._owner;if(null!=b){void 0!==b.ref&&(f=b.ref,m=M.current);void 0!==b.key&&(e=""+b.key);if(a.type&&a.type.defaultProps)var h=
a.type.defaultProps;for(k in b)ha.call(b,k)&&!ia.hasOwnProperty(k)&&(d[k]=void 0===b[k]&&void 0!==h?h[k]:b[k])}var k=arguments.length-2;if(1===k)d.children=c;else if(1<k){h=Array(k);for(var l=0;l<k;l++)h[l]=arguments[l+2];d.children=h}return{$$typeof:x,type:a.type,key:e,ref:f,props:d,_owner:m}};d.createContext=function(a,b){void 0===b&&(b=null);a={$$typeof:Ea,_calculateChangedBits:b,_currentValue:a,_currentValue2:a,_threadCount:0,Provider:null,Consumer:null};a.Provider={$$typeof:Da,_context:a};return a.Consumer=
a};d.createElement=ea;d.createFactory=function(a){var b=ea.bind(null,a);b.type=a;return b};d.createRef=function(){return{current:null}};d.forwardRef=function(a){return{$$typeof:Fa,render:a}};d.isValidElement=N;d.lazy=function(a){return{$$typeof:Ia,_ctor:a,_status:-1,_result:null}};d.memo=function(a,b){return{$$typeof:Ha,type:a,compare:void 0===b?null:b}};d.useCallback=function(a,b){return t().useCallback(a,b)};d.useContext=function(a,b){return t().useContext(a,b)};d.useDebugValue=function(a,b){};
d.useEffect=function(a,b){return t().useEffect(a,b)};d.useImperativeHandle=function(a,b,c){return t().useImperativeHandle(a,b,c)};d.useLayoutEffect=function(a,b){return t().useLayoutEffect(a,b)};d.useMemo=function(a,b){return t().useMemo(a,b)};d.useReducer=function(a,b,c){return t().useReducer(a,b,c)};d.useRef=function(a){return t().useRef(a)};d.useState=function(a){return t().useState(a)};d.version="16.13.1"});
</script>
    <script crossorigin>/** @license React v16.13.1
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
/*
 Modernizr 3.0.0pre (Custom Build) | MIT
*/
'use strict';(function(I,ea){"object"===typeof exports&&"undefined"!==typeof module?ea(exports,require("react")):"function"===typeof define&&define.amd?define(["exports","react"],ea):(I=I||self,ea(I.ReactDOM={},I.React))})(this,function(I,ea){function k(a){for(var b="https://reactjs.org/docs/error-decoder.html?invariant="+a,c=1;c<arguments.length;c++)b+="&args[]="+encodeURIComponent(arguments[c]);return"Minified React error #"+a+"; visit "+b+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}
function ji(a,b,c,d,e,f,g,h,m){yb=!1;gc=null;ki.apply(li,arguments)}function mi(a,b,c,d,e,f,g,h,m){ji.apply(this,arguments);if(yb){if(yb){var n=gc;yb=!1;gc=null}else throw Error(k(198));hc||(hc=!0,pd=n)}}function lf(a,b,c){var d=a.type||"unknown-event";a.currentTarget=mf(c);mi(d,b,void 0,a);a.currentTarget=null}function nf(){if(ic)for(var a in cb){var b=cb[a],c=ic.indexOf(a);if(!(-1<c))throw Error(k(96,a));if(!jc[c]){if(!b.extractEvents)throw Error(k(97,a));jc[c]=b;c=b.eventTypes;for(var d in c){var e=
void 0;var f=c[d],g=b,h=d;if(qd.hasOwnProperty(h))throw Error(k(99,h));qd[h]=f;var m=f.phasedRegistrationNames;if(m){for(e in m)m.hasOwnProperty(e)&&of(m[e],g,h);e=!0}else f.registrationName?(of(f.registrationName,g,h),e=!0):e=!1;if(!e)throw Error(k(98,d,a));}}}}function of(a,b,c){if(db[a])throw Error(k(100,a));db[a]=b;rd[a]=b.eventTypes[c].dependencies}function pf(a){var b=!1,c;for(c in a)if(a.hasOwnProperty(c)){var d=a[c];if(!cb.hasOwnProperty(c)||cb[c]!==d){if(cb[c])throw Error(k(102,c));cb[c]=
d;b=!0}}b&&nf()}function qf(a){if(a=rf(a)){if("function"!==typeof sd)throw Error(k(280));var b=a.stateNode;b&&(b=td(b),sd(a.stateNode,a.type,b))}}function sf(a){eb?fb?fb.push(a):fb=[a]:eb=a}function tf(){if(eb){var a=eb,b=fb;fb=eb=null;qf(a);if(b)for(a=0;a<b.length;a++)qf(b[a])}}function ud(){if(null!==eb||null!==fb)vd(),tf()}function uf(a,b,c){if(wd)return a(b,c);wd=!0;try{return vf(a,b,c)}finally{wd=!1,ud()}}function ni(a){if(wf.call(xf,a))return!0;if(wf.call(yf,a))return!1;if(oi.test(a))return xf[a]=
!0;yf[a]=!0;return!1}function pi(a,b,c,d){if(null!==c&&0===c.type)return!1;switch(typeof b){case "function":case "symbol":return!0;case "boolean":if(d)return!1;if(null!==c)return!c.acceptsBooleans;a=a.toLowerCase().slice(0,5);return"data-"!==a&&"aria-"!==a;default:return!1}}function qi(a,b,c,d){if(null===b||"undefined"===typeof b||pi(a,b,c,d))return!0;if(d)return!1;if(null!==c)switch(c.type){case 3:return!b;case 4:return!1===b;case 5:return isNaN(b);case 6:return isNaN(b)||1>b}return!1}function L(a,
b,c,d,e,f){this.acceptsBooleans=2===b||3===b||4===b;this.attributeName=d;this.attributeNamespace=e;this.mustUseProperty=c;this.propertyName=a;this.type=b;this.sanitizeURL=f}function xd(a,b,c,d){var e=E.hasOwnProperty(b)?E[b]:null;var f=null!==e?0===e.type:d?!1:!(2<b.length)||"o"!==b[0]&&"O"!==b[0]||"n"!==b[1]&&"N"!==b[1]?!1:!0;f||(qi(b,c,e,d)&&(c=null),d||null===e?ni(b)&&(null===c?a.removeAttribute(b):a.setAttribute(b,""+c)):e.mustUseProperty?a[e.propertyName]=null===c?3===e.type?!1:"":c:(b=e.attributeName,
d=e.attributeNamespace,null===c?a.removeAttribute(b):(e=e.type,c=3===e||4===e&&!0===c?"":""+c,d?a.setAttributeNS(d,b,c):a.setAttribute(b,c))))}function zb(a){if(null===a||"object"!==typeof a)return null;a=zf&&a[zf]||a["@@iterator"];return"function"===typeof a?a:null}function ri(a){if(-1===a._status){a._status=0;var b=a._ctor;b=b();a._result=b;b.then(function(b){0===a._status&&(b=b.default,a._status=1,a._result=b)},function(b){0===a._status&&(a._status=2,a._result=b)})}}function na(a){if(null==a)return null;
if("function"===typeof a)return a.displayName||a.name||null;if("string"===typeof a)return a;switch(a){case Ma:return"Fragment";case gb:return"Portal";case kc:return"Profiler";case Af:return"StrictMode";case lc:return"Suspense";case yd:return"SuspenseList"}if("object"===typeof a)switch(a.$$typeof){case Bf:return"Context.Consumer";case Cf:return"Context.Provider";case zd:var b=a.render;b=b.displayName||b.name||"";return a.displayName||(""!==b?"ForwardRef("+b+")":"ForwardRef");case Ad:return na(a.type);
case Df:return na(a.render);case Ef:if(a=1===a._status?a._result:null)return na(a)}return null}function Bd(a){var b="";do{a:switch(a.tag){case 3:case 4:case 6:case 7:case 10:case 9:var c="";break a;default:var d=a._debugOwner,e=a._debugSource,f=na(a.type);c=null;d&&(c=na(d.type));d=f;f="";e?f=" (at "+e.fileName.replace(si,"")+":"+e.lineNumber+")":c&&(f=" (created by "+c+")");c="\n    in "+(d||"Unknown")+f}b+=c;a=a.return}while(a);return b}function va(a){switch(typeof a){case "boolean":case "number":case "object":case "string":case "undefined":return a;
default:return""}}function Ff(a){var b=a.type;return(a=a.nodeName)&&"input"===a.toLowerCase()&&("checkbox"===b||"radio"===b)}function ti(a){var b=Ff(a)?"checked":"value",c=Object.getOwnPropertyDescriptor(a.constructor.prototype,b),d=""+a[b];if(!a.hasOwnProperty(b)&&"undefined"!==typeof c&&"function"===typeof c.get&&"function"===typeof c.set){var e=c.get,f=c.set;Object.defineProperty(a,b,{configurable:!0,get:function(){return e.call(this)},set:function(a){d=""+a;f.call(this,a)}});Object.defineProperty(a,
b,{enumerable:c.enumerable});return{getValue:function(){return d},setValue:function(a){d=""+a},stopTracking:function(){a._valueTracker=null;delete a[b]}}}}function mc(a){a._valueTracker||(a._valueTracker=ti(a))}function Gf(a){if(!a)return!1;var b=a._valueTracker;if(!b)return!0;var c=b.getValue();var d="";a&&(d=Ff(a)?a.checked?"true":"false":a.value);a=d;return a!==c?(b.setValue(a),!0):!1}function Cd(a,b){var c=b.checked;return M({},b,{defaultChecked:void 0,defaultValue:void 0,value:void 0,checked:null!=
c?c:a._wrapperState.initialChecked})}function Hf(a,b){var c=null==b.defaultValue?"":b.defaultValue,d=null!=b.checked?b.checked:b.defaultChecked;c=va(null!=b.value?b.value:c);a._wrapperState={initialChecked:d,initialValue:c,controlled:"checkbox"===b.type||"radio"===b.type?null!=b.checked:null!=b.value}}function If(a,b){b=b.checked;null!=b&&xd(a,"checked",b,!1)}function Dd(a,b){If(a,b);var c=va(b.value),d=b.type;if(null!=c)if("number"===d){if(0===c&&""===a.value||a.value!=c)a.value=""+c}else a.value!==
""+c&&(a.value=""+c);else if("submit"===d||"reset"===d){a.removeAttribute("value");return}b.hasOwnProperty("value")?Ed(a,b.type,c):b.hasOwnProperty("defaultValue")&&Ed(a,b.type,va(b.defaultValue));null==b.checked&&null!=b.defaultChecked&&(a.defaultChecked=!!b.defaultChecked)}function Jf(a,b,c){if(b.hasOwnProperty("value")||b.hasOwnProperty("defaultValue")){var d=b.type;if(!("submit"!==d&&"reset"!==d||void 0!==b.value&&null!==b.value))return;b=""+a._wrapperState.initialValue;c||b===a.value||(a.value=
b);a.defaultValue=b}c=a.name;""!==c&&(a.name="");a.defaultChecked=!!a._wrapperState.initialChecked;""!==c&&(a.name=c)}function Ed(a,b,c){if("number"!==b||a.ownerDocument.activeElement!==a)null==c?a.defaultValue=""+a._wrapperState.initialValue:a.defaultValue!==""+c&&(a.defaultValue=""+c)}function ui(a){var b="";ea.Children.forEach(a,function(a){null!=a&&(b+=a)});return b}function Fd(a,b){a=M({children:void 0},b);if(b=ui(b.children))a.children=b;return a}function hb(a,b,c,d){a=a.options;if(b){b={};
for(var e=0;e<c.length;e++)b["$"+c[e]]=!0;for(c=0;c<a.length;c++)e=b.hasOwnProperty("$"+a[c].value),a[c].selected!==e&&(a[c].selected=e),e&&d&&(a[c].defaultSelected=!0)}else{c=""+va(c);b=null;for(e=0;e<a.length;e++){if(a[e].value===c){a[e].selected=!0;d&&(a[e].defaultSelected=!0);return}null!==b||a[e].disabled||(b=a[e])}null!==b&&(b.selected=!0)}}function Gd(a,b){if(null!=b.dangerouslySetInnerHTML)throw Error(k(91));return M({},b,{value:void 0,defaultValue:void 0,children:""+a._wrapperState.initialValue})}
function Kf(a,b){var c=b.value;if(null==c){c=b.children;b=b.defaultValue;if(null!=c){if(null!=b)throw Error(k(92));if(Array.isArray(c)){if(!(1>=c.length))throw Error(k(93));c=c[0]}b=c}null==b&&(b="");c=b}a._wrapperState={initialValue:va(c)}}function Lf(a,b){var c=va(b.value),d=va(b.defaultValue);null!=c&&(c=""+c,c!==a.value&&(a.value=c),null==b.defaultValue&&a.defaultValue!==c&&(a.defaultValue=c));null!=d&&(a.defaultValue=""+d)}function Mf(a,b){b=a.textContent;b===a._wrapperState.initialValue&&""!==
b&&null!==b&&(a.value=b)}function Nf(a){switch(a){case "svg":return"http://www.w3.org/2000/svg";case "math":return"http://www.w3.org/1998/Math/MathML";default:return"http://www.w3.org/1999/xhtml"}}function Hd(a,b){return null==a||"http://www.w3.org/1999/xhtml"===a?Nf(b):"http://www.w3.org/2000/svg"===a&&"foreignObject"===b?"http://www.w3.org/1999/xhtml":a}function nc(a,b){var c={};c[a.toLowerCase()]=b.toLowerCase();c["Webkit"+a]="webkit"+b;c["Moz"+a]="moz"+b;return c}function oc(a){if(Id[a])return Id[a];
if(!ib[a])return a;var b=ib[a],c;for(c in b)if(b.hasOwnProperty(c)&&c in Of)return Id[a]=b[c];return a}function Jd(a){var b=Pf.get(a);void 0===b&&(b=new Map,Pf.set(a,b));return b}function Na(a){var b=a,c=a;if(a.alternate)for(;b.return;)b=b.return;else{a=b;do b=a,0!==(b.effectTag&1026)&&(c=b.return),a=b.return;while(a)}return 3===b.tag?c:null}function Qf(a){if(13===a.tag){var b=a.memoizedState;null===b&&(a=a.alternate,null!==a&&(b=a.memoizedState));if(null!==b)return b.dehydrated}return null}function Rf(a){if(Na(a)!==
a)throw Error(k(188));}function vi(a){var b=a.alternate;if(!b){b=Na(a);if(null===b)throw Error(k(188));return b!==a?null:a}for(var c=a,d=b;;){var e=c.return;if(null===e)break;var f=e.alternate;if(null===f){d=e.return;if(null!==d){c=d;continue}break}if(e.child===f.child){for(f=e.child;f;){if(f===c)return Rf(e),a;if(f===d)return Rf(e),b;f=f.sibling}throw Error(k(188));}if(c.return!==d.return)c=e,d=f;else{for(var g=!1,h=e.child;h;){if(h===c){g=!0;c=e;d=f;break}if(h===d){g=!0;d=e;c=f;break}h=h.sibling}if(!g){for(h=
f.child;h;){if(h===c){g=!0;c=f;d=e;break}if(h===d){g=!0;d=f;c=e;break}h=h.sibling}if(!g)throw Error(k(189));}}if(c.alternate!==d)throw Error(k(190));}if(3!==c.tag)throw Error(k(188));return c.stateNode.current===c?a:b}function Sf(a){a=vi(a);if(!a)return null;for(var b=a;;){if(5===b.tag||6===b.tag)return b;if(b.child)b.child.return=b,b=b.child;else{if(b===a)break;for(;!b.sibling;){if(!b.return||b.return===a)return null;b=b.return}b.sibling.return=b.return;b=b.sibling}}return null}function jb(a,b){if(null==
b)throw Error(k(30));if(null==a)return b;if(Array.isArray(a)){if(Array.isArray(b))return a.push.apply(a,b),a;a.push(b);return a}return Array.isArray(b)?[a].concat(b):[a,b]}function Kd(a,b,c){Array.isArray(a)?a.forEach(b,c):a&&b.call(c,a)}function pc(a){null!==a&&(Ab=jb(Ab,a));a=Ab;Ab=null;if(a){Kd(a,wi);if(Ab)throw Error(k(95));if(hc)throw a=pd,hc=!1,pd=null,a;}}function Ld(a){a=a.target||a.srcElement||window;a.correspondingUseElement&&(a=a.correspondingUseElement);return 3===a.nodeType?a.parentNode:
a}function Tf(a){if(!wa)return!1;a="on"+a;var b=a in document;b||(b=document.createElement("div"),b.setAttribute(a,"return;"),b="function"===typeof b[a]);return b}function Uf(a){a.topLevelType=null;a.nativeEvent=null;a.targetInst=null;a.ancestors.length=0;10>qc.length&&qc.push(a)}function Vf(a,b,c,d){if(qc.length){var e=qc.pop();e.topLevelType=a;e.eventSystemFlags=d;e.nativeEvent=b;e.targetInst=c;return e}return{topLevelType:a,eventSystemFlags:d,nativeEvent:b,targetInst:c,ancestors:[]}}function Wf(a){var b=
a.targetInst,c=b;do{if(!c){a.ancestors.push(c);break}var d=c;if(3===d.tag)d=d.stateNode.containerInfo;else{for(;d.return;)d=d.return;d=3!==d.tag?null:d.stateNode.containerInfo}if(!d)break;b=c.tag;5!==b&&6!==b||a.ancestors.push(c);c=Bb(d)}while(c);for(c=0;c<a.ancestors.length;c++){b=a.ancestors[c];var e=Ld(a.nativeEvent);d=a.topLevelType;var f=a.nativeEvent,g=a.eventSystemFlags;0===c&&(g|=64);for(var h=null,m=0;m<jc.length;m++){var n=jc[m];n&&(n=n.extractEvents(d,b,f,e,g))&&(h=jb(h,n))}pc(h)}}function Md(a,
b,c){if(!c.has(a)){switch(a){case "scroll":Cb(b,"scroll",!0);break;case "focus":case "blur":Cb(b,"focus",!0);Cb(b,"blur",!0);c.set("blur",null);c.set("focus",null);break;case "cancel":case "close":Tf(a)&&Cb(b,a,!0);break;case "invalid":case "submit":case "reset":break;default:-1===Db.indexOf(a)&&w(a,b)}c.set(a,null)}}function xi(a,b){var c=Jd(b);Nd.forEach(function(a){Md(a,b,c)});yi.forEach(function(a){Md(a,b,c)})}function Od(a,b,c,d,e){return{blockedOn:a,topLevelType:b,eventSystemFlags:c|32,nativeEvent:e,
container:d}}function Xf(a,b){switch(a){case "focus":case "blur":xa=null;break;case "dragenter":case "dragleave":ya=null;break;case "mouseover":case "mouseout":za=null;break;case "pointerover":case "pointerout":Eb.delete(b.pointerId);break;case "gotpointercapture":case "lostpointercapture":Fb.delete(b.pointerId)}}function Gb(a,b,c,d,e,f){if(null===a||a.nativeEvent!==f)return a=Od(b,c,d,e,f),null!==b&&(b=Hb(b),null!==b&&Yf(b)),a;a.eventSystemFlags|=d;return a}function zi(a,b,c,d,e){switch(b){case "focus":return xa=
Gb(xa,a,b,c,d,e),!0;case "dragenter":return ya=Gb(ya,a,b,c,d,e),!0;case "mouseover":return za=Gb(za,a,b,c,d,e),!0;case "pointerover":var f=e.pointerId;Eb.set(f,Gb(Eb.get(f)||null,a,b,c,d,e));return!0;case "gotpointercapture":return f=e.pointerId,Fb.set(f,Gb(Fb.get(f)||null,a,b,c,d,e)),!0}return!1}function Ai(a){var b=Bb(a.target);if(null!==b){var c=Na(b);if(null!==c)if(b=c.tag,13===b){if(b=Qf(c),null!==b){a.blockedOn=b;Pd(a.priority,function(){Bi(c)});return}}else if(3===b&&c.stateNode.hydrate){a.blockedOn=
3===c.tag?c.stateNode.containerInfo:null;return}}a.blockedOn=null}function rc(a){if(null!==a.blockedOn)return!1;var b=Qd(a.topLevelType,a.eventSystemFlags,a.container,a.nativeEvent);if(null!==b){var c=Hb(b);null!==c&&Yf(c);a.blockedOn=b;return!1}return!0}function Zf(a,b,c){rc(a)&&c.delete(b)}function Ci(){for(Rd=!1;0<fa.length;){var a=fa[0];if(null!==a.blockedOn){a=Hb(a.blockedOn);null!==a&&Di(a);break}var b=Qd(a.topLevelType,a.eventSystemFlags,a.container,a.nativeEvent);null!==b?a.blockedOn=b:fa.shift()}null!==
xa&&rc(xa)&&(xa=null);null!==ya&&rc(ya)&&(ya=null);null!==za&&rc(za)&&(za=null);Eb.forEach(Zf);Fb.forEach(Zf)}function Ib(a,b){a.blockedOn===b&&(a.blockedOn=null,Rd||(Rd=!0,$f(ag,Ci)))}function bg(a){if(0<fa.length){Ib(fa[0],a);for(var b=1;b<fa.length;b++){var c=fa[b];c.blockedOn===a&&(c.blockedOn=null)}}null!==xa&&Ib(xa,a);null!==ya&&Ib(ya,a);null!==za&&Ib(za,a);b=function(b){return Ib(b,a)};Eb.forEach(b);Fb.forEach(b);for(b=0;b<Jb.length;b++)c=Jb[b],c.blockedOn===a&&(c.blockedOn=null);for(;0<Jb.length&&
(b=Jb[0],null===b.blockedOn);)Ai(b),null===b.blockedOn&&Jb.shift()}function Sd(a,b){for(var c=0;c<a.length;c+=2){var d=a[c],e=a[c+1],f="on"+(e[0].toUpperCase()+e.slice(1));f={phasedRegistrationNames:{bubbled:f,captured:f+"Capture"},dependencies:[d],eventPriority:b};Td.set(d,b);cg.set(d,f);dg[e]=f}}function w(a,b){Cb(b,a,!1)}function Cb(a,b,c){var d=Td.get(b);switch(void 0===d?2:d){case 0:d=Ei.bind(null,b,1,a);break;case 1:d=Fi.bind(null,b,1,a);break;default:d=sc.bind(null,b,1,a)}c?a.addEventListener(b,
d,!0):a.addEventListener(b,d,!1)}function Ei(a,b,c,d){Oa||vd();var e=sc,f=Oa;Oa=!0;try{eg(e,a,b,c,d)}finally{(Oa=f)||ud()}}function Fi(a,b,c,d){Gi(Hi,sc.bind(null,a,b,c,d))}function sc(a,b,c,d){if(tc)if(0<fa.length&&-1<Nd.indexOf(a))a=Od(null,a,b,c,d),fa.push(a);else{var e=Qd(a,b,c,d);if(null===e)Xf(a,d);else if(-1<Nd.indexOf(a))a=Od(e,a,b,c,d),fa.push(a);else if(!zi(e,a,b,c,d)){Xf(a,d);a=Vf(a,d,null,b);try{uf(Wf,a)}finally{Uf(a)}}}}function Qd(a,b,c,d){c=Ld(d);c=Bb(c);if(null!==c){var e=Na(c);if(null===
e)c=null;else{var f=e.tag;if(13===f){c=Qf(e);if(null!==c)return c;c=null}else if(3===f){if(e.stateNode.hydrate)return 3===e.tag?e.stateNode.containerInfo:null;c=null}else e!==c&&(c=null)}}a=Vf(a,d,c,b);try{uf(Wf,a)}finally{Uf(a)}return null}function fg(a,b,c){return null==b||"boolean"===typeof b||""===b?"":c||"number"!==typeof b||0===b||Kb.hasOwnProperty(a)&&Kb[a]?(""+b).trim():b+"px"}function gg(a,b){a=a.style;for(var c in b)if(b.hasOwnProperty(c)){var d=0===c.indexOf("--"),e=fg(c,b[c],d);"float"===
c&&(c="cssFloat");d?a.setProperty(c,e):a[c]=e}}function Ud(a,b){if(b){if(Ii[a]&&(null!=b.children||null!=b.dangerouslySetInnerHTML))throw Error(k(137,a,""));if(null!=b.dangerouslySetInnerHTML){if(null!=b.children)throw Error(k(60));if(!("object"===typeof b.dangerouslySetInnerHTML&&"__html"in b.dangerouslySetInnerHTML))throw Error(k(61));}if(null!=b.style&&"object"!==typeof b.style)throw Error(k(62,""));}}function Vd(a,b){if(-1===a.indexOf("-"))return"string"===typeof b.is;switch(a){case "annotation-xml":case "color-profile":case "font-face":case "font-face-src":case "font-face-uri":case "font-face-format":case "font-face-name":case "missing-glyph":return!1;
default:return!0}}function oa(a,b){a=9===a.nodeType||11===a.nodeType?a:a.ownerDocument;var c=Jd(a);b=rd[b];for(var d=0;d<b.length;d++)Md(b[d],a,c)}function uc(){}function Wd(a){a=a||("undefined"!==typeof document?document:void 0);if("undefined"===typeof a)return null;try{return a.activeElement||a.body}catch(b){return a.body}}function hg(a){for(;a&&a.firstChild;)a=a.firstChild;return a}function ig(a,b){var c=hg(a);a=0;for(var d;c;){if(3===c.nodeType){d=a+c.textContent.length;if(a<=b&&d>=b)return{node:c,
offset:b-a};a=d}a:{for(;c;){if(c.nextSibling){c=c.nextSibling;break a}c=c.parentNode}c=void 0}c=hg(c)}}function jg(a,b){return a&&b?a===b?!0:a&&3===a.nodeType?!1:b&&3===b.nodeType?jg(a,b.parentNode):"contains"in a?a.contains(b):a.compareDocumentPosition?!!(a.compareDocumentPosition(b)&16):!1:!1}function kg(){for(var a=window,b=Wd();b instanceof a.HTMLIFrameElement;){try{var c="string"===typeof b.contentWindow.location.href}catch(d){c=!1}if(c)a=b.contentWindow;else break;b=Wd(a.document)}return b}
function Xd(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return b&&("input"===b&&("text"===a.type||"search"===a.type||"tel"===a.type||"url"===a.type||"password"===a.type)||"textarea"===b||"true"===a.contentEditable)}function lg(a,b){switch(a){case "button":case "input":case "select":case "textarea":return!!b.autoFocus}return!1}function Yd(a,b){return"textarea"===a||"option"===a||"noscript"===a||"string"===typeof b.children||"number"===typeof b.children||"object"===typeof b.dangerouslySetInnerHTML&&
null!==b.dangerouslySetInnerHTML&&null!=b.dangerouslySetInnerHTML.__html}function kb(a){for(;null!=a;a=a.nextSibling){var b=a.nodeType;if(1===b||3===b)break}return a}function mg(a){a=a.previousSibling;for(var b=0;a;){if(8===a.nodeType){var c=a.data;if(c===ng||c===Zd||c===$d){if(0===b)return a;b--}else c===og&&b++}a=a.previousSibling}return null}function Bb(a){var b=a[Aa];if(b)return b;for(var c=a.parentNode;c;){if(b=c[Lb]||c[Aa]){c=b.alternate;if(null!==b.child||null!==c&&null!==c.child)for(a=mg(a);null!==
a;){if(c=a[Aa])return c;a=mg(a)}return b}a=c;c=a.parentNode}return null}function Hb(a){a=a[Aa]||a[Lb];return!a||5!==a.tag&&6!==a.tag&&13!==a.tag&&3!==a.tag?null:a}function Pa(a){if(5===a.tag||6===a.tag)return a.stateNode;throw Error(k(33));}function ae(a){return a[vc]||null}function pa(a){do a=a.return;while(a&&5!==a.tag);return a?a:null}function pg(a,b){var c=a.stateNode;if(!c)return null;var d=td(c);if(!d)return null;c=d[b];a:switch(b){case "onClick":case "onClickCapture":case "onDoubleClick":case "onDoubleClickCapture":case "onMouseDown":case "onMouseDownCapture":case "onMouseMove":case "onMouseMoveCapture":case "onMouseUp":case "onMouseUpCapture":case "onMouseEnter":(d=
!d.disabled)||(a=a.type,d=!("button"===a||"input"===a||"select"===a||"textarea"===a));a=!d;break a;default:a=!1}if(a)return null;if(c&&"function"!==typeof c)throw Error(k(231,b,typeof c));return c}function qg(a,b,c){if(b=pg(a,c.dispatchConfig.phasedRegistrationNames[b]))c._dispatchListeners=jb(c._dispatchListeners,b),c._dispatchInstances=jb(c._dispatchInstances,a)}function Ji(a){if(a&&a.dispatchConfig.phasedRegistrationNames){for(var b=a._targetInst,c=[];b;)c.push(b),b=pa(b);for(b=c.length;0<b--;)qg(c[b],
"captured",a);for(b=0;b<c.length;b++)qg(c[b],"bubbled",a)}}function be(a,b,c){a&&c&&c.dispatchConfig.registrationName&&(b=pg(a,c.dispatchConfig.registrationName))&&(c._dispatchListeners=jb(c._dispatchListeners,b),c._dispatchInstances=jb(c._dispatchInstances,a))}function Ki(a){a&&a.dispatchConfig.registrationName&&be(a._targetInst,null,a)}function lb(a){Kd(a,Ji)}function rg(){if(wc)return wc;var a,b=ce,c=b.length,d,e="value"in Ba?Ba.value:Ba.textContent,f=e.length;for(a=0;a<c&&b[a]===e[a];a++);var g=
c-a;for(d=1;d<=g&&b[c-d]===e[f-d];d++);return wc=e.slice(a,1<d?1-d:void 0)}function xc(){return!0}function yc(){return!1}function R(a,b,c,d){this.dispatchConfig=a;this._targetInst=b;this.nativeEvent=c;a=this.constructor.Interface;for(var e in a)a.hasOwnProperty(e)&&((b=a[e])?this[e]=b(c):"target"===e?this.target=d:this[e]=c[e]);this.isDefaultPrevented=(null!=c.defaultPrevented?c.defaultPrevented:!1===c.returnValue)?xc:yc;this.isPropagationStopped=yc;return this}function Li(a,b,c,d){if(this.eventPool.length){var e=
this.eventPool.pop();this.call(e,a,b,c,d);return e}return new this(a,b,c,d)}function Mi(a){if(!(a instanceof this))throw Error(k(279));a.destructor();10>this.eventPool.length&&this.eventPool.push(a)}function sg(a){a.eventPool=[];a.getPooled=Li;a.release=Mi}function tg(a,b){switch(a){case "keyup":return-1!==Ni.indexOf(b.keyCode);case "keydown":return 229!==b.keyCode;case "keypress":case "mousedown":case "blur":return!0;default:return!1}}function ug(a){a=a.detail;return"object"===typeof a&&"data"in
a?a.data:null}function Oi(a,b){switch(a){case "compositionend":return ug(b);case "keypress":if(32!==b.which)return null;vg=!0;return wg;case "textInput":return a=b.data,a===wg&&vg?null:a;default:return null}}function Pi(a,b){if(mb)return"compositionend"===a||!de&&tg(a,b)?(a=rg(),wc=ce=Ba=null,mb=!1,a):null;switch(a){case "paste":return null;case "keypress":if(!(b.ctrlKey||b.altKey||b.metaKey)||b.ctrlKey&&b.altKey){if(b.char&&1<b.char.length)return b.char;if(b.which)return String.fromCharCode(b.which)}return null;
case "compositionend":return xg&&"ko"!==b.locale?null:b.data;default:return null}}function yg(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return"input"===b?!!Qi[a.type]:"textarea"===b?!0:!1}function zg(a,b,c){a=R.getPooled(Ag.change,a,b,c);a.type="change";sf(c);lb(a);return a}function Ri(a){pc(a)}function zc(a){var b=Pa(a);if(Gf(b))return a}function Si(a,b){if("change"===a)return b}function Bg(){Mb&&(Mb.detachEvent("onpropertychange",Cg),Nb=Mb=null)}function Cg(a){if("value"===a.propertyName&&
zc(Nb))if(a=zg(Nb,a,Ld(a)),Oa)pc(a);else{Oa=!0;try{ee(Ri,a)}finally{Oa=!1,ud()}}}function Ti(a,b,c){"focus"===a?(Bg(),Mb=b,Nb=c,Mb.attachEvent("onpropertychange",Cg)):"blur"===a&&Bg()}function Ui(a,b){if("selectionchange"===a||"keyup"===a||"keydown"===a)return zc(Nb)}function Vi(a,b){if("click"===a)return zc(b)}function Wi(a,b){if("input"===a||"change"===a)return zc(b)}function Xi(a){var b=this.nativeEvent;return b.getModifierState?b.getModifierState(a):(a=Yi[a])?!!b[a]:!1}function fe(a){return Xi}
function Zi(a,b){return a===b&&(0!==a||1/a===1/b)||a!==a&&b!==b}function Ob(a,b){if(Qa(a,b))return!0;if("object"!==typeof a||null===a||"object"!==typeof b||null===b)return!1;var c=Object.keys(a),d=Object.keys(b);if(c.length!==d.length)return!1;for(d=0;d<c.length;d++)if(!$i.call(b,c[d])||!Qa(a[c[d]],b[c[d]]))return!1;return!0}function Dg(a,b){var c=b.window===b?b.document:9===b.nodeType?b:b.ownerDocument;if(ge||null==nb||nb!==Wd(c))return null;c=nb;"selectionStart"in c&&Xd(c)?c={start:c.selectionStart,
end:c.selectionEnd}:(c=(c.ownerDocument&&c.ownerDocument.defaultView||window).getSelection(),c={anchorNode:c.anchorNode,anchorOffset:c.anchorOffset,focusNode:c.focusNode,focusOffset:c.focusOffset});return Pb&&Ob(Pb,c)?null:(Pb=c,a=R.getPooled(Eg.select,he,a,b),a.type="select",a.target=nb,lb(a),a)}function Ac(a){var b=a.keyCode;"charCode"in a?(a=a.charCode,0===a&&13===b&&(a=13)):a=b;10===a&&(a=13);return 32<=a||13===a?a:0}function q(a,b){0>ob||(a.current=ie[ob],ie[ob]=null,ob--)}function y(a,b,c){ob++;
ie[ob]=a.current;a.current=b}function pb(a,b){var c=a.type.contextTypes;if(!c)return Ca;var d=a.stateNode;if(d&&d.__reactInternalMemoizedUnmaskedChildContext===b)return d.__reactInternalMemoizedMaskedChildContext;var e={},f;for(f in c)e[f]=b[f];d&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=b,a.__reactInternalMemoizedMaskedChildContext=e);return e}function N(a){a=a.childContextTypes;return null!==a&&void 0!==a}function Fg(a,b,c){if(B.current!==Ca)throw Error(k(168));y(B,b);y(G,c)}
function Gg(a,b,c){var d=a.stateNode;a=b.childContextTypes;if("function"!==typeof d.getChildContext)return c;d=d.getChildContext();for(var e in d)if(!(e in a))throw Error(k(108,na(b)||"Unknown",e));return M({},c,{},d)}function Bc(a){a=(a=a.stateNode)&&a.__reactInternalMemoizedMergedChildContext||Ca;Ra=B.current;y(B,a);y(G,G.current);return!0}function Hg(a,b,c){var d=a.stateNode;if(!d)throw Error(k(169));c?(a=Gg(a,b,Ra),d.__reactInternalMemoizedMergedChildContext=a,q(G),q(B),y(B,a)):q(G);y(G,c)}function Cc(){switch(aj()){case Dc:return 99;
case Ig:return 98;case Jg:return 97;case Kg:return 96;case Lg:return 95;default:throw Error(k(332));}}function Mg(a){switch(a){case 99:return Dc;case 98:return Ig;case 97:return Jg;case 96:return Kg;case 95:return Lg;default:throw Error(k(332));}}function Da(a,b){a=Mg(a);return bj(a,b)}function Ng(a,b,c){a=Mg(a);return je(a,b,c)}function Og(a){null===qa?(qa=[a],Ec=je(Dc,Pg)):qa.push(a);return Qg}function ha(){if(null!==Ec){var a=Ec;Ec=null;Rg(a)}Pg()}function Pg(){if(!ke&&null!==qa){ke=!0;var a=0;
try{var b=qa;Da(99,function(){for(;a<b.length;a++){var c=b[a];do c=c(!0);while(null!==c)}});qa=null}catch(c){throw null!==qa&&(qa=qa.slice(a+1)),je(Dc,ha),c;}finally{ke=!1}}}function Fc(a,b,c){c/=10;return 1073741821-(((1073741821-a+b/10)/c|0)+1)*c}function aa(a,b){if(a&&a.defaultProps){b=M({},b);a=a.defaultProps;for(var c in a)void 0===b[c]&&(b[c]=a[c])}return b}function le(){Gc=qb=Hc=null}function me(a){var b=Ic.current;q(Ic);a.type._context._currentValue=b}function Sg(a,b){for(;null!==a;){var c=
a.alternate;if(a.childExpirationTime<b)a.childExpirationTime=b,null!==c&&c.childExpirationTime<b&&(c.childExpirationTime=b);else if(null!==c&&c.childExpirationTime<b)c.childExpirationTime=b;else break;a=a.return}}function rb(a,b){Hc=a;Gc=qb=null;a=a.dependencies;null!==a&&null!==a.firstContext&&(a.expirationTime>=b&&(ia=!0),a.firstContext=null)}function W(a,b){if(Gc!==a&&!1!==b&&0!==b){if("number"!==typeof b||1073741823===b)Gc=a,b=1073741823;b={context:a,observedBits:b,next:null};if(null===qb){if(null===
Hc)throw Error(k(308));qb=b;Hc.dependencies={expirationTime:0,firstContext:b,responders:null}}else qb=qb.next=b}return a._currentValue}function ne(a){a.updateQueue={baseState:a.memoizedState,baseQueue:null,shared:{pending:null},effects:null}}function oe(a,b){a=a.updateQueue;b.updateQueue===a&&(b.updateQueue={baseState:a.baseState,baseQueue:a.baseQueue,shared:a.shared,effects:a.effects})}function Ea(a,b){a={expirationTime:a,suspenseConfig:b,tag:Tg,payload:null,callback:null,next:null};return a.next=
a}function Fa(a,b){a=a.updateQueue;if(null!==a){a=a.shared;var c=a.pending;null===c?b.next=b:(b.next=c.next,c.next=b);a.pending=b}}function Ug(a,b){var c=a.alternate;null!==c&&oe(c,a);a=a.updateQueue;c=a.baseQueue;null===c?(a.baseQueue=b.next=b,b.next=b):(b.next=c.next,c.next=b)}function Qb(a,b,c,d){var e=a.updateQueue;Ga=!1;var f=e.baseQueue,g=e.shared.pending;if(null!==g){if(null!==f){var h=f.next;f.next=g.next;g.next=h}f=g;e.shared.pending=null;h=a.alternate;null!==h&&(h=h.updateQueue,null!==h&&
(h.baseQueue=g))}if(null!==f){h=f.next;var m=e.baseState,n=0,k=null,ba=null,l=null;if(null!==h){var p=h;do{g=p.expirationTime;if(g<d){var t={expirationTime:p.expirationTime,suspenseConfig:p.suspenseConfig,tag:p.tag,payload:p.payload,callback:p.callback,next:null};null===l?(ba=l=t,k=m):l=l.next=t;g>n&&(n=g)}else{null!==l&&(l=l.next={expirationTime:1073741823,suspenseConfig:p.suspenseConfig,tag:p.tag,payload:p.payload,callback:p.callback,next:null});Vg(g,p.suspenseConfig);a:{var q=a,r=p;g=b;t=c;switch(r.tag){case 1:q=
r.payload;if("function"===typeof q){m=q.call(t,m,g);break a}m=q;break a;case 3:q.effectTag=q.effectTag&-4097|64;case Tg:q=r.payload;g="function"===typeof q?q.call(t,m,g):q;if(null===g||void 0===g)break a;m=M({},m,g);break a;case Jc:Ga=!0}}null!==p.callback&&(a.effectTag|=32,g=e.effects,null===g?e.effects=[p]:g.push(p))}p=p.next;if(null===p||p===h)if(g=e.shared.pending,null===g)break;else p=f.next=g.next,g.next=h,e.baseQueue=f=g,e.shared.pending=null}while(1)}null===l?k=m:l.next=ba;e.baseState=k;e.baseQueue=
l;Kc(n);a.expirationTime=n;a.memoizedState=m}}function Wg(a,b,c){a=b.effects;b.effects=null;if(null!==a)for(b=0;b<a.length;b++){var d=a[b],e=d.callback;if(null!==e){d.callback=null;d=e;e=c;if("function"!==typeof d)throw Error(k(191,d));d.call(e)}}}function Lc(a,b,c,d){b=a.memoizedState;c=c(d,b);c=null===c||void 0===c?b:M({},b,c);a.memoizedState=c;0===a.expirationTime&&(a.updateQueue.baseState=c)}function Xg(a,b,c,d,e,f,g){a=a.stateNode;return"function"===typeof a.shouldComponentUpdate?a.shouldComponentUpdate(d,
f,g):b.prototype&&b.prototype.isPureReactComponent?!Ob(c,d)||!Ob(e,f):!0}function Yg(a,b,c){var d=!1,e=Ca;var f=b.contextType;"object"===typeof f&&null!==f?f=W(f):(e=N(b)?Ra:B.current,d=b.contextTypes,f=(d=null!==d&&void 0!==d)?pb(a,e):Ca);b=new b(c,f);a.memoizedState=null!==b.state&&void 0!==b.state?b.state:null;b.updater=Mc;a.stateNode=b;b._reactInternalFiber=a;d&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=e,a.__reactInternalMemoizedMaskedChildContext=f);return b}function Zg(a,
b,c,d){a=b.state;"function"===typeof b.componentWillReceiveProps&&b.componentWillReceiveProps(c,d);"function"===typeof b.UNSAFE_componentWillReceiveProps&&b.UNSAFE_componentWillReceiveProps(c,d);b.state!==a&&Mc.enqueueReplaceState(b,b.state,null)}function pe(a,b,c,d){var e=a.stateNode;e.props=c;e.state=a.memoizedState;e.refs=$g;ne(a);var f=b.contextType;"object"===typeof f&&null!==f?e.context=W(f):(f=N(b)?Ra:B.current,e.context=pb(a,f));Qb(a,c,e,d);e.state=a.memoizedState;f=b.getDerivedStateFromProps;
"function"===typeof f&&(Lc(a,b,f,c),e.state=a.memoizedState);"function"===typeof b.getDerivedStateFromProps||"function"===typeof e.getSnapshotBeforeUpdate||"function"!==typeof e.UNSAFE_componentWillMount&&"function"!==typeof e.componentWillMount||(b=e.state,"function"===typeof e.componentWillMount&&e.componentWillMount(),"function"===typeof e.UNSAFE_componentWillMount&&e.UNSAFE_componentWillMount(),b!==e.state&&Mc.enqueueReplaceState(e,e.state,null),Qb(a,c,e,d),e.state=a.memoizedState);"function"===
typeof e.componentDidMount&&(a.effectTag|=4)}function Rb(a,b,c){a=c.ref;if(null!==a&&"function"!==typeof a&&"object"!==typeof a){if(c._owner){c=c._owner;if(c){if(1!==c.tag)throw Error(k(309));var d=c.stateNode}if(!d)throw Error(k(147,a));var e=""+a;if(null!==b&&null!==b.ref&&"function"===typeof b.ref&&b.ref._stringRef===e)return b.ref;b=function(a){var b=d.refs;b===$g&&(b=d.refs={});null===a?delete b[e]:b[e]=a};b._stringRef=e;return b}if("string"!==typeof a)throw Error(k(284));if(!c._owner)throw Error(k(290,
a));}return a}function Nc(a,b){if("textarea"!==a.type)throw Error(k(31,"[object Object]"===Object.prototype.toString.call(b)?"object with keys {"+Object.keys(b).join(", ")+"}":b,""));}function ah(a){function b(b,c){if(a){var d=b.lastEffect;null!==d?(d.nextEffect=c,b.lastEffect=c):b.firstEffect=b.lastEffect=c;c.nextEffect=null;c.effectTag=8}}function c(c,d){if(!a)return null;for(;null!==d;)b(c,d),d=d.sibling;return null}function d(a,b){for(a=new Map;null!==b;)null!==b.key?a.set(b.key,b):a.set(b.index,
b),b=b.sibling;return a}function e(a,b){a=Sa(a,b);a.index=0;a.sibling=null;return a}function f(b,c,d){b.index=d;if(!a)return c;d=b.alternate;if(null!==d)return d=d.index,d<c?(b.effectTag=2,c):d;b.effectTag=2;return c}function g(b){a&&null===b.alternate&&(b.effectTag=2);return b}function h(a,b,c,d){if(null===b||6!==b.tag)return b=qe(c,a.mode,d),b.return=a,b;b=e(b,c);b.return=a;return b}function m(a,b,c,d){if(null!==b&&b.elementType===c.type)return d=e(b,c.props),d.ref=Rb(a,b,c),d.return=a,d;d=Oc(c.type,
c.key,c.props,null,a.mode,d);d.ref=Rb(a,b,c);d.return=a;return d}function n(a,b,c,d){if(null===b||4!==b.tag||b.stateNode.containerInfo!==c.containerInfo||b.stateNode.implementation!==c.implementation)return b=re(c,a.mode,d),b.return=a,b;b=e(b,c.children||[]);b.return=a;return b}function l(a,b,c,d,f){if(null===b||7!==b.tag)return b=Ha(c,a.mode,d,f),b.return=a,b;b=e(b,c);b.return=a;return b}function ba(a,b,c){if("string"===typeof b||"number"===typeof b)return b=qe(""+b,a.mode,c),b.return=a,b;if("object"===
typeof b&&null!==b){switch(b.$$typeof){case Pc:return c=Oc(b.type,b.key,b.props,null,a.mode,c),c.ref=Rb(a,null,b),c.return=a,c;case gb:return b=re(b,a.mode,c),b.return=a,b}if(Qc(b)||zb(b))return b=Ha(b,a.mode,c,null),b.return=a,b;Nc(a,b)}return null}function p(a,b,c,d){var e=null!==b?b.key:null;if("string"===typeof c||"number"===typeof c)return null!==e?null:h(a,b,""+c,d);if("object"===typeof c&&null!==c){switch(c.$$typeof){case Pc:return c.key===e?c.type===Ma?l(a,b,c.props.children,d,e):m(a,b,c,
d):null;case gb:return c.key===e?n(a,b,c,d):null}if(Qc(c)||zb(c))return null!==e?null:l(a,b,c,d,null);Nc(a,c)}return null}function t(a,b,c,d,e){if("string"===typeof d||"number"===typeof d)return a=a.get(c)||null,h(b,a,""+d,e);if("object"===typeof d&&null!==d){switch(d.$$typeof){case Pc:return a=a.get(null===d.key?c:d.key)||null,d.type===Ma?l(b,a,d.props.children,e,d.key):m(b,a,d,e);case gb:return a=a.get(null===d.key?c:d.key)||null,n(b,a,d,e)}if(Qc(d)||zb(d))return a=a.get(c)||null,l(b,a,d,e,null);
Nc(b,d)}return null}function q(e,g,h,m){for(var n=null,k=null,l=g,r=g=0,C=null;null!==l&&r<h.length;r++){l.index>r?(C=l,l=null):C=l.sibling;var O=p(e,l,h[r],m);if(null===O){null===l&&(l=C);break}a&&l&&null===O.alternate&&b(e,l);g=f(O,g,r);null===k?n=O:k.sibling=O;k=O;l=C}if(r===h.length)return c(e,l),n;if(null===l){for(;r<h.length;r++)l=ba(e,h[r],m),null!==l&&(g=f(l,g,r),null===k?n=l:k.sibling=l,k=l);return n}for(l=d(e,l);r<h.length;r++)C=t(l,e,r,h[r],m),null!==C&&(a&&null!==C.alternate&&l.delete(null===
C.key?r:C.key),g=f(C,g,r),null===k?n=C:k.sibling=C,k=C);a&&l.forEach(function(a){return b(e,a)});return n}function w(e,g,h,n){var m=zb(h);if("function"!==typeof m)throw Error(k(150));h=m.call(h);if(null==h)throw Error(k(151));for(var l=m=null,r=g,C=g=0,O=null,v=h.next();null!==r&&!v.done;C++,v=h.next()){r.index>C?(O=r,r=null):O=r.sibling;var q=p(e,r,v.value,n);if(null===q){null===r&&(r=O);break}a&&r&&null===q.alternate&&b(e,r);g=f(q,g,C);null===l?m=q:l.sibling=q;l=q;r=O}if(v.done)return c(e,r),m;
if(null===r){for(;!v.done;C++,v=h.next())v=ba(e,v.value,n),null!==v&&(g=f(v,g,C),null===l?m=v:l.sibling=v,l=v);return m}for(r=d(e,r);!v.done;C++,v=h.next())v=t(r,e,C,v.value,n),null!==v&&(a&&null!==v.alternate&&r.delete(null===v.key?C:v.key),g=f(v,g,C),null===l?m=v:l.sibling=v,l=v);a&&r.forEach(function(a){return b(e,a)});return m}return function(a,d,f,h){var m="object"===typeof f&&null!==f&&f.type===Ma&&null===f.key;m&&(f=f.props.children);var n="object"===typeof f&&null!==f;if(n)switch(f.$$typeof){case Pc:a:{n=
f.key;for(m=d;null!==m;){if(m.key===n){switch(m.tag){case 7:if(f.type===Ma){c(a,m.sibling);d=e(m,f.props.children);d.return=a;a=d;break a}break;default:if(m.elementType===f.type){c(a,m.sibling);d=e(m,f.props);d.ref=Rb(a,m,f);d.return=a;a=d;break a}}c(a,m);break}else b(a,m);m=m.sibling}f.type===Ma?(d=Ha(f.props.children,a.mode,h,f.key),d.return=a,a=d):(h=Oc(f.type,f.key,f.props,null,a.mode,h),h.ref=Rb(a,d,f),h.return=a,a=h)}return g(a);case gb:a:{for(m=f.key;null!==d;){if(d.key===m)if(4===d.tag&&d.stateNode.containerInfo===
f.containerInfo&&d.stateNode.implementation===f.implementation){c(a,d.sibling);d=e(d,f.children||[]);d.return=a;a=d;break a}else{c(a,d);break}else b(a,d);d=d.sibling}d=re(f,a.mode,h);d.return=a;a=d}return g(a)}if("string"===typeof f||"number"===typeof f)return f=""+f,null!==d&&6===d.tag?(c(a,d.sibling),d=e(d,f),d.return=a,a=d):(c(a,d),d=qe(f,a.mode,h),d.return=a,a=d),g(a);if(Qc(f))return q(a,d,f,h);if(zb(f))return w(a,d,f,h);n&&Nc(a,f);if("undefined"===typeof f&&!m)switch(a.tag){case 1:case 0:throw a=
a.type,Error(k(152,a.displayName||a.name||"Component"));}return c(a,d)}}function Ta(a){if(a===Sb)throw Error(k(174));return a}function se(a,b){y(Tb,b);y(Ub,a);y(ja,Sb);a=b.nodeType;switch(a){case 9:case 11:b=(b=b.documentElement)?b.namespaceURI:Hd(null,"");break;default:a=8===a?b.parentNode:b,b=a.namespaceURI||null,a=a.tagName,b=Hd(b,a)}q(ja);y(ja,b)}function tb(a){q(ja);q(Ub);q(Tb)}function bh(a){Ta(Tb.current);var b=Ta(ja.current);var c=Hd(b,a.type);b!==c&&(y(Ub,a),y(ja,c))}function te(a){Ub.current===
a&&(q(ja),q(Ub))}function Rc(a){for(var b=a;null!==b;){if(13===b.tag){var c=b.memoizedState;if(null!==c&&(c=c.dehydrated,null===c||c.data===$d||c.data===Zd))return b}else if(19===b.tag&&void 0!==b.memoizedProps.revealOrder){if(0!==(b.effectTag&64))return b}else if(null!==b.child){b.child.return=b;b=b.child;continue}if(b===a)break;for(;null===b.sibling;){if(null===b.return||b.return===a)return null;b=b.return}b.sibling.return=b.return;b=b.sibling}return null}function ue(a,b){return{responder:a,props:b}}
function S(){throw Error(k(321));}function ve(a,b){if(null===b)return!1;for(var c=0;c<b.length&&c<a.length;c++)if(!Qa(a[c],b[c]))return!1;return!0}function we(a,b,c,d,e,f){Ia=f;z=b;b.memoizedState=null;b.updateQueue=null;b.expirationTime=0;Sc.current=null===a||null===a.memoizedState?dj:ej;a=c(d,e);if(b.expirationTime===Ia){f=0;do{b.expirationTime=0;if(!(25>f))throw Error(k(301));f+=1;J=K=null;b.updateQueue=null;Sc.current=fj;a=c(d,e)}while(b.expirationTime===Ia)}Sc.current=Tc;b=null!==K&&null!==K.next;
Ia=0;J=K=z=null;Uc=!1;if(b)throw Error(k(300));return a}function ub(){var a={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};null===J?z.memoizedState=J=a:J=J.next=a;return J}function vb(){if(null===K){var a=z.alternate;a=null!==a?a.memoizedState:null}else a=K.next;var b=null===J?z.memoizedState:J.next;if(null!==b)J=b,K=a;else{if(null===a)throw Error(k(310));K=a;a={memoizedState:K.memoizedState,baseState:K.baseState,baseQueue:K.baseQueue,queue:K.queue,next:null};null===J?z.memoizedState=
J=a:J=J.next=a}return J}function Ua(a,b){return"function"===typeof b?b(a):b}function Vc(a,b,c){b=vb();c=b.queue;if(null===c)throw Error(k(311));c.lastRenderedReducer=a;var d=K,e=d.baseQueue,f=c.pending;if(null!==f){if(null!==e){var g=e.next;e.next=f.next;f.next=g}d.baseQueue=e=f;c.pending=null}if(null!==e){e=e.next;d=d.baseState;var h=g=f=null,m=e;do{var n=m.expirationTime;if(n<Ia){var l={expirationTime:m.expirationTime,suspenseConfig:m.suspenseConfig,action:m.action,eagerReducer:m.eagerReducer,eagerState:m.eagerState,
next:null};null===h?(g=h=l,f=d):h=h.next=l;n>z.expirationTime&&(z.expirationTime=n,Kc(n))}else null!==h&&(h=h.next={expirationTime:1073741823,suspenseConfig:m.suspenseConfig,action:m.action,eagerReducer:m.eagerReducer,eagerState:m.eagerState,next:null}),Vg(n,m.suspenseConfig),d=m.eagerReducer===a?m.eagerState:a(d,m.action);m=m.next}while(null!==m&&m!==e);null===h?f=d:h.next=g;Qa(d,b.memoizedState)||(ia=!0);b.memoizedState=d;b.baseState=f;b.baseQueue=h;c.lastRenderedState=d}return[b.memoizedState,
c.dispatch]}function Wc(a,b,c){b=vb();c=b.queue;if(null===c)throw Error(k(311));c.lastRenderedReducer=a;var d=c.dispatch,e=c.pending,f=b.memoizedState;if(null!==e){c.pending=null;var g=e=e.next;do f=a(f,g.action),g=g.next;while(g!==e);Qa(f,b.memoizedState)||(ia=!0);b.memoizedState=f;null===b.baseQueue&&(b.baseState=f);c.lastRenderedState=f}return[f,d]}function xe(a){var b=ub();"function"===typeof a&&(a=a());b.memoizedState=b.baseState=a;a=b.queue={pending:null,dispatch:null,lastRenderedReducer:Ua,
lastRenderedState:a};a=a.dispatch=ch.bind(null,z,a);return[b.memoizedState,a]}function ye(a,b,c,d){a={tag:a,create:b,destroy:c,deps:d,next:null};b=z.updateQueue;null===b?(b={lastEffect:null},z.updateQueue=b,b.lastEffect=a.next=a):(c=b.lastEffect,null===c?b.lastEffect=a.next=a:(d=c.next,c.next=a,a.next=d,b.lastEffect=a));return a}function dh(a){return vb().memoizedState}function ze(a,b,c,d){var e=ub();z.effectTag|=a;e.memoizedState=ye(1|b,c,void 0,void 0===d?null:d)}function Ae(a,b,c,d){var e=vb();
d=void 0===d?null:d;var f=void 0;if(null!==K){var g=K.memoizedState;f=g.destroy;if(null!==d&&ve(d,g.deps)){ye(b,c,f,d);return}}z.effectTag|=a;e.memoizedState=ye(1|b,c,f,d)}function eh(a,b){return ze(516,4,a,b)}function Xc(a,b){return Ae(516,4,a,b)}function fh(a,b){return Ae(4,2,a,b)}function gh(a,b){if("function"===typeof b)return a=a(),b(a),function(){b(null)};if(null!==b&&void 0!==b)return a=a(),b.current=a,function(){b.current=null}}function hh(a,b,c){c=null!==c&&void 0!==c?c.concat([a]):null;
return Ae(4,2,gh.bind(null,b,a),c)}function Be(a,b){}function ih(a,b){ub().memoizedState=[a,void 0===b?null:b];return a}function Yc(a,b){var c=vb();b=void 0===b?null:b;var d=c.memoizedState;if(null!==d&&null!==b&&ve(b,d[1]))return d[0];c.memoizedState=[a,b];return a}function jh(a,b){var c=vb();b=void 0===b?null:b;var d=c.memoizedState;if(null!==d&&null!==b&&ve(b,d[1]))return d[0];a=a();c.memoizedState=[a,b];return a}function Ce(a,b,c){var d=Cc();Da(98>d?98:d,function(){a(!0)});Da(97<d?97:d,function(){var d=
X.suspense;X.suspense=void 0===b?null:b;try{a(!1),c()}finally{X.suspense=d}})}function ch(a,b,c){var d=ka(),e=Vb.suspense;d=Va(d,a,e);e={expirationTime:d,suspenseConfig:e,action:c,eagerReducer:null,eagerState:null,next:null};var f=b.pending;null===f?e.next=e:(e.next=f.next,f.next=e);b.pending=e;f=a.alternate;if(a===z||null!==f&&f===z)Uc=!0,e.expirationTime=Ia,z.expirationTime=Ia;else{if(0===a.expirationTime&&(null===f||0===f.expirationTime)&&(f=b.lastRenderedReducer,null!==f))try{var g=b.lastRenderedState,
h=f(g,c);e.eagerReducer=f;e.eagerState=h;if(Qa(h,g))return}catch(m){}finally{}Ja(a,d)}}function kh(a,b){var c=la(5,null,null,0);c.elementType="DELETED";c.type="DELETED";c.stateNode=b;c.return=a;c.effectTag=8;null!==a.lastEffect?(a.lastEffect.nextEffect=c,a.lastEffect=c):a.firstEffect=a.lastEffect=c}function lh(a,b){switch(a.tag){case 5:var c=a.type;b=1!==b.nodeType||c.toLowerCase()!==b.nodeName.toLowerCase()?null:b;return null!==b?(a.stateNode=b,!0):!1;case 6:return b=""===a.pendingProps||3!==b.nodeType?
null:b,null!==b?(a.stateNode=b,!0):!1;case 13:return!1;default:return!1}}function De(a){if(Wa){var b=Ka;if(b){var c=b;if(!lh(a,b)){b=kb(c.nextSibling);if(!b||!lh(a,b)){a.effectTag=a.effectTag&-1025|2;Wa=!1;ra=a;return}kh(ra,c)}ra=a;Ka=kb(b.firstChild)}else a.effectTag=a.effectTag&-1025|2,Wa=!1,ra=a}}function mh(a){for(a=a.return;null!==a&&5!==a.tag&&3!==a.tag&&13!==a.tag;)a=a.return;ra=a}function Zc(a){if(a!==ra)return!1;if(!Wa)return mh(a),Wa=!0,!1;var b=a.type;if(5!==a.tag||"head"!==b&&"body"!==
b&&!Yd(b,a.memoizedProps))for(b=Ka;b;)kh(a,b),b=kb(b.nextSibling);mh(a);if(13===a.tag){a=a.memoizedState;a=null!==a?a.dehydrated:null;if(!a)throw Error(k(317));a:{a=a.nextSibling;for(b=0;a;){if(8===a.nodeType){var c=a.data;if(c===og){if(0===b){Ka=kb(a.nextSibling);break a}b--}else c!==ng&&c!==Zd&&c!==$d||b++}a=a.nextSibling}Ka=null}}else Ka=ra?kb(a.stateNode.nextSibling):null;return!0}function Ee(){Ka=ra=null;Wa=!1}function T(a,b,c,d){b.child=null===a?Fe(b,null,c,d):wb(b,a.child,c,d)}function nh(a,
b,c,d,e){c=c.render;var f=b.ref;rb(b,e);d=we(a,b,c,d,f,e);if(null!==a&&!ia)return b.updateQueue=a.updateQueue,b.effectTag&=-517,a.expirationTime<=e&&(a.expirationTime=0),sa(a,b,e);b.effectTag|=1;T(a,b,d,e);return b.child}function oh(a,b,c,d,e,f){if(null===a){var g=c.type;if("function"===typeof g&&!Ge(g)&&void 0===g.defaultProps&&null===c.compare&&void 0===c.defaultProps)return b.tag=15,b.type=g,ph(a,b,g,d,e,f);a=Oc(c.type,null,d,null,b.mode,f);a.ref=b.ref;a.return=b;return b.child=a}g=a.child;if(e<
f&&(e=g.memoizedProps,c=c.compare,c=null!==c?c:Ob,c(e,d)&&a.ref===b.ref))return sa(a,b,f);b.effectTag|=1;a=Sa(g,d);a.ref=b.ref;a.return=b;return b.child=a}function ph(a,b,c,d,e,f){return null!==a&&Ob(a.memoizedProps,d)&&a.ref===b.ref&&(ia=!1,e<f)?(b.expirationTime=a.expirationTime,sa(a,b,f)):He(a,b,c,d,f)}function qh(a,b){var c=b.ref;if(null===a&&null!==c||null!==a&&a.ref!==c)b.effectTag|=128}function He(a,b,c,d,e){var f=N(c)?Ra:B.current;f=pb(b,f);rb(b,e);c=we(a,b,c,d,f,e);if(null!==a&&!ia)return b.updateQueue=
a.updateQueue,b.effectTag&=-517,a.expirationTime<=e&&(a.expirationTime=0),sa(a,b,e);b.effectTag|=1;T(a,b,c,e);return b.child}function rh(a,b,c,d,e){if(N(c)){var f=!0;Bc(b)}else f=!1;rb(b,e);if(null===b.stateNode)null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2),Yg(b,c,d),pe(b,c,d,e),d=!0;else if(null===a){var g=b.stateNode,h=b.memoizedProps;g.props=h;var m=g.context,n=c.contextType;"object"===typeof n&&null!==n?n=W(n):(n=N(c)?Ra:B.current,n=pb(b,n));var l=c.getDerivedStateFromProps,k="function"===
typeof l||"function"===typeof g.getSnapshotBeforeUpdate;k||"function"!==typeof g.UNSAFE_componentWillReceiveProps&&"function"!==typeof g.componentWillReceiveProps||(h!==d||m!==n)&&Zg(b,g,d,n);Ga=!1;var p=b.memoizedState;g.state=p;Qb(b,d,g,e);m=b.memoizedState;h!==d||p!==m||G.current||Ga?("function"===typeof l&&(Lc(b,c,l,d),m=b.memoizedState),(h=Ga||Xg(b,c,h,d,p,m,n))?(k||"function"!==typeof g.UNSAFE_componentWillMount&&"function"!==typeof g.componentWillMount||("function"===typeof g.componentWillMount&&
g.componentWillMount(),"function"===typeof g.UNSAFE_componentWillMount&&g.UNSAFE_componentWillMount()),"function"===typeof g.componentDidMount&&(b.effectTag|=4)):("function"===typeof g.componentDidMount&&(b.effectTag|=4),b.memoizedProps=d,b.memoizedState=m),g.props=d,g.state=m,g.context=n,d=h):("function"===typeof g.componentDidMount&&(b.effectTag|=4),d=!1)}else g=b.stateNode,oe(a,b),h=b.memoizedProps,g.props=b.type===b.elementType?h:aa(b.type,h),m=g.context,n=c.contextType,"object"===typeof n&&null!==
n?n=W(n):(n=N(c)?Ra:B.current,n=pb(b,n)),l=c.getDerivedStateFromProps,(k="function"===typeof l||"function"===typeof g.getSnapshotBeforeUpdate)||"function"!==typeof g.UNSAFE_componentWillReceiveProps&&"function"!==typeof g.componentWillReceiveProps||(h!==d||m!==n)&&Zg(b,g,d,n),Ga=!1,m=b.memoizedState,g.state=m,Qb(b,d,g,e),p=b.memoizedState,h!==d||m!==p||G.current||Ga?("function"===typeof l&&(Lc(b,c,l,d),p=b.memoizedState),(l=Ga||Xg(b,c,h,d,m,p,n))?(k||"function"!==typeof g.UNSAFE_componentWillUpdate&&
"function"!==typeof g.componentWillUpdate||("function"===typeof g.componentWillUpdate&&g.componentWillUpdate(d,p,n),"function"===typeof g.UNSAFE_componentWillUpdate&&g.UNSAFE_componentWillUpdate(d,p,n)),"function"===typeof g.componentDidUpdate&&(b.effectTag|=4),"function"===typeof g.getSnapshotBeforeUpdate&&(b.effectTag|=256)):("function"!==typeof g.componentDidUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=4),"function"!==typeof g.getSnapshotBeforeUpdate||h===a.memoizedProps&&m===
a.memoizedState||(b.effectTag|=256),b.memoizedProps=d,b.memoizedState=p),g.props=d,g.state=p,g.context=n,d=l):("function"!==typeof g.componentDidUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=4),"function"!==typeof g.getSnapshotBeforeUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=256),d=!1);return Ie(a,b,c,d,f,e)}function Ie(a,b,c,d,e,f){qh(a,b);var g=0!==(b.effectTag&64);if(!d&&!g)return e&&Hg(b,c,!1),sa(a,b,f);d=b.stateNode;gj.current=b;var h=g&&"function"!==typeof c.getDerivedStateFromError?
null:d.render();b.effectTag|=1;null!==a&&g?(b.child=wb(b,a.child,null,f),b.child=wb(b,null,h,f)):T(a,b,h,f);b.memoizedState=d.state;e&&Hg(b,c,!0);return b.child}function sh(a){var b=a.stateNode;b.pendingContext?Fg(a,b.pendingContext,b.pendingContext!==b.context):b.context&&Fg(a,b.context,!1);se(a,b.containerInfo)}function th(a,b,c){var d=b.mode,e=b.pendingProps,f=D.current,g=!1,h;(h=0!==(b.effectTag&64))||(h=0!==(f&2)&&(null===a||null!==a.memoizedState));h?(g=!0,b.effectTag&=-65):null!==a&&null===
a.memoizedState||void 0===e.fallback||!0===e.unstable_avoidThisFallback||(f|=1);y(D,f&1);if(null===a){void 0!==e.fallback&&De(b);if(g){g=e.fallback;e=Ha(null,d,0,null);e.return=b;if(0===(b.mode&2))for(a=null!==b.memoizedState?b.child.child:b.child,e.child=a;null!==a;)a.return=e,a=a.sibling;c=Ha(g,d,c,null);c.return=b;e.sibling=c;b.memoizedState=Je;b.child=e;return c}d=e.children;b.memoizedState=null;return b.child=Fe(b,null,d,c)}if(null!==a.memoizedState){a=a.child;d=a.sibling;if(g){e=e.fallback;
c=Sa(a,a.pendingProps);c.return=b;if(0===(b.mode&2)&&(g=null!==b.memoizedState?b.child.child:b.child,g!==a.child))for(c.child=g;null!==g;)g.return=c,g=g.sibling;d=Sa(d,e);d.return=b;c.sibling=d;c.childExpirationTime=0;b.memoizedState=Je;b.child=c;return d}c=wb(b,a.child,e.children,c);b.memoizedState=null;return b.child=c}a=a.child;if(g){g=e.fallback;e=Ha(null,d,0,null);e.return=b;e.child=a;null!==a&&(a.return=e);if(0===(b.mode&2))for(a=null!==b.memoizedState?b.child.child:b.child,e.child=a;null!==
a;)a.return=e,a=a.sibling;c=Ha(g,d,c,null);c.return=b;e.sibling=c;c.effectTag|=2;e.childExpirationTime=0;b.memoizedState=Je;b.child=e;return c}b.memoizedState=null;return b.child=wb(b,a,e.children,c)}function uh(a,b){a.expirationTime<b&&(a.expirationTime=b);var c=a.alternate;null!==c&&c.expirationTime<b&&(c.expirationTime=b);Sg(a.return,b)}function Ke(a,b,c,d,e,f){var g=a.memoizedState;null===g?a.memoizedState={isBackwards:b,rendering:null,renderingStartTime:0,last:d,tail:c,tailExpiration:0,tailMode:e,
lastEffect:f}:(g.isBackwards=b,g.rendering=null,g.renderingStartTime=0,g.last=d,g.tail=c,g.tailExpiration=0,g.tailMode=e,g.lastEffect=f)}function vh(a,b,c){var d=b.pendingProps,e=d.revealOrder,f=d.tail;T(a,b,d.children,c);d=D.current;if(0!==(d&2))d=d&1|2,b.effectTag|=64;else{if(null!==a&&0!==(a.effectTag&64))a:for(a=b.child;null!==a;){if(13===a.tag)null!==a.memoizedState&&uh(a,c);else if(19===a.tag)uh(a,c);else if(null!==a.child){a.child.return=a;a=a.child;continue}if(a===b)break a;for(;null===a.sibling;){if(null===
a.return||a.return===b)break a;a=a.return}a.sibling.return=a.return;a=a.sibling}d&=1}y(D,d);if(0===(b.mode&2))b.memoizedState=null;else switch(e){case "forwards":c=b.child;for(e=null;null!==c;)a=c.alternate,null!==a&&null===Rc(a)&&(e=c),c=c.sibling;c=e;null===c?(e=b.child,b.child=null):(e=c.sibling,c.sibling=null);Ke(b,!1,e,c,f,b.lastEffect);break;case "backwards":c=null;e=b.child;for(b.child=null;null!==e;){a=e.alternate;if(null!==a&&null===Rc(a)){b.child=e;break}a=e.sibling;e.sibling=c;c=e;e=a}Ke(b,
!0,c,null,f,b.lastEffect);break;case "together":Ke(b,!1,null,null,void 0,b.lastEffect);break;default:b.memoizedState=null}return b.child}function sa(a,b,c){null!==a&&(b.dependencies=a.dependencies);var d=b.expirationTime;0!==d&&Kc(d);if(b.childExpirationTime<c)return null;if(null!==a&&b.child!==a.child)throw Error(k(153));if(null!==b.child){a=b.child;c=Sa(a,a.pendingProps);b.child=c;for(c.return=b;null!==a.sibling;)a=a.sibling,c=c.sibling=Sa(a,a.pendingProps),c.return=b;c.sibling=null}return b.child}
function $c(a,b){switch(a.tailMode){case "hidden":b=a.tail;for(var c=null;null!==b;)null!==b.alternate&&(c=b),b=b.sibling;null===c?a.tail=null:c.sibling=null;break;case "collapsed":c=a.tail;for(var d=null;null!==c;)null!==c.alternate&&(d=c),c=c.sibling;null===d?b||null===a.tail?a.tail=null:a.tail.sibling=null:d.sibling=null}}function hj(a,b,c){var d=b.pendingProps;switch(b.tag){case 2:case 16:case 15:case 0:case 11:case 7:case 8:case 12:case 9:case 14:return null;case 1:return N(b.type)&&(q(G),q(B)),
null;case 3:return tb(),q(G),q(B),c=b.stateNode,c.pendingContext&&(c.context=c.pendingContext,c.pendingContext=null),null!==a&&null!==a.child||!Zc(b)||(b.effectTag|=4),wh(b),null;case 5:te(b);c=Ta(Tb.current);var e=b.type;if(null!==a&&null!=b.stateNode)ij(a,b,e,d,c),a.ref!==b.ref&&(b.effectTag|=128);else{if(!d){if(null===b.stateNode)throw Error(k(166));return null}a=Ta(ja.current);if(Zc(b)){d=b.stateNode;e=b.type;var f=b.memoizedProps;d[Aa]=b;d[vc]=f;switch(e){case "iframe":case "object":case "embed":w("load",
d);break;case "video":case "audio":for(a=0;a<Db.length;a++)w(Db[a],d);break;case "source":w("error",d);break;case "img":case "image":case "link":w("error",d);w("load",d);break;case "form":w("reset",d);w("submit",d);break;case "details":w("toggle",d);break;case "input":Hf(d,f);w("invalid",d);oa(c,"onChange");break;case "select":d._wrapperState={wasMultiple:!!f.multiple};w("invalid",d);oa(c,"onChange");break;case "textarea":Kf(d,f),w("invalid",d),oa(c,"onChange")}Ud(e,f);a=null;for(var g in f)if(f.hasOwnProperty(g)){var h=
f[g];"children"===g?"string"===typeof h?d.textContent!==h&&(a=["children",h]):"number"===typeof h&&d.textContent!==""+h&&(a=["children",""+h]):db.hasOwnProperty(g)&&null!=h&&oa(c,g)}switch(e){case "input":mc(d);Jf(d,f,!0);break;case "textarea":mc(d);Mf(d);break;case "select":case "option":break;default:"function"===typeof f.onClick&&(d.onclick=uc)}c=a;b.updateQueue=c;null!==c&&(b.effectTag|=4)}else{g=9===c.nodeType?c:c.ownerDocument;"http://www.w3.org/1999/xhtml"===a&&(a=Nf(e));"http://www.w3.org/1999/xhtml"===
a?"script"===e?(a=g.createElement("div"),a.innerHTML="<script>\x3c/script>",a=a.removeChild(a.firstChild)):"string"===typeof d.is?a=g.createElement(e,{is:d.is}):(a=g.createElement(e),"select"===e&&(g=a,d.multiple?g.multiple=!0:d.size&&(g.size=d.size))):a=g.createElementNS(a,e);a[Aa]=b;a[vc]=d;jj(a,b,!1,!1);b.stateNode=a;g=Vd(e,d);switch(e){case "iframe":case "object":case "embed":w("load",a);h=d;break;case "video":case "audio":for(h=0;h<Db.length;h++)w(Db[h],a);h=d;break;case "source":w("error",a);
h=d;break;case "img":case "image":case "link":w("error",a);w("load",a);h=d;break;case "form":w("reset",a);w("submit",a);h=d;break;case "details":w("toggle",a);h=d;break;case "input":Hf(a,d);h=Cd(a,d);w("invalid",a);oa(c,"onChange");break;case "option":h=Fd(a,d);break;case "select":a._wrapperState={wasMultiple:!!d.multiple};h=M({},d,{value:void 0});w("invalid",a);oa(c,"onChange");break;case "textarea":Kf(a,d);h=Gd(a,d);w("invalid",a);oa(c,"onChange");break;default:h=d}Ud(e,h);var m=h;for(f in m)if(m.hasOwnProperty(f)){var n=
m[f];"style"===f?gg(a,n):"dangerouslySetInnerHTML"===f?(n=n?n.__html:void 0,null!=n&&xh(a,n)):"children"===f?"string"===typeof n?("textarea"!==e||""!==n)&&Wb(a,n):"number"===typeof n&&Wb(a,""+n):"suppressContentEditableWarning"!==f&&"suppressHydrationWarning"!==f&&"autoFocus"!==f&&(db.hasOwnProperty(f)?null!=n&&oa(c,f):null!=n&&xd(a,f,n,g))}switch(e){case "input":mc(a);Jf(a,d,!1);break;case "textarea":mc(a);Mf(a);break;case "option":null!=d.value&&a.setAttribute("value",""+va(d.value));break;case "select":a.multiple=
!!d.multiple;c=d.value;null!=c?hb(a,!!d.multiple,c,!1):null!=d.defaultValue&&hb(a,!!d.multiple,d.defaultValue,!0);break;default:"function"===typeof h.onClick&&(a.onclick=uc)}lg(e,d)&&(b.effectTag|=4)}null!==b.ref&&(b.effectTag|=128)}return null;case 6:if(a&&null!=b.stateNode)kj(a,b,a.memoizedProps,d);else{if("string"!==typeof d&&null===b.stateNode)throw Error(k(166));c=Ta(Tb.current);Ta(ja.current);Zc(b)?(c=b.stateNode,d=b.memoizedProps,c[Aa]=b,c.nodeValue!==d&&(b.effectTag|=4)):(c=(9===c.nodeType?
c:c.ownerDocument).createTextNode(d),c[Aa]=b,b.stateNode=c)}return null;case 13:q(D);d=b.memoizedState;if(0!==(b.effectTag&64))return b.expirationTime=c,b;c=null!==d;d=!1;null===a?void 0!==b.memoizedProps.fallback&&Zc(b):(e=a.memoizedState,d=null!==e,c||null===e||(e=a.child.sibling,null!==e&&(f=b.firstEffect,null!==f?(b.firstEffect=e,e.nextEffect=f):(b.firstEffect=b.lastEffect=e,e.nextEffect=null),e.effectTag=8)));if(c&&!d&&0!==(b.mode&2))if(null===a&&!0!==b.memoizedProps.unstable_avoidThisFallback||
0!==(D.current&1))F===Xa&&(F=ad);else{if(F===Xa||F===ad)F=bd;0!==Xb&&null!==U&&(Ya(U,P),yh(U,Xb))}if(c||d)b.effectTag|=4;return null;case 4:return tb(),wh(b),null;case 10:return me(b),null;case 17:return N(b.type)&&(q(G),q(B)),null;case 19:q(D);d=b.memoizedState;if(null===d)return null;e=0!==(b.effectTag&64);f=d.rendering;if(null===f)if(e)$c(d,!1);else{if(F!==Xa||null!==a&&0!==(a.effectTag&64))for(f=b.child;null!==f;){a=Rc(f);if(null!==a){b.effectTag|=64;$c(d,!1);e=a.updateQueue;null!==e&&(b.updateQueue=
e,b.effectTag|=4);null===d.lastEffect&&(b.firstEffect=null);b.lastEffect=d.lastEffect;for(d=b.child;null!==d;)e=d,f=c,e.effectTag&=2,e.nextEffect=null,e.firstEffect=null,e.lastEffect=null,a=e.alternate,null===a?(e.childExpirationTime=0,e.expirationTime=f,e.child=null,e.memoizedProps=null,e.memoizedState=null,e.updateQueue=null,e.dependencies=null):(e.childExpirationTime=a.childExpirationTime,e.expirationTime=a.expirationTime,e.child=a.child,e.memoizedProps=a.memoizedProps,e.memoizedState=a.memoizedState,
e.updateQueue=a.updateQueue,f=a.dependencies,e.dependencies=null===f?null:{expirationTime:f.expirationTime,firstContext:f.firstContext,responders:f.responders}),d=d.sibling;y(D,D.current&1|2);return b.child}f=f.sibling}}else{if(!e)if(a=Rc(f),null!==a){if(b.effectTag|=64,e=!0,c=a.updateQueue,null!==c&&(b.updateQueue=c,b.effectTag|=4),$c(d,!0),null===d.tail&&"hidden"===d.tailMode&&!f.alternate)return b=b.lastEffect=d.lastEffect,null!==b&&(b.nextEffect=null),null}else 2*Y()-d.renderingStartTime>d.tailExpiration&&
1<c&&(b.effectTag|=64,e=!0,$c(d,!1),b.expirationTime=b.childExpirationTime=c-1);d.isBackwards?(f.sibling=b.child,b.child=f):(c=d.last,null!==c?c.sibling=f:b.child=f,d.last=f)}return null!==d.tail?(0===d.tailExpiration&&(d.tailExpiration=Y()+500),c=d.tail,d.rendering=c,d.tail=c.sibling,d.lastEffect=b.lastEffect,d.renderingStartTime=Y(),c.sibling=null,b=D.current,y(D,e?b&1|2:b&1),c):null}throw Error(k(156,b.tag));}function lj(a,b){switch(a.tag){case 1:return N(a.type)&&(q(G),q(B)),b=a.effectTag,b&4096?
(a.effectTag=b&-4097|64,a):null;case 3:tb();q(G);q(B);b=a.effectTag;if(0!==(b&64))throw Error(k(285));a.effectTag=b&-4097|64;return a;case 5:return te(a),null;case 13:return q(D),b=a.effectTag,b&4096?(a.effectTag=b&-4097|64,a):null;case 19:return q(D),null;case 4:return tb(),null;case 10:return me(a),null;default:return null}}function Le(a,b){return{value:a,source:b,stack:Bd(b)}}function Me(a,b){var c=b.source,d=b.stack;null===d&&null!==c&&(d=Bd(c));null!==c&&na(c.type);b=b.value;null!==a&&1===a.tag&&
na(a.type);try{console.error(b)}catch(e){setTimeout(function(){throw e;})}}function mj(a,b){try{b.props=a.memoizedProps,b.state=a.memoizedState,b.componentWillUnmount()}catch(c){Za(a,c)}}function zh(a){var b=a.ref;if(null!==b)if("function"===typeof b)try{b(null)}catch(c){Za(a,c)}else b.current=null}function nj(a,b){switch(b.tag){case 0:case 11:case 15:case 22:return;case 1:if(b.effectTag&256&&null!==a){var c=a.memoizedProps,d=a.memoizedState;a=b.stateNode;b=a.getSnapshotBeforeUpdate(b.elementType===
b.type?c:aa(b.type,c),d);a.__reactInternalSnapshotBeforeUpdate=b}return;case 3:case 5:case 6:case 4:case 17:return}throw Error(k(163));}function Ah(a,b){b=b.updateQueue;b=null!==b?b.lastEffect:null;if(null!==b){var c=b=b.next;do{if((c.tag&a)===a){var d=c.destroy;c.destroy=void 0;void 0!==d&&d()}c=c.next}while(c!==b)}}function Bh(a,b){b=b.updateQueue;b=null!==b?b.lastEffect:null;if(null!==b){var c=b=b.next;do{if((c.tag&a)===a){var d=c.create;c.destroy=d()}c=c.next}while(c!==b)}}function oj(a,b,c,d){switch(c.tag){case 0:case 11:case 15:case 22:Bh(3,
c);return;case 1:a=c.stateNode;c.effectTag&4&&(null===b?a.componentDidMount():(d=c.elementType===c.type?b.memoizedProps:aa(c.type,b.memoizedProps),a.componentDidUpdate(d,b.memoizedState,a.__reactInternalSnapshotBeforeUpdate)));b=c.updateQueue;null!==b&&Wg(c,b,a);return;case 3:b=c.updateQueue;if(null!==b){a=null;if(null!==c.child)switch(c.child.tag){case 5:a=c.child.stateNode;break;case 1:a=c.child.stateNode}Wg(c,b,a)}return;case 5:a=c.stateNode;null===b&&c.effectTag&4&&lg(c.type,c.memoizedProps)&&
a.focus();return;case 6:return;case 4:return;case 12:return;case 13:null===c.memoizedState&&(c=c.alternate,null!==c&&(c=c.memoizedState,null!==c&&(c=c.dehydrated,null!==c&&bg(c))));return;case 19:case 17:case 20:case 21:return}throw Error(k(163));}function Ch(a,b,c){"function"===typeof Ne&&Ne(b);switch(b.tag){case 0:case 11:case 14:case 15:case 22:a=b.updateQueue;if(null!==a&&(a=a.lastEffect,null!==a)){var d=a.next;Da(97<c?97:c,function(){var a=d;do{var c=a.destroy;if(void 0!==c){var g=b;try{c()}catch(h){Za(g,
h)}}a=a.next}while(a!==d)})}break;case 1:zh(b);c=b.stateNode;"function"===typeof c.componentWillUnmount&&mj(b,c);break;case 5:zh(b);break;case 4:Dh(a,b,c)}}function Eh(a){var b=a.alternate;a.return=null;a.child=null;a.memoizedState=null;a.updateQueue=null;a.dependencies=null;a.alternate=null;a.firstEffect=null;a.lastEffect=null;a.pendingProps=null;a.memoizedProps=null;a.stateNode=null;null!==b&&Eh(b)}function Fh(a){return 5===a.tag||3===a.tag||4===a.tag}function Gh(a){a:{for(var b=a.return;null!==
b;){if(Fh(b)){var c=b;break a}b=b.return}throw Error(k(160));}b=c.stateNode;switch(c.tag){case 5:var d=!1;break;case 3:b=b.containerInfo;d=!0;break;case 4:b=b.containerInfo;d=!0;break;default:throw Error(k(161));}c.effectTag&16&&(Wb(b,""),c.effectTag&=-17);a:b:for(c=a;;){for(;null===c.sibling;){if(null===c.return||Fh(c.return)){c=null;break a}c=c.return}c.sibling.return=c.return;for(c=c.sibling;5!==c.tag&&6!==c.tag&&18!==c.tag;){if(c.effectTag&2)continue b;if(null===c.child||4===c.tag)continue b;
else c.child.return=c,c=c.child}if(!(c.effectTag&2)){c=c.stateNode;break a}}d?Oe(a,c,b):Pe(a,c,b)}function Oe(a,b,c){var d=a.tag,e=5===d||6===d;if(e)a=e?a.stateNode:a.stateNode.instance,b?8===c.nodeType?c.parentNode.insertBefore(a,b):c.insertBefore(a,b):(8===c.nodeType?(b=c.parentNode,b.insertBefore(a,c)):(b=c,b.appendChild(a)),c=c._reactRootContainer,null!==c&&void 0!==c||null!==b.onclick||(b.onclick=uc));else if(4!==d&&(a=a.child,null!==a))for(Oe(a,b,c),a=a.sibling;null!==a;)Oe(a,b,c),a=a.sibling}
function Pe(a,b,c){var d=a.tag,e=5===d||6===d;if(e)a=e?a.stateNode:a.stateNode.instance,b?c.insertBefore(a,b):c.appendChild(a);else if(4!==d&&(a=a.child,null!==a))for(Pe(a,b,c),a=a.sibling;null!==a;)Pe(a,b,c),a=a.sibling}function Dh(a,b,c){for(var d=b,e=!1,f,g;;){if(!e){e=d.return;a:for(;;){if(null===e)throw Error(k(160));f=e.stateNode;switch(e.tag){case 5:g=!1;break a;case 3:f=f.containerInfo;g=!0;break a;case 4:f=f.containerInfo;g=!0;break a}e=e.return}e=!0}if(5===d.tag||6===d.tag){a:for(var h=
a,m=d,n=c,l=m;;)if(Ch(h,l,n),null!==l.child&&4!==l.tag)l.child.return=l,l=l.child;else{if(l===m)break a;for(;null===l.sibling;){if(null===l.return||l.return===m)break a;l=l.return}l.sibling.return=l.return;l=l.sibling}g?(h=f,m=d.stateNode,8===h.nodeType?h.parentNode.removeChild(m):h.removeChild(m)):f.removeChild(d.stateNode)}else if(4===d.tag){if(null!==d.child){f=d.stateNode.containerInfo;g=!0;d.child.return=d;d=d.child;continue}}else if(Ch(a,d,c),null!==d.child){d.child.return=d;d=d.child;continue}if(d===
b)break;for(;null===d.sibling;){if(null===d.return||d.return===b)return;d=d.return;4===d.tag&&(e=!1)}d.sibling.return=d.return;d=d.sibling}}function Qe(a,b){switch(b.tag){case 0:case 11:case 14:case 15:case 22:Ah(3,b);return;case 1:return;case 5:var c=b.stateNode;if(null!=c){var d=b.memoizedProps,e=null!==a?a.memoizedProps:d;a=b.type;var f=b.updateQueue;b.updateQueue=null;if(null!==f){c[vc]=d;"input"===a&&"radio"===d.type&&null!=d.name&&If(c,d);Vd(a,e);b=Vd(a,d);for(e=0;e<f.length;e+=2){var g=f[e],
h=f[e+1];"style"===g?gg(c,h):"dangerouslySetInnerHTML"===g?xh(c,h):"children"===g?Wb(c,h):xd(c,g,h,b)}switch(a){case "input":Dd(c,d);break;case "textarea":Lf(c,d);break;case "select":b=c._wrapperState.wasMultiple,c._wrapperState.wasMultiple=!!d.multiple,a=d.value,null!=a?hb(c,!!d.multiple,a,!1):b!==!!d.multiple&&(null!=d.defaultValue?hb(c,!!d.multiple,d.defaultValue,!0):hb(c,!!d.multiple,d.multiple?[]:"",!1))}}}return;case 6:if(null===b.stateNode)throw Error(k(162));b.stateNode.nodeValue=b.memoizedProps;
return;case 3:b=b.stateNode;b.hydrate&&(b.hydrate=!1,bg(b.containerInfo));return;case 12:return;case 13:c=b;null===b.memoizedState?d=!1:(d=!0,c=b.child,Re=Y());if(null!==c)a:for(a=c;;){if(5===a.tag)f=a.stateNode,d?(f=f.style,"function"===typeof f.setProperty?f.setProperty("display","none","important"):f.display="none"):(f=a.stateNode,e=a.memoizedProps.style,e=void 0!==e&&null!==e&&e.hasOwnProperty("display")?e.display:null,f.style.display=fg("display",e));else if(6===a.tag)a.stateNode.nodeValue=d?
"":a.memoizedProps;else if(13===a.tag&&null!==a.memoizedState&&null===a.memoizedState.dehydrated){f=a.child.sibling;f.return=a;a=f;continue}else if(null!==a.child){a.child.return=a;a=a.child;continue}if(a===c)break;for(;null===a.sibling;){if(null===a.return||a.return===c)break a;a=a.return}a.sibling.return=a.return;a=a.sibling}Hh(b);return;case 19:Hh(b);return;case 17:return}throw Error(k(163));}function Hh(a){var b=a.updateQueue;if(null!==b){a.updateQueue=null;var c=a.stateNode;null===c&&(c=a.stateNode=
new pj);b.forEach(function(b){var d=qj.bind(null,a,b);c.has(b)||(c.add(b),b.then(d,d))})}}function Ih(a,b,c){c=Ea(c,null);c.tag=3;c.payload={element:null};var d=b.value;c.callback=function(){cd||(cd=!0,Se=d);Me(a,b)};return c}function Jh(a,b,c){c=Ea(c,null);c.tag=3;var d=a.type.getDerivedStateFromError;if("function"===typeof d){var e=b.value;c.payload=function(){Me(a,b);return d(e)}}var f=a.stateNode;null!==f&&"function"===typeof f.componentDidCatch&&(c.callback=function(){"function"!==typeof d&&
(null===La?La=new Set([this]):La.add(this),Me(a,b));var c=b.stack;this.componentDidCatch(b.value,{componentStack:null!==c?c:""})});return c}function ka(){return(p&(ca|ma))!==H?1073741821-(Y()/10|0):0!==dd?dd:dd=1073741821-(Y()/10|0)}function Va(a,b,c){b=b.mode;if(0===(b&2))return 1073741823;var d=Cc();if(0===(b&4))return 99===d?1073741823:1073741822;if((p&ca)!==H)return P;if(null!==c)a=Fc(a,c.timeoutMs|0||5E3,250);else switch(d){case 99:a=1073741823;break;case 98:a=Fc(a,150,100);break;case 97:case 96:a=
Fc(a,5E3,250);break;case 95:a=2;break;default:throw Error(k(326));}null!==U&&a===P&&--a;return a}function ed(a,b){a.expirationTime<b&&(a.expirationTime=b);var c=a.alternate;null!==c&&c.expirationTime<b&&(c.expirationTime=b);var d=a.return,e=null;if(null===d&&3===a.tag)e=a.stateNode;else for(;null!==d;){c=d.alternate;d.childExpirationTime<b&&(d.childExpirationTime=b);null!==c&&c.childExpirationTime<b&&(c.childExpirationTime=b);if(null===d.return&&3===d.tag){e=d.stateNode;break}d=d.return}null!==e&&
(U===e&&(Kc(b),F===bd&&Ya(e,P)),yh(e,b));return e}function fd(a){var b=a.lastExpiredTime;if(0!==b)return b;b=a.firstPendingTime;if(!Kh(a,b))return b;var c=a.lastPingedTime;a=a.nextKnownPendingLevel;a=c>a?c:a;return 2>=a&&b!==a?0:a}function V(a){if(0!==a.lastExpiredTime)a.callbackExpirationTime=1073741823,a.callbackPriority=99,a.callbackNode=Og(Te.bind(null,a));else{var b=fd(a),c=a.callbackNode;if(0===b)null!==c&&(a.callbackNode=null,a.callbackExpirationTime=0,a.callbackPriority=90);else{var d=ka();
1073741823===b?d=99:1===b||2===b?d=95:(d=10*(1073741821-b)-10*(1073741821-d),d=0>=d?99:250>=d?98:5250>=d?97:95);if(null!==c){var e=a.callbackPriority;if(a.callbackExpirationTime===b&&e>=d)return;c!==Qg&&Rg(c)}a.callbackExpirationTime=b;a.callbackPriority=d;b=1073741823===b?Og(Te.bind(null,a)):Ng(d,Lh.bind(null,a),{timeout:10*(1073741821-b)-Y()});a.callbackNode=b}}}function Lh(a,b){dd=0;if(b)return b=ka(),Ue(a,b),V(a),null;var c=fd(a);if(0!==c){b=a.callbackNode;if((p&(ca|ma))!==H)throw Error(k(327));
xb();a===U&&c===P||$a(a,c);if(null!==t){var d=p;p|=ca;var e=Mh();do try{rj();break}catch(h){Nh(a,h)}while(1);le();p=d;gd.current=e;if(F===hd)throw b=id,$a(a,c),Ya(a,c),V(a),b;if(null===t)switch(e=a.finishedWork=a.current.alternate,a.finishedExpirationTime=c,d=F,U=null,d){case Xa:case hd:throw Error(k(345));case Oh:Ue(a,2<c?2:c);break;case ad:Ya(a,c);d=a.lastSuspendedTime;c===d&&(a.nextKnownPendingLevel=Ve(e));if(1073741823===ta&&(e=Re+Ph-Y(),10<e)){if(jd){var f=a.lastPingedTime;if(0===f||f>=c){a.lastPingedTime=
c;$a(a,c);break}}f=fd(a);if(0!==f&&f!==c)break;if(0!==d&&d!==c){a.lastPingedTime=d;break}a.timeoutHandle=We(ab.bind(null,a),e);break}ab(a);break;case bd:Ya(a,c);d=a.lastSuspendedTime;c===d&&(a.nextKnownPendingLevel=Ve(e));if(jd&&(e=a.lastPingedTime,0===e||e>=c)){a.lastPingedTime=c;$a(a,c);break}e=fd(a);if(0!==e&&e!==c)break;if(0!==d&&d!==c){a.lastPingedTime=d;break}1073741823!==Yb?d=10*(1073741821-Yb)-Y():1073741823===ta?d=0:(d=10*(1073741821-ta)-5E3,e=Y(),c=10*(1073741821-c)-e,d=e-d,0>d&&(d=0),d=
(120>d?120:480>d?480:1080>d?1080:1920>d?1920:3E3>d?3E3:4320>d?4320:1960*sj(d/1960))-d,c<d&&(d=c));if(10<d){a.timeoutHandle=We(ab.bind(null,a),d);break}ab(a);break;case Xe:if(1073741823!==ta&&null!==kd){f=ta;var g=kd;d=g.busyMinDurationMs|0;0>=d?d=0:(e=g.busyDelayMs|0,f=Y()-(10*(1073741821-f)-(g.timeoutMs|0||5E3)),d=f<=e?0:e+d-f);if(10<d){Ya(a,c);a.timeoutHandle=We(ab.bind(null,a),d);break}}ab(a);break;default:throw Error(k(329));}V(a);if(a.callbackNode===b)return Lh.bind(null,a)}}return null}function Te(a){var b=
a.lastExpiredTime;b=0!==b?b:1073741823;if((p&(ca|ma))!==H)throw Error(k(327));xb();a===U&&b===P||$a(a,b);if(null!==t){var c=p;p|=ca;var d=Mh();do try{tj();break}catch(e){Nh(a,e)}while(1);le();p=c;gd.current=d;if(F===hd)throw c=id,$a(a,b),Ya(a,b),V(a),c;if(null!==t)throw Error(k(261));a.finishedWork=a.current.alternate;a.finishedExpirationTime=b;U=null;ab(a);V(a)}return null}function uj(){if(null!==bb){var a=bb;bb=null;a.forEach(function(a,c){Ue(c,a);V(c)});ha()}}function Qh(a,b){var c=p;p|=1;try{return a(b)}finally{p=
c,p===H&&ha()}}function Rh(a,b){var c=p;p&=-2;p|=Ye;try{return a(b)}finally{p=c,p===H&&ha()}}function $a(a,b){a.finishedWork=null;a.finishedExpirationTime=0;var c=a.timeoutHandle;-1!==c&&(a.timeoutHandle=-1,vj(c));if(null!==t)for(c=t.return;null!==c;){var d=c;switch(d.tag){case 1:d=d.type.childContextTypes;null!==d&&void 0!==d&&(q(G),q(B));break;case 3:tb();q(G);q(B);break;case 5:te(d);break;case 4:tb();break;case 13:q(D);break;case 19:q(D);break;case 10:me(d)}c=c.return}U=a;t=Sa(a.current,null);
P=b;F=Xa;id=null;Yb=ta=1073741823;kd=null;Xb=0;jd=!1}function Nh(a,b){do{try{le();Sc.current=Tc;if(Uc)for(var c=z.memoizedState;null!==c;){var d=c.queue;null!==d&&(d.pending=null);c=c.next}Ia=0;J=K=z=null;Uc=!1;if(null===t||null===t.return)return F=hd,id=b,t=null;a:{var e=a,f=t.return,g=t,h=b;b=P;g.effectTag|=2048;g.firstEffect=g.lastEffect=null;if(null!==h&&"object"===typeof h&&"function"===typeof h.then){var m=h;if(0===(g.mode&2)){var n=g.alternate;n?(g.updateQueue=n.updateQueue,g.memoizedState=
n.memoizedState,g.expirationTime=n.expirationTime):(g.updateQueue=null,g.memoizedState=null)}var l=0!==(D.current&1),k=f;do{var p;if(p=13===k.tag){var q=k.memoizedState;if(null!==q)p=null!==q.dehydrated?!0:!1;else{var w=k.memoizedProps;p=void 0===w.fallback?!1:!0!==w.unstable_avoidThisFallback?!0:l?!1:!0}}if(p){var y=k.updateQueue;if(null===y){var r=new Set;r.add(m);k.updateQueue=r}else y.add(m);if(0===(k.mode&2)){k.effectTag|=64;g.effectTag&=-2981;if(1===g.tag)if(null===g.alternate)g.tag=17;else{var O=
Ea(1073741823,null);O.tag=Jc;Fa(g,O)}g.expirationTime=1073741823;break a}h=void 0;g=b;var v=e.pingCache;null===v?(v=e.pingCache=new wj,h=new Set,v.set(m,h)):(h=v.get(m),void 0===h&&(h=new Set,v.set(m,h)));if(!h.has(g)){h.add(g);var x=xj.bind(null,e,m,g);m.then(x,x)}k.effectTag|=4096;k.expirationTime=b;break a}k=k.return}while(null!==k);h=Error((na(g.type)||"A React component")+" suspended while rendering, but no fallback UI was specified.\n\nAdd a <Suspense fallback=...> component higher in the tree to provide a loading indicator or placeholder to display."+
Bd(g))}F!==Xe&&(F=Oh);h=Le(h,g);k=f;do{switch(k.tag){case 3:m=h;k.effectTag|=4096;k.expirationTime=b;var A=Ih(k,m,b);Ug(k,A);break a;case 1:m=h;var u=k.type,B=k.stateNode;if(0===(k.effectTag&64)&&("function"===typeof u.getDerivedStateFromError||null!==B&&"function"===typeof B.componentDidCatch&&(null===La||!La.has(B)))){k.effectTag|=4096;k.expirationTime=b;var H=Jh(k,m,b);Ug(k,H);break a}}k=k.return}while(null!==k)}t=Sh(t)}catch(cj){b=cj;continue}break}while(1)}function Mh(a){a=gd.current;gd.current=
Tc;return null===a?Tc:a}function Vg(a,b){a<ta&&2<a&&(ta=a);null!==b&&a<Yb&&2<a&&(Yb=a,kd=b)}function Kc(a){a>Xb&&(Xb=a)}function tj(){for(;null!==t;)t=Th(t)}function rj(){for(;null!==t&&!yj();)t=Th(t)}function Th(a){var b=zj(a.alternate,a,P);a.memoizedProps=a.pendingProps;null===b&&(b=Sh(a));Uh.current=null;return b}function Sh(a){t=a;do{var b=t.alternate;a=t.return;if(0===(t.effectTag&2048)){b=hj(b,t,P);if(1===P||1!==t.childExpirationTime){for(var c=0,d=t.child;null!==d;){var e=d.expirationTime,
f=d.childExpirationTime;e>c&&(c=e);f>c&&(c=f);d=d.sibling}t.childExpirationTime=c}if(null!==b)return b;null!==a&&0===(a.effectTag&2048)&&(null===a.firstEffect&&(a.firstEffect=t.firstEffect),null!==t.lastEffect&&(null!==a.lastEffect&&(a.lastEffect.nextEffect=t.firstEffect),a.lastEffect=t.lastEffect),1<t.effectTag&&(null!==a.lastEffect?a.lastEffect.nextEffect=t:a.firstEffect=t,a.lastEffect=t))}else{b=lj(t);if(null!==b)return b.effectTag&=2047,b;null!==a&&(a.firstEffect=a.lastEffect=null,a.effectTag|=
2048)}b=t.sibling;if(null!==b)return b;t=a}while(null!==t);F===Xa&&(F=Xe);return null}function Ve(a){var b=a.expirationTime;a=a.childExpirationTime;return b>a?b:a}function ab(a){var b=Cc();Da(99,Aj.bind(null,a,b));return null}function Aj(a,b){do xb();while(null!==Zb);if((p&(ca|ma))!==H)throw Error(k(327));var c=a.finishedWork,d=a.finishedExpirationTime;if(null===c)return null;a.finishedWork=null;a.finishedExpirationTime=0;if(c===a.current)throw Error(k(177));a.callbackNode=null;a.callbackExpirationTime=
0;a.callbackPriority=90;a.nextKnownPendingLevel=0;var e=Ve(c);a.firstPendingTime=e;d<=a.lastSuspendedTime?a.firstSuspendedTime=a.lastSuspendedTime=a.nextKnownPendingLevel=0:d<=a.firstSuspendedTime&&(a.firstSuspendedTime=d-1);d<=a.lastPingedTime&&(a.lastPingedTime=0);d<=a.lastExpiredTime&&(a.lastExpiredTime=0);a===U&&(t=U=null,P=0);1<c.effectTag?null!==c.lastEffect?(c.lastEffect.nextEffect=c,e=c.firstEffect):e=c:e=c.firstEffect;if(null!==e){var f=p;p|=ma;Uh.current=null;Ze=tc;var g=kg();if(Xd(g)){if("selectionStart"in
g)var h={start:g.selectionStart,end:g.selectionEnd};else a:{h=(h=g.ownerDocument)&&h.defaultView||window;var m=h.getSelection&&h.getSelection();if(m&&0!==m.rangeCount){h=m.anchorNode;var n=m.anchorOffset,q=m.focusNode;m=m.focusOffset;try{h.nodeType,q.nodeType}catch(sb){h=null;break a}var ba=0,w=-1,y=-1,B=0,D=0,r=g,z=null;b:for(;;){for(var v;;){r!==h||0!==n&&3!==r.nodeType||(w=ba+n);r!==q||0!==m&&3!==r.nodeType||(y=ba+m);3===r.nodeType&&(ba+=r.nodeValue.length);if(null===(v=r.firstChild))break;z=r;
r=v}for(;;){if(r===g)break b;z===h&&++B===n&&(w=ba);z===q&&++D===m&&(y=ba);if(null!==(v=r.nextSibling))break;r=z;z=r.parentNode}r=v}h=-1===w||-1===y?null:{start:w,end:y}}else h=null}h=h||{start:0,end:0}}else h=null;$e={activeElementDetached:null,focusedElem:g,selectionRange:h};tc=!1;l=e;do try{Bj()}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);l=e;do try{for(g=a,h=b;null!==l;){var x=l.effectTag;x&16&&Wb(l.stateNode,"");if(x&128){var A=l.alternate;if(null!==A){var u=
A.ref;null!==u&&("function"===typeof u?u(null):u.current=null)}}switch(x&1038){case 2:Gh(l);l.effectTag&=-3;break;case 6:Gh(l);l.effectTag&=-3;Qe(l.alternate,l);break;case 1024:l.effectTag&=-1025;break;case 1028:l.effectTag&=-1025;Qe(l.alternate,l);break;case 4:Qe(l.alternate,l);break;case 8:n=l,Dh(g,n,h),Eh(n)}l=l.nextEffect}}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);u=$e;A=kg();x=u.focusedElem;h=u.selectionRange;if(A!==x&&x&&x.ownerDocument&&jg(x.ownerDocument.documentElement,
x)){null!==h&&Xd(x)&&(A=h.start,u=h.end,void 0===u&&(u=A),"selectionStart"in x?(x.selectionStart=A,x.selectionEnd=Math.min(u,x.value.length)):(u=(A=x.ownerDocument||document)&&A.defaultView||window,u.getSelection&&(u=u.getSelection(),n=x.textContent.length,g=Math.min(h.start,n),h=void 0===h.end?g:Math.min(h.end,n),!u.extend&&g>h&&(n=h,h=g,g=n),n=ig(x,g),q=ig(x,h),n&&q&&(1!==u.rangeCount||u.anchorNode!==n.node||u.anchorOffset!==n.offset||u.focusNode!==q.node||u.focusOffset!==q.offset)&&(A=A.createRange(),
A.setStart(n.node,n.offset),u.removeAllRanges(),g>h?(u.addRange(A),u.extend(q.node,q.offset)):(A.setEnd(q.node,q.offset),u.addRange(A))))));A=[];for(u=x;u=u.parentNode;)1===u.nodeType&&A.push({element:u,left:u.scrollLeft,top:u.scrollTop});"function"===typeof x.focus&&x.focus();for(x=0;x<A.length;x++)u=A[x],u.element.scrollLeft=u.left,u.element.scrollTop=u.top}tc=!!Ze;$e=Ze=null;a.current=c;l=e;do try{for(x=a;null!==l;){var F=l.effectTag;F&36&&oj(x,l.alternate,l);if(F&128){A=void 0;var E=l.ref;if(null!==
E){var G=l.stateNode;switch(l.tag){case 5:A=G;break;default:A=G}"function"===typeof E?E(A):E.current=A}}l=l.nextEffect}}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);l=null;Cj();p=f}else a.current=c;if(ld)ld=!1,Zb=a,$b=b;else for(l=e;null!==l;)b=l.nextEffect,l.nextEffect=null,l=b;b=a.firstPendingTime;0===b&&(La=null);1073741823===b?a===af?ac++:(ac=0,af=a):ac=0;"function"===typeof bf&&bf(c.stateNode,d);V(a);if(cd)throw cd=!1,a=Se,Se=null,a;if((p&Ye)!==H)return null;
ha();return null}function Bj(){for(;null!==l;){var a=l.effectTag;0!==(a&256)&&nj(l.alternate,l);0===(a&512)||ld||(ld=!0,Ng(97,function(){xb();return null}));l=l.nextEffect}}function xb(){if(90!==$b){var a=97<$b?97:$b;$b=90;return Da(a,Dj)}}function Dj(){if(null===Zb)return!1;var a=Zb;Zb=null;if((p&(ca|ma))!==H)throw Error(k(331));var b=p;p|=ma;for(a=a.current.firstEffect;null!==a;){try{var c=a;if(0!==(c.effectTag&512))switch(c.tag){case 0:case 11:case 15:case 22:Ah(5,c),Bh(5,c)}}catch(d){if(null===
a)throw Error(k(330));Za(a,d)}c=a.nextEffect;a.nextEffect=null;a=c}p=b;ha();return!0}function Vh(a,b,c){b=Le(c,b);b=Ih(a,b,1073741823);Fa(a,b);a=ed(a,1073741823);null!==a&&V(a)}function Za(a,b){if(3===a.tag)Vh(a,a,b);else for(var c=a.return;null!==c;){if(3===c.tag){Vh(c,a,b);break}else if(1===c.tag){var d=c.stateNode;if("function"===typeof c.type.getDerivedStateFromError||"function"===typeof d.componentDidCatch&&(null===La||!La.has(d))){a=Le(b,a);a=Jh(c,a,1073741823);Fa(c,a);c=ed(c,1073741823);null!==
c&&V(c);break}}c=c.return}}function xj(a,b,c){var d=a.pingCache;null!==d&&d.delete(b);U===a&&P===c?F===bd||F===ad&&1073741823===ta&&Y()-Re<Ph?$a(a,P):jd=!0:Kh(a,c)&&(b=a.lastPingedTime,0!==b&&b<c||(a.lastPingedTime=c,V(a)))}function qj(a,b){var c=a.stateNode;null!==c&&c.delete(b);b=0;0===b&&(b=ka(),b=Va(b,a,null));a=ed(a,b);null!==a&&V(a)}function Ej(a){if("undefined"===typeof __REACT_DEVTOOLS_GLOBAL_HOOK__)return!1;var b=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(b.isDisabled||!b.supportsFiber)return!0;try{var c=
b.inject(a);bf=function(a,e){try{b.onCommitFiberRoot(c,a,void 0,64===(a.current.effectTag&64))}catch(f){}};Ne=function(a){try{b.onCommitFiberUnmount(c,a)}catch(e){}}}catch(d){}return!0}function Fj(a,b,c,d){this.tag=a;this.key=c;this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null;this.index=0;this.ref=null;this.pendingProps=b;this.dependencies=this.memoizedState=this.updateQueue=this.memoizedProps=null;this.mode=d;this.effectTag=0;this.lastEffect=this.firstEffect=this.nextEffect=
null;this.childExpirationTime=this.expirationTime=0;this.alternate=null}function Ge(a){a=a.prototype;return!(!a||!a.isReactComponent)}function Gj(a){if("function"===typeof a)return Ge(a)?1:0;if(void 0!==a&&null!==a){a=a.$$typeof;if(a===zd)return 11;if(a===Ad)return 14}return 2}function Sa(a,b){var c=a.alternate;null===c?(c=la(a.tag,b,a.key,a.mode),c.elementType=a.elementType,c.type=a.type,c.stateNode=a.stateNode,c.alternate=a,a.alternate=c):(c.pendingProps=b,c.effectTag=0,c.nextEffect=null,c.firstEffect=
null,c.lastEffect=null);c.childExpirationTime=a.childExpirationTime;c.expirationTime=a.expirationTime;c.child=a.child;c.memoizedProps=a.memoizedProps;c.memoizedState=a.memoizedState;c.updateQueue=a.updateQueue;b=a.dependencies;c.dependencies=null===b?null:{expirationTime:b.expirationTime,firstContext:b.firstContext,responders:b.responders};c.sibling=a.sibling;c.index=a.index;c.ref=a.ref;return c}function Oc(a,b,c,d,e,f){var g=2;d=a;if("function"===typeof a)Ge(a)&&(g=1);else if("string"===typeof a)g=
5;else a:switch(a){case Ma:return Ha(c.children,e,f,b);case Hj:g=8;e|=7;break;case Af:g=8;e|=1;break;case kc:return a=la(12,c,b,e|8),a.elementType=kc,a.type=kc,a.expirationTime=f,a;case lc:return a=la(13,c,b,e),a.type=lc,a.elementType=lc,a.expirationTime=f,a;case yd:return a=la(19,c,b,e),a.elementType=yd,a.expirationTime=f,a;default:if("object"===typeof a&&null!==a)switch(a.$$typeof){case Cf:g=10;break a;case Bf:g=9;break a;case zd:g=11;break a;case Ad:g=14;break a;case Ef:g=16;d=null;break a;case Df:g=
22;break a}throw Error(k(130,null==a?a:typeof a,""));}b=la(g,c,b,e);b.elementType=a;b.type=d;b.expirationTime=f;return b}function Ha(a,b,c,d){a=la(7,a,d,b);a.expirationTime=c;return a}function qe(a,b,c){a=la(6,a,null,b);a.expirationTime=c;return a}function re(a,b,c){b=la(4,null!==a.children?a.children:[],a.key,b);b.expirationTime=c;b.stateNode={containerInfo:a.containerInfo,pendingChildren:null,implementation:a.implementation};return b}function Ij(a,b,c){this.tag=b;this.current=null;this.containerInfo=
a;this.pingCache=this.pendingChildren=null;this.finishedExpirationTime=0;this.finishedWork=null;this.timeoutHandle=-1;this.pendingContext=this.context=null;this.hydrate=c;this.callbackNode=null;this.callbackPriority=90;this.lastExpiredTime=this.lastPingedTime=this.nextKnownPendingLevel=this.lastSuspendedTime=this.firstSuspendedTime=this.firstPendingTime=0}function Kh(a,b){var c=a.firstSuspendedTime;a=a.lastSuspendedTime;return 0!==c&&c>=b&&a<=b}function Ya(a,b){var c=a.firstSuspendedTime,d=a.lastSuspendedTime;
c<b&&(a.firstSuspendedTime=b);if(d>b||0===c)a.lastSuspendedTime=b;b<=a.lastPingedTime&&(a.lastPingedTime=0);b<=a.lastExpiredTime&&(a.lastExpiredTime=0)}function yh(a,b){b>a.firstPendingTime&&(a.firstPendingTime=b);var c=a.firstSuspendedTime;0!==c&&(b>=c?a.firstSuspendedTime=a.lastSuspendedTime=a.nextKnownPendingLevel=0:b>=a.lastSuspendedTime&&(a.lastSuspendedTime=b+1),b>a.nextKnownPendingLevel&&(a.nextKnownPendingLevel=b))}function Ue(a,b){var c=a.lastExpiredTime;if(0===c||c>b)a.lastExpiredTime=b}
function md(a,b,c,d){var e=b.current,f=ka(),g=Vb.suspense;f=Va(f,e,g);a:if(c){c=c._reactInternalFiber;b:{if(Na(c)!==c||1!==c.tag)throw Error(k(170));var h=c;do{switch(h.tag){case 3:h=h.stateNode.context;break b;case 1:if(N(h.type)){h=h.stateNode.__reactInternalMemoizedMergedChildContext;break b}}h=h.return}while(null!==h);throw Error(k(171));}if(1===c.tag){var m=c.type;if(N(m)){c=Gg(c,m,h);break a}}c=h}else c=Ca;null===b.context?b.context=c:b.pendingContext=c;b=Ea(f,g);b.payload={element:a};d=void 0===
d?null:d;null!==d&&(b.callback=d);Fa(e,b);Ja(e,f);return f}function cf(a){a=a.current;if(!a.child)return null;switch(a.child.tag){case 5:return a.child.stateNode;default:return a.child.stateNode}}function Wh(a,b){a=a.memoizedState;null!==a&&null!==a.dehydrated&&a.retryTime<b&&(a.retryTime=b)}function df(a,b){Wh(a,b);(a=a.alternate)&&Wh(a,b)}function ef(a,b,c){c=null!=c&&!0===c.hydrate;var d=new Ij(a,b,c),e=la(3,null,null,2===b?7:1===b?3:0);d.current=e;e.stateNode=d;ne(e);a[Lb]=d.current;c&&0!==b&&
xi(a,9===a.nodeType?a:a.ownerDocument);this._internalRoot=d}function bc(a){return!(!a||1!==a.nodeType&&9!==a.nodeType&&11!==a.nodeType&&(8!==a.nodeType||" react-mount-point-unstable "!==a.nodeValue))}function Jj(a,b){b||(b=a?9===a.nodeType?a.documentElement:a.firstChild:null,b=!(!b||1!==b.nodeType||!b.hasAttribute("data-reactroot")));if(!b)for(var c;c=a.lastChild;)a.removeChild(c);return new ef(a,0,b?{hydrate:!0}:void 0)}function nd(a,b,c,d,e){var f=c._reactRootContainer;if(f){var g=f._internalRoot;
if("function"===typeof e){var h=e;e=function(){var a=cf(g);h.call(a)}}md(b,g,a,e)}else{f=c._reactRootContainer=Jj(c,d);g=f._internalRoot;if("function"===typeof e){var m=e;e=function(){var a=cf(g);m.call(a)}}Rh(function(){md(b,g,a,e)})}return cf(g)}function Kj(a,b,c){var d=3<arguments.length&&void 0!==arguments[3]?arguments[3]:null;return{$$typeof:gb,key:null==d?null:""+d,children:a,containerInfo:b,implementation:c}}function Xh(a,b){var c=2<arguments.length&&void 0!==arguments[2]?arguments[2]:null;
if(!bc(b))throw Error(k(200));return Kj(a,b,null,c)}if(!ea)throw Error(k(227));var ki=function(a,b,c,d,e,f,g,h,m){var n=Array.prototype.slice.call(arguments,3);try{b.apply(c,n)}catch(C){this.onError(C)}},yb=!1,gc=null,hc=!1,pd=null,li={onError:function(a){yb=!0;gc=a}},td=null,rf=null,mf=null,ic=null,cb={},jc=[],qd={},db={},rd={},wa=!("undefined"===typeof window||"undefined"===typeof window.document||"undefined"===typeof window.document.createElement),M=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.assign,
sd=null,eb=null,fb=null,ee=function(a,b){return a(b)},eg=function(a,b,c,d,e){return a(b,c,d,e)},vd=function(){},vf=ee,Oa=!1,wd=!1,Z=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.Scheduler,Lj=Z.unstable_cancelCallback,ff=Z.unstable_now,$f=Z.unstable_scheduleCallback,Mj=Z.unstable_shouldYield,Yh=Z.unstable_requestPaint,Pd=Z.unstable_runWithPriority,Nj=Z.unstable_getCurrentPriorityLevel,Oj=Z.unstable_ImmediatePriority,Zh=Z.unstable_UserBlockingPriority,ag=Z.unstable_NormalPriority,Pj=Z.unstable_LowPriority,
Qj=Z.unstable_IdlePriority,oi=/^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,wf=Object.prototype.hasOwnProperty,yf={},xf={},E={};"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(a){E[a]=
new L(a,0,!1,a,null,!1)});[["acceptCharset","accept-charset"],["className","class"],["htmlFor","for"],["httpEquiv","http-equiv"]].forEach(function(a){var b=a[0];E[b]=new L(b,1,!1,a[1],null,!1)});["contentEditable","draggable","spellCheck","value"].forEach(function(a){E[a]=new L(a,2,!1,a.toLowerCase(),null,!1)});["autoReverse","externalResourcesRequired","focusable","preserveAlpha"].forEach(function(a){E[a]=new L(a,2,!1,a,null,!1)});"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(a){E[a]=
new L(a,3,!1,a.toLowerCase(),null,!1)});["checked","multiple","muted","selected"].forEach(function(a){E[a]=new L(a,3,!0,a,null,!1)});["capture","download"].forEach(function(a){E[a]=new L(a,4,!1,a,null,!1)});["cols","rows","size","span"].forEach(function(a){E[a]=new L(a,6,!1,a,null,!1)});["rowSpan","start"].forEach(function(a){E[a]=new L(a,5,!1,a.toLowerCase(),null,!1)});var gf=/[\-:]([a-z])/g,hf=function(a){return a[1].toUpperCase()};"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(a){var b=
a.replace(gf,hf);E[b]=new L(b,1,!1,a,null,!1)});"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(a){var b=a.replace(gf,hf);E[b]=new L(b,1,!1,a,"http://www.w3.org/1999/xlink",!1)});["xml:base","xml:lang","xml:space"].forEach(function(a){var b=a.replace(gf,hf);E[b]=new L(b,1,!1,a,"http://www.w3.org/XML/1998/namespace",!1)});["tabIndex","crossOrigin"].forEach(function(a){E[a]=new L(a,1,!1,a.toLowerCase(),null,!1)});E.xlinkHref=new L("xlinkHref",1,
!1,"xlink:href","http://www.w3.org/1999/xlink",!0);["src","href","action","formAction"].forEach(function(a){E[a]=new L(a,1,!1,a.toLowerCase(),null,!0)});var da=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;da.hasOwnProperty("ReactCurrentDispatcher")||(da.ReactCurrentDispatcher={current:null});da.hasOwnProperty("ReactCurrentBatchConfig")||(da.ReactCurrentBatchConfig={suspense:null});var si=/^(.*)[\\\/]/,Q="function"===typeof Symbol&&Symbol.for,Pc=Q?Symbol.for("react.element"):60103,gb=Q?Symbol.for("react.portal"):
60106,Ma=Q?Symbol.for("react.fragment"):60107,Af=Q?Symbol.for("react.strict_mode"):60108,kc=Q?Symbol.for("react.profiler"):60114,Cf=Q?Symbol.for("react.provider"):60109,Bf=Q?Symbol.for("react.context"):60110,Hj=Q?Symbol.for("react.concurrent_mode"):60111,zd=Q?Symbol.for("react.forward_ref"):60112,lc=Q?Symbol.for("react.suspense"):60113,yd=Q?Symbol.for("react.suspense_list"):60120,Ad=Q?Symbol.for("react.memo"):60115,Ef=Q?Symbol.for("react.lazy"):60116,Df=Q?Symbol.for("react.block"):60121,zf="function"===
typeof Symbol&&Symbol.iterator,od,xh=function(a){return"undefined"!==typeof MSApp&&MSApp.execUnsafeLocalFunction?function(b,c,d,e){MSApp.execUnsafeLocalFunction(function(){return a(b,c,d,e)})}:a}(function(a,b){if("http://www.w3.org/2000/svg"!==a.namespaceURI||"innerHTML"in a)a.innerHTML=b;else{od=od||document.createElement("div");od.innerHTML="<svg>"+b.valueOf().toString()+"</svg>";for(b=od.firstChild;a.firstChild;)a.removeChild(a.firstChild);for(;b.firstChild;)a.appendChild(b.firstChild)}}),Wb=function(a,
b){if(b){var c=a.firstChild;if(c&&c===a.lastChild&&3===c.nodeType){c.nodeValue=b;return}}a.textContent=b},ib={animationend:nc("Animation","AnimationEnd"),animationiteration:nc("Animation","AnimationIteration"),animationstart:nc("Animation","AnimationStart"),transitionend:nc("Transition","TransitionEnd")},Id={},Of={};wa&&(Of=document.createElement("div").style,"AnimationEvent"in window||(delete ib.animationend.animation,delete ib.animationiteration.animation,delete ib.animationstart.animation),"TransitionEvent"in
window||delete ib.transitionend.transition);var $h=oc("animationend"),ai=oc("animationiteration"),bi=oc("animationstart"),ci=oc("transitionend"),Db="abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),Pf=new ("function"===typeof WeakMap?WeakMap:Map),Ab=null,wi=function(a){if(a){var b=a._dispatchListeners,c=a._dispatchInstances;
if(Array.isArray(b))for(var d=0;d<b.length&&!a.isPropagationStopped();d++)lf(a,b[d],c[d]);else b&&lf(a,b,c);a._dispatchListeners=null;a._dispatchInstances=null;a.isPersistent()||a.constructor.release(a)}},qc=[],Rd=!1,fa=[],xa=null,ya=null,za=null,Eb=new Map,Fb=new Map,Jb=[],Nd="mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput close cancel copy cut paste click change contextmenu reset submit".split(" "),
yi="focus blur dragenter dragleave mouseover mouseout pointerover pointerout gotpointercapture lostpointercapture".split(" "),dg={},cg=new Map,Td=new Map,Rj=["abort","abort",$h,"animationEnd",ai,"animationIteration",bi,"animationStart","canplay","canPlay","canplaythrough","canPlayThrough","durationchange","durationChange","emptied","emptied","encrypted","encrypted","ended","ended","error","error","gotpointercapture","gotPointerCapture","load","load","loadeddata","loadedData","loadedmetadata","loadedMetadata",
"loadstart","loadStart","lostpointercapture","lostPointerCapture","playing","playing","progress","progress","seeking","seeking","stalled","stalled","suspend","suspend","timeupdate","timeUpdate",ci,"transitionEnd","waiting","waiting"];Sd("blur blur cancel cancel click click close close contextmenu contextMenu copy copy cut cut auxclick auxClick dblclick doubleClick dragend dragEnd dragstart dragStart drop drop focus focus input input invalid invalid keydown keyDown keypress keyPress keyup keyUp mousedown mouseDown mouseup mouseUp paste paste pause pause play play pointercancel pointerCancel pointerdown pointerDown pointerup pointerUp ratechange rateChange reset reset seeked seeked submit submit touchcancel touchCancel touchend touchEnd touchstart touchStart volumechange volumeChange".split(" "),
0);Sd("drag drag dragenter dragEnter dragexit dragExit dragleave dragLeave dragover dragOver mousemove mouseMove mouseout mouseOut mouseover mouseOver pointermove pointerMove pointerout pointerOut pointerover pointerOver scroll scroll toggle toggle touchmove touchMove wheel wheel".split(" "),1);Sd(Rj,2);(function(a,b){for(var c=0;c<a.length;c++)Td.set(a[c],b)})("change selectionchange textInput compositionstart compositionend compositionupdate".split(" "),0);var Hi=Zh,Gi=Pd,tc=!0,Kb={animationIterationCount:!0,
borderImageOutset:!0,borderImageSlice:!0,borderImageWidth:!0,boxFlex:!0,boxFlexGroup:!0,boxOrdinalGroup:!0,columnCount:!0,columns:!0,flex:!0,flexGrow:!0,flexPositive:!0,flexShrink:!0,flexNegative:!0,flexOrder:!0,gridArea:!0,gridRow:!0,gridRowEnd:!0,gridRowSpan:!0,gridRowStart:!0,gridColumn:!0,gridColumnEnd:!0,gridColumnSpan:!0,gridColumnStart:!0,fontWeight:!0,lineClamp:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,tabSize:!0,widows:!0,zIndex:!0,zoom:!0,fillOpacity:!0,floodOpacity:!0,stopOpacity:!0,
strokeDasharray:!0,strokeDashoffset:!0,strokeMiterlimit:!0,strokeOpacity:!0,strokeWidth:!0},Sj=["Webkit","ms","Moz","O"];Object.keys(Kb).forEach(function(a){Sj.forEach(function(b){b=b+a.charAt(0).toUpperCase()+a.substring(1);Kb[b]=Kb[a]})});var Ii=M({menuitem:!0},{area:!0,base:!0,br:!0,col:!0,embed:!0,hr:!0,img:!0,input:!0,keygen:!0,link:!0,meta:!0,param:!0,source:!0,track:!0,wbr:!0}),ng="$",og="/$",$d="$?",Zd="$!",Ze=null,$e=null,We="function"===typeof setTimeout?setTimeout:void 0,vj="function"===
typeof clearTimeout?clearTimeout:void 0,jf=Math.random().toString(36).slice(2),Aa="__reactInternalInstance$"+jf,vc="__reactEventHandlers$"+jf,Lb="__reactContainere$"+jf,Ba=null,ce=null,wc=null;M(R.prototype,{preventDefault:function(){this.defaultPrevented=!0;var a=this.nativeEvent;a&&(a.preventDefault?a.preventDefault():"unknown"!==typeof a.returnValue&&(a.returnValue=!1),this.isDefaultPrevented=xc)},stopPropagation:function(){var a=this.nativeEvent;a&&(a.stopPropagation?a.stopPropagation():"unknown"!==
typeof a.cancelBubble&&(a.cancelBubble=!0),this.isPropagationStopped=xc)},persist:function(){this.isPersistent=xc},isPersistent:yc,destructor:function(){var a=this.constructor.Interface,b;for(b in a)this[b]=null;this.nativeEvent=this._targetInst=this.dispatchConfig=null;this.isPropagationStopped=this.isDefaultPrevented=yc;this._dispatchInstances=this._dispatchListeners=null}});R.Interface={type:null,target:null,currentTarget:function(){return null},eventPhase:null,bubbles:null,cancelable:null,timeStamp:function(a){return a.timeStamp||
Date.now()},defaultPrevented:null,isTrusted:null};R.extend=function(a){function b(){return c.apply(this,arguments)}var c=this,d=function(){};d.prototype=c.prototype;d=new d;M(d,b.prototype);b.prototype=d;b.prototype.constructor=b;b.Interface=M({},c.Interface,a);b.extend=c.extend;sg(b);return b};sg(R);var Tj=R.extend({data:null}),Uj=R.extend({data:null}),Ni=[9,13,27,32],de=wa&&"CompositionEvent"in window,cc=null;wa&&"documentMode"in document&&(cc=document.documentMode);var Vj=wa&&"TextEvent"in window&&
!cc,xg=wa&&(!de||cc&&8<cc&&11>=cc),wg=String.fromCharCode(32),ua={beforeInput:{phasedRegistrationNames:{bubbled:"onBeforeInput",captured:"onBeforeInputCapture"},dependencies:["compositionend","keypress","textInput","paste"]},compositionEnd:{phasedRegistrationNames:{bubbled:"onCompositionEnd",captured:"onCompositionEndCapture"},dependencies:"blur compositionend keydown keypress keyup mousedown".split(" ")},compositionStart:{phasedRegistrationNames:{bubbled:"onCompositionStart",captured:"onCompositionStartCapture"},
dependencies:"blur compositionstart keydown keypress keyup mousedown".split(" ")},compositionUpdate:{phasedRegistrationNames:{bubbled:"onCompositionUpdate",captured:"onCompositionUpdateCapture"},dependencies:"blur compositionupdate keydown keypress keyup mousedown".split(" ")}},vg=!1,mb=!1,Wj={eventTypes:ua,extractEvents:function(a,b,c,d,e){var f;if(de)b:{switch(a){case "compositionstart":var g=ua.compositionStart;break b;case "compositionend":g=ua.compositionEnd;break b;case "compositionupdate":g=
ua.compositionUpdate;break b}g=void 0}else mb?tg(a,c)&&(g=ua.compositionEnd):"keydown"===a&&229===c.keyCode&&(g=ua.compositionStart);g?(xg&&"ko"!==c.locale&&(mb||g!==ua.compositionStart?g===ua.compositionEnd&&mb&&(f=rg()):(Ba=d,ce="value"in Ba?Ba.value:Ba.textContent,mb=!0)),e=Tj.getPooled(g,b,c,d),f?e.data=f:(f=ug(c),null!==f&&(e.data=f)),lb(e),f=e):f=null;(a=Vj?Oi(a,c):Pi(a,c))?(b=Uj.getPooled(ua.beforeInput,b,c,d),b.data=a,lb(b)):b=null;return null===f?b:null===b?f:[f,b]}},Qi={color:!0,date:!0,
datetime:!0,"datetime-local":!0,email:!0,month:!0,number:!0,password:!0,range:!0,search:!0,tel:!0,text:!0,time:!0,url:!0,week:!0},Ag={change:{phasedRegistrationNames:{bubbled:"onChange",captured:"onChangeCapture"},dependencies:"blur change click focus input keydown keyup selectionchange".split(" ")}},Mb=null,Nb=null,kf=!1;wa&&(kf=Tf("input")&&(!document.documentMode||9<document.documentMode));var Xj={eventTypes:Ag,_isInputEventSupported:kf,extractEvents:function(a,b,c,d,e){e=b?Pa(b):window;var f=
e.nodeName&&e.nodeName.toLowerCase();if("select"===f||"input"===f&&"file"===e.type)var g=Si;else if(yg(e))if(kf)g=Wi;else{g=Ui;var h=Ti}else(f=e.nodeName)&&"input"===f.toLowerCase()&&("checkbox"===e.type||"radio"===e.type)&&(g=Vi);if(g&&(g=g(a,b)))return zg(g,c,d);h&&h(a,e,b);"blur"===a&&(a=e._wrapperState)&&a.controlled&&"number"===e.type&&Ed(e,"number",e.value)}},dc=R.extend({view:null,detail:null}),Yi={Alt:"altKey",Control:"ctrlKey",Meta:"metaKey",Shift:"shiftKey"},di=0,ei=0,fi=!1,gi=!1,ec=dc.extend({screenX:null,
screenY:null,clientX:null,clientY:null,pageX:null,pageY:null,ctrlKey:null,shiftKey:null,altKey:null,metaKey:null,getModifierState:fe,button:null,buttons:null,relatedTarget:function(a){return a.relatedTarget||(a.fromElement===a.srcElement?a.toElement:a.fromElement)},movementX:function(a){if("movementX"in a)return a.movementX;var b=di;di=a.screenX;return fi?"mousemove"===a.type?a.screenX-b:0:(fi=!0,0)},movementY:function(a){if("movementY"in a)return a.movementY;var b=ei;ei=a.screenY;return gi?"mousemove"===
a.type?a.screenY-b:0:(gi=!0,0)}}),hi=ec.extend({pointerId:null,width:null,height:null,pressure:null,tangentialPressure:null,tiltX:null,tiltY:null,twist:null,pointerType:null,isPrimary:null}),fc={mouseEnter:{registrationName:"onMouseEnter",dependencies:["mouseout","mouseover"]},mouseLeave:{registrationName:"onMouseLeave",dependencies:["mouseout","mouseover"]},pointerEnter:{registrationName:"onPointerEnter",dependencies:["pointerout","pointerover"]},pointerLeave:{registrationName:"onPointerLeave",dependencies:["pointerout",
"pointerover"]}},Yj={eventTypes:fc,extractEvents:function(a,b,c,d,e){var f="mouseover"===a||"pointerover"===a,g="mouseout"===a||"pointerout"===a;if(f&&0===(e&32)&&(c.relatedTarget||c.fromElement)||!g&&!f)return null;f=d.window===d?d:(f=d.ownerDocument)?f.defaultView||f.parentWindow:window;if(g){if(g=b,b=(b=c.relatedTarget||c.toElement)?Bb(b):null,null!==b){var h=Na(b);if(b!==h||5!==b.tag&&6!==b.tag)b=null}}else g=null;if(g===b)return null;if("mouseout"===a||"mouseover"===a){var m=ec;var n=fc.mouseLeave;
var l=fc.mouseEnter;var k="mouse"}else if("pointerout"===a||"pointerover"===a)m=hi,n=fc.pointerLeave,l=fc.pointerEnter,k="pointer";a=null==g?f:Pa(g);f=null==b?f:Pa(b);n=m.getPooled(n,g,c,d);n.type=k+"leave";n.target=a;n.relatedTarget=f;c=m.getPooled(l,b,c,d);c.type=k+"enter";c.target=f;c.relatedTarget=a;d=g;k=b;if(d&&k)a:{m=d;l=k;g=0;for(a=m;a;a=pa(a))g++;a=0;for(b=l;b;b=pa(b))a++;for(;0<g-a;)m=pa(m),g--;for(;0<a-g;)l=pa(l),a--;for(;g--;){if(m===l||m===l.alternate)break a;m=pa(m);l=pa(l)}m=null}else m=
null;l=m;for(m=[];d&&d!==l;){g=d.alternate;if(null!==g&&g===l)break;m.push(d);d=pa(d)}for(d=[];k&&k!==l;){g=k.alternate;if(null!==g&&g===l)break;d.push(k);k=pa(k)}for(k=0;k<m.length;k++)be(m[k],"bubbled",n);for(k=d.length;0<k--;)be(d[k],"captured",c);return 0===(e&64)?[n]:[n,c]}},Qa="function"===typeof Object.is?Object.is:Zi,$i=Object.prototype.hasOwnProperty,Zj=wa&&"documentMode"in document&&11>=document.documentMode,Eg={select:{phasedRegistrationNames:{bubbled:"onSelect",captured:"onSelectCapture"},
dependencies:"blur contextmenu dragend focus keydown keyup mousedown mouseup selectionchange".split(" ")}},nb=null,he=null,Pb=null,ge=!1,ak={eventTypes:Eg,extractEvents:function(a,b,c,d,e,f){e=f||(d.window===d?d.document:9===d.nodeType?d:d.ownerDocument);if(!(f=!e)){a:{e=Jd(e);f=rd.onSelect;for(var g=0;g<f.length;g++)if(!e.has(f[g])){e=!1;break a}e=!0}f=!e}if(f)return null;e=b?Pa(b):window;switch(a){case "focus":if(yg(e)||"true"===e.contentEditable)nb=e,he=b,Pb=null;break;case "blur":Pb=he=nb=null;
break;case "mousedown":ge=!0;break;case "contextmenu":case "mouseup":case "dragend":return ge=!1,Dg(c,d);case "selectionchange":if(Zj)break;case "keydown":case "keyup":return Dg(c,d)}return null}},bk=R.extend({animationName:null,elapsedTime:null,pseudoElement:null}),ck=R.extend({clipboardData:function(a){return"clipboardData"in a?a.clipboardData:window.clipboardData}}),dk=dc.extend({relatedTarget:null}),ek={Esc:"Escape",Spacebar:" ",Left:"ArrowLeft",Up:"ArrowUp",Right:"ArrowRight",Down:"ArrowDown",
Del:"Delete",Win:"OS",Menu:"ContextMenu",Apps:"ContextMenu",Scroll:"ScrollLock",MozPrintableKey:"Unidentified"},fk={8:"Backspace",9:"Tab",12:"Clear",13:"Enter",16:"Shift",17:"Control",18:"Alt",19:"Pause",20:"CapsLock",27:"Escape",32:" ",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"ArrowLeft",38:"ArrowUp",39:"ArrowRight",40:"ArrowDown",45:"Insert",46:"Delete",112:"F1",113:"F2",114:"F3",115:"F4",116:"F5",117:"F6",118:"F7",119:"F8",120:"F9",121:"F10",122:"F11",123:"F12",144:"NumLock",145:"ScrollLock",
224:"Meta"},gk=dc.extend({key:function(a){if(a.key){var b=ek[a.key]||a.key;if("Unidentified"!==b)return b}return"keypress"===a.type?(a=Ac(a),13===a?"Enter":String.fromCharCode(a)):"keydown"===a.type||"keyup"===a.type?fk[a.keyCode]||"Unidentified":""},location:null,ctrlKey:null,shiftKey:null,altKey:null,metaKey:null,repeat:null,locale:null,getModifierState:fe,charCode:function(a){return"keypress"===a.type?Ac(a):0},keyCode:function(a){return"keydown"===a.type||"keyup"===a.type?a.keyCode:0},which:function(a){return"keypress"===
a.type?Ac(a):"keydown"===a.type||"keyup"===a.type?a.keyCode:0}}),hk=ec.extend({dataTransfer:null}),ik=dc.extend({touches:null,targetTouches:null,changedTouches:null,altKey:null,metaKey:null,ctrlKey:null,shiftKey:null,getModifierState:fe}),jk=R.extend({propertyName:null,elapsedTime:null,pseudoElement:null}),kk=ec.extend({deltaX:function(a){return"deltaX"in a?a.deltaX:"wheelDeltaX"in a?-a.wheelDeltaX:0},deltaY:function(a){return"deltaY"in a?a.deltaY:"wheelDeltaY"in a?-a.wheelDeltaY:"wheelDelta"in a?
-a.wheelDelta:0},deltaZ:null,deltaMode:null}),lk={eventTypes:dg,extractEvents:function(a,b,c,d,e){e=cg.get(a);if(!e)return null;switch(a){case "keypress":if(0===Ac(c))return null;case "keydown":case "keyup":a=gk;break;case "blur":case "focus":a=dk;break;case "click":if(2===c.button)return null;case "auxclick":case "dblclick":case "mousedown":case "mousemove":case "mouseup":case "mouseout":case "mouseover":case "contextmenu":a=ec;break;case "drag":case "dragend":case "dragenter":case "dragexit":case "dragleave":case "dragover":case "dragstart":case "drop":a=
hk;break;case "touchcancel":case "touchend":case "touchmove":case "touchstart":a=ik;break;case $h:case ai:case bi:a=bk;break;case ci:a=jk;break;case "scroll":a=dc;break;case "wheel":a=kk;break;case "copy":case "cut":case "paste":a=ck;break;case "gotpointercapture":case "lostpointercapture":case "pointercancel":case "pointerdown":case "pointermove":case "pointerout":case "pointerover":case "pointerup":a=hi;break;default:a=R}b=a.getPooled(e,b,c,d);lb(b);return b}};(function(a){if(ic)throw Error(k(101));
ic=Array.prototype.slice.call(a);nf()})("ResponderEventPlugin SimpleEventPlugin EnterLeaveEventPlugin ChangeEventPlugin SelectEventPlugin BeforeInputEventPlugin".split(" "));(function(a,b,c){td=a;rf=b;mf=c})(ae,Hb,Pa);pf({SimpleEventPlugin:lk,EnterLeaveEventPlugin:Yj,ChangeEventPlugin:Xj,SelectEventPlugin:ak,BeforeInputEventPlugin:Wj});var ie=[],ob=-1,Ca={},B={current:Ca},G={current:!1},Ra=Ca,bj=Pd,je=$f,Rg=Lj,aj=Nj,Dc=Oj,Ig=Zh,Jg=ag,Kg=Pj,Lg=Qj,Qg={},yj=Mj,Cj=void 0!==Yh?Yh:function(){},qa=null,
Ec=null,ke=!1,ii=ff(),Y=1E4>ii?ff:function(){return ff()-ii},Ic={current:null},Hc=null,qb=null,Gc=null,Tg=0,Jc=2,Ga=!1,Vb=da.ReactCurrentBatchConfig,$g=(new ea.Component).refs,Mc={isMounted:function(a){return(a=a._reactInternalFiber)?Na(a)===a:!1},enqueueSetState:function(a,b,c){a=a._reactInternalFiber;var d=ka(),e=Vb.suspense;d=Va(d,a,e);e=Ea(d,e);e.payload=b;void 0!==c&&null!==c&&(e.callback=c);Fa(a,e);Ja(a,d)},enqueueReplaceState:function(a,b,c){a=a._reactInternalFiber;var d=ka(),e=Vb.suspense;
d=Va(d,a,e);e=Ea(d,e);e.tag=1;e.payload=b;void 0!==c&&null!==c&&(e.callback=c);Fa(a,e);Ja(a,d)},enqueueForceUpdate:function(a,b){a=a._reactInternalFiber;var c=ka(),d=Vb.suspense;c=Va(c,a,d);d=Ea(c,d);d.tag=Jc;void 0!==b&&null!==b&&(d.callback=b);Fa(a,d);Ja(a,c)}},Qc=Array.isArray,wb=ah(!0),Fe=ah(!1),Sb={},ja={current:Sb},Ub={current:Sb},Tb={current:Sb},D={current:0},Sc=da.ReactCurrentDispatcher,X=da.ReactCurrentBatchConfig,Ia=0,z=null,K=null,J=null,Uc=!1,Tc={readContext:W,useCallback:S,useContext:S,
useEffect:S,useImperativeHandle:S,useLayoutEffect:S,useMemo:S,useReducer:S,useRef:S,useState:S,useDebugValue:S,useResponder:S,useDeferredValue:S,useTransition:S},dj={readContext:W,useCallback:ih,useContext:W,useEffect:eh,useImperativeHandle:function(a,b,c){c=null!==c&&void 0!==c?c.concat([a]):null;return ze(4,2,gh.bind(null,b,a),c)},useLayoutEffect:function(a,b){return ze(4,2,a,b)},useMemo:function(a,b){var c=ub();b=void 0===b?null:b;a=a();c.memoizedState=[a,b];return a},useReducer:function(a,b,c){var d=
ub();b=void 0!==c?c(b):b;d.memoizedState=d.baseState=b;a=d.queue={pending:null,dispatch:null,lastRenderedReducer:a,lastRenderedState:b};a=a.dispatch=ch.bind(null,z,a);return[d.memoizedState,a]},useRef:function(a){var b=ub();a={current:a};return b.memoizedState=a},useState:xe,useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=xe(a),d=c[0],e=c[1];eh(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=
xe(!1),c=b[0];b=b[1];return[ih(Ce.bind(null,b,a),[b,a]),c]}},ej={readContext:W,useCallback:Yc,useContext:W,useEffect:Xc,useImperativeHandle:hh,useLayoutEffect:fh,useMemo:jh,useReducer:Vc,useRef:dh,useState:function(a){return Vc(Ua)},useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=Vc(Ua),d=c[0],e=c[1];Xc(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=Vc(Ua),c=b[0];b=b[1];return[Yc(Ce.bind(null,
b,a),[b,a]),c]}},fj={readContext:W,useCallback:Yc,useContext:W,useEffect:Xc,useImperativeHandle:hh,useLayoutEffect:fh,useMemo:jh,useReducer:Wc,useRef:dh,useState:function(a){return Wc(Ua)},useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=Wc(Ua),d=c[0],e=c[1];Xc(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=Wc(Ua),c=b[0];b=b[1];return[Yc(Ce.bind(null,b,a),[b,a]),c]}},ra=null,Ka=null,Wa=
!1,gj=da.ReactCurrentOwner,ia=!1,Je={dehydrated:null,retryTime:0};var jj=function(a,b,c,d){for(c=b.child;null!==c;){if(5===c.tag||6===c.tag)a.appendChild(c.stateNode);else if(4!==c.tag&&null!==c.child){c.child.return=c;c=c.child;continue}if(c===b)break;for(;null===c.sibling;){if(null===c.return||c.return===b)return;c=c.return}c.sibling.return=c.return;c=c.sibling}};var wh=function(a){};var ij=function(a,b,c,d,e){var f=a.memoizedProps;if(f!==d){var g=b.stateNode;Ta(ja.current);a=null;switch(c){case "input":f=
Cd(g,f);d=Cd(g,d);a=[];break;case "option":f=Fd(g,f);d=Fd(g,d);a=[];break;case "select":f=M({},f,{value:void 0});d=M({},d,{value:void 0});a=[];break;case "textarea":f=Gd(g,f);d=Gd(g,d);a=[];break;default:"function"!==typeof f.onClick&&"function"===typeof d.onClick&&(g.onclick=uc)}Ud(c,d);var h,m;c=null;for(h in f)if(!d.hasOwnProperty(h)&&f.hasOwnProperty(h)&&null!=f[h])if("style"===h)for(m in g=f[h],g)g.hasOwnProperty(m)&&(c||(c={}),c[m]="");else"dangerouslySetInnerHTML"!==h&&"children"!==h&&"suppressContentEditableWarning"!==
h&&"suppressHydrationWarning"!==h&&"autoFocus"!==h&&(db.hasOwnProperty(h)?a||(a=[]):(a=a||[]).push(h,null));for(h in d){var k=d[h];g=null!=f?f[h]:void 0;if(d.hasOwnProperty(h)&&k!==g&&(null!=k||null!=g))if("style"===h)if(g){for(m in g)!g.hasOwnProperty(m)||k&&k.hasOwnProperty(m)||(c||(c={}),c[m]="");for(m in k)k.hasOwnProperty(m)&&g[m]!==k[m]&&(c||(c={}),c[m]=k[m])}else c||(a||(a=[]),a.push(h,c)),c=k;else"dangerouslySetInnerHTML"===h?(k=k?k.__html:void 0,g=g?g.__html:void 0,null!=k&&g!==k&&(a=a||
[]).push(h,k)):"children"===h?g===k||"string"!==typeof k&&"number"!==typeof k||(a=a||[]).push(h,""+k):"suppressContentEditableWarning"!==h&&"suppressHydrationWarning"!==h&&(db.hasOwnProperty(h)?(null!=k&&oa(e,h),a||g===k||(a=[])):(a=a||[]).push(h,k))}c&&(a=a||[]).push("style",c);e=a;if(b.updateQueue=e)b.effectTag|=4}};var kj=function(a,b,c,d){c!==d&&(b.effectTag|=4)};var pj="function"===typeof WeakSet?WeakSet:Set,wj="function"===typeof WeakMap?WeakMap:Map,sj=Math.ceil,gd=da.ReactCurrentDispatcher,
Uh=da.ReactCurrentOwner,H=0,Ye=8,ca=16,ma=32,Xa=0,hd=1,Oh=2,ad=3,bd=4,Xe=5,p=H,U=null,t=null,P=0,F=Xa,id=null,ta=1073741823,Yb=1073741823,kd=null,Xb=0,jd=!1,Re=0,Ph=500,l=null,cd=!1,Se=null,La=null,ld=!1,Zb=null,$b=90,bb=null,ac=0,af=null,dd=0,Ja=function(a,b){if(50<ac)throw ac=0,af=null,Error(k(185));a=ed(a,b);if(null!==a){var c=Cc();1073741823===b?(p&Ye)!==H&&(p&(ca|ma))===H?Te(a):(V(a),p===H&&ha()):V(a);(p&4)===H||98!==c&&99!==c||(null===bb?bb=new Map([[a,b]]):(c=bb.get(a),(void 0===c||c>b)&&bb.set(a,
b)))}};var zj=function(a,b,c){var d=b.expirationTime;if(null!==a){var e=b.pendingProps;if(a.memoizedProps!==e||G.current)ia=!0;else{if(d<c){ia=!1;switch(b.tag){case 3:sh(b);Ee();break;case 5:bh(b);if(b.mode&4&&1!==c&&e.hidden)return b.expirationTime=b.childExpirationTime=1,null;break;case 1:N(b.type)&&Bc(b);break;case 4:se(b,b.stateNode.containerInfo);break;case 10:d=b.memoizedProps.value;e=b.type._context;y(Ic,e._currentValue);e._currentValue=d;break;case 13:if(null!==b.memoizedState){d=b.child.childExpirationTime;
if(0!==d&&d>=c)return th(a,b,c);y(D,D.current&1);b=sa(a,b,c);return null!==b?b.sibling:null}y(D,D.current&1);break;case 19:d=b.childExpirationTime>=c;if(0!==(a.effectTag&64)){if(d)return vh(a,b,c);b.effectTag|=64}e=b.memoizedState;null!==e&&(e.rendering=null,e.tail=null);y(D,D.current);if(!d)return null}return sa(a,b,c)}ia=!1}}else ia=!1;b.expirationTime=0;switch(b.tag){case 2:d=b.type;null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2);a=b.pendingProps;e=pb(b,B.current);rb(b,c);e=we(null,
b,d,a,e,c);b.effectTag|=1;if("object"===typeof e&&null!==e&&"function"===typeof e.render&&void 0===e.$$typeof){b.tag=1;b.memoizedState=null;b.updateQueue=null;if(N(d)){var f=!0;Bc(b)}else f=!1;b.memoizedState=null!==e.state&&void 0!==e.state?e.state:null;ne(b);var g=d.getDerivedStateFromProps;"function"===typeof g&&Lc(b,d,g,a);e.updater=Mc;b.stateNode=e;e._reactInternalFiber=b;pe(b,d,a,c);b=Ie(null,b,d,!0,f,c)}else b.tag=0,T(null,b,e,c),b=b.child;return b;case 16:a:{e=b.elementType;null!==a&&(a.alternate=
null,b.alternate=null,b.effectTag|=2);a=b.pendingProps;ri(e);if(1!==e._status)throw e._result;e=e._result;b.type=e;f=b.tag=Gj(e);a=aa(e,a);switch(f){case 0:b=He(null,b,e,a,c);break a;case 1:b=rh(null,b,e,a,c);break a;case 11:b=nh(null,b,e,a,c);break a;case 14:b=oh(null,b,e,aa(e.type,a),d,c);break a}throw Error(k(306,e,""));}return b;case 0:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),He(a,b,d,e,c);case 1:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),rh(a,b,d,e,c);
case 3:sh(b);d=b.updateQueue;if(null===a||null===d)throw Error(k(282));d=b.pendingProps;e=b.memoizedState;e=null!==e?e.element:null;oe(a,b);Qb(b,d,null,c);d=b.memoizedState.element;if(d===e)Ee(),b=sa(a,b,c);else{if(e=b.stateNode.hydrate)Ka=kb(b.stateNode.containerInfo.firstChild),ra=b,e=Wa=!0;if(e)for(c=Fe(b,null,d,c),b.child=c;c;)c.effectTag=c.effectTag&-3|1024,c=c.sibling;else T(a,b,d,c),Ee();b=b.child}return b;case 5:return bh(b),null===a&&De(b),d=b.type,e=b.pendingProps,f=null!==a?a.memoizedProps:
null,g=e.children,Yd(d,e)?g=null:null!==f&&Yd(d,f)&&(b.effectTag|=16),qh(a,b),b.mode&4&&1!==c&&e.hidden?(b.expirationTime=b.childExpirationTime=1,b=null):(T(a,b,g,c),b=b.child),b;case 6:return null===a&&De(b),null;case 13:return th(a,b,c);case 4:return se(b,b.stateNode.containerInfo),d=b.pendingProps,null===a?b.child=wb(b,null,d,c):T(a,b,d,c),b.child;case 11:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),nh(a,b,d,e,c);case 7:return T(a,b,b.pendingProps,c),b.child;case 8:return T(a,
b,b.pendingProps.children,c),b.child;case 12:return T(a,b,b.pendingProps.children,c),b.child;case 10:a:{d=b.type._context;e=b.pendingProps;g=b.memoizedProps;f=e.value;var h=b.type._context;y(Ic,h._currentValue);h._currentValue=f;if(null!==g)if(h=g.value,f=Qa(h,f)?0:("function"===typeof d._calculateChangedBits?d._calculateChangedBits(h,f):1073741823)|0,0===f){if(g.children===e.children&&!G.current){b=sa(a,b,c);break a}}else for(h=b.child,null!==h&&(h.return=b);null!==h;){var m=h.dependencies;if(null!==
m){g=h.child;for(var l=m.firstContext;null!==l;){if(l.context===d&&0!==(l.observedBits&f)){1===h.tag&&(l=Ea(c,null),l.tag=Jc,Fa(h,l));h.expirationTime<c&&(h.expirationTime=c);l=h.alternate;null!==l&&l.expirationTime<c&&(l.expirationTime=c);Sg(h.return,c);m.expirationTime<c&&(m.expirationTime=c);break}l=l.next}}else g=10===h.tag?h.type===b.type?null:h.child:h.child;if(null!==g)g.return=h;else for(g=h;null!==g;){if(g===b){g=null;break}h=g.sibling;if(null!==h){h.return=g.return;g=h;break}g=g.return}h=
g}T(a,b,e.children,c);b=b.child}return b;case 9:return e=b.type,f=b.pendingProps,d=f.children,rb(b,c),e=W(e,f.unstable_observedBits),d=d(e),b.effectTag|=1,T(a,b,d,c),b.child;case 14:return e=b.type,f=aa(e,b.pendingProps),f=aa(e.type,f),oh(a,b,e,f,d,c);case 15:return ph(a,b,b.type,b.pendingProps,d,c);case 17:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2),b.tag=1,N(d)?(a=!0,Bc(b)):a=!1,rb(b,c),Yg(b,d,e),pe(b,d,e,c),Ie(null,
b,d,!0,a,c);case 19:return vh(a,b,c)}throw Error(k(156,b.tag));};var bf=null,Ne=null,la=function(a,b,c,d){return new Fj(a,b,c,d)};ef.prototype.render=function(a){md(a,this._internalRoot,null,null)};ef.prototype.unmount=function(){var a=this._internalRoot,b=a.containerInfo;md(null,a,null,function(){b[Lb]=null})};var Di=function(a){if(13===a.tag){var b=Fc(ka(),150,100);Ja(a,b);df(a,b)}};var Yf=function(a){13===a.tag&&(Ja(a,3),df(a,3))};var Bi=function(a){if(13===a.tag){var b=ka();b=Va(b,a,null);Ja(a,
b);df(a,b)}};sd=function(a,b,c){switch(b){case "input":Dd(a,c);b=c.name;if("radio"===c.type&&null!=b){for(c=a;c.parentNode;)c=c.parentNode;c=c.querySelectorAll("input[name="+JSON.stringify(""+b)+'][type="radio"]');for(b=0;b<c.length;b++){var d=c[b];if(d!==a&&d.form===a.form){var e=ae(d);if(!e)throw Error(k(90));Gf(d);Dd(d,e)}}}break;case "textarea":Lf(a,c);break;case "select":b=c.value,null!=b&&hb(a,!!c.multiple,b,!1)}};(function(a,b,c,d){ee=a;eg=b;vd=c;vf=d})(Qh,function(a,b,c,d,e){var f=p;p|=4;
try{return Da(98,a.bind(null,b,c,d,e))}finally{p=f,p===H&&ha()}},function(){(p&(1|ca|ma))===H&&(uj(),xb())},function(a,b){var c=p;p|=2;try{return a(b)}finally{p=c,p===H&&ha()}});var mk={Events:[Hb,Pa,ae,pf,qd,lb,function(a){Kd(a,Ki)},sf,tf,sc,pc,xb,{current:!1}]};(function(a){var b=a.findFiberByHostInstance;return Ej(M({},a,{overrideHookState:null,overrideProps:null,setSuspenseHandler:null,scheduleUpdate:null,currentDispatcherRef:da.ReactCurrentDispatcher,findHostInstanceByFiber:function(a){a=Sf(a);
return null===a?null:a.stateNode},findFiberByHostInstance:function(a){return b?b(a):null},findHostInstancesForRefresh:null,scheduleRefresh:null,scheduleRoot:null,setRefreshHandler:null,getCurrentFiber:null}))})({findFiberByHostInstance:Bb,bundleType:0,version:"16.13.1",rendererPackageName:"react-dom"});I.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=mk;I.createPortal=Xh;I.findDOMNode=function(a){if(null==a)return null;if(1===a.nodeType)return a;var b=a._reactInternalFiber;if(void 0===
b){if("function"===typeof a.render)throw Error(k(188));throw Error(k(268,Object.keys(a)));}a=Sf(b);a=null===a?null:a.stateNode;return a};I.flushSync=function(a,b){if((p&(ca|ma))!==H)throw Error(k(187));var c=p;p|=1;try{return Da(99,a.bind(null,b))}finally{p=c,ha()}};I.hydrate=function(a,b,c){if(!bc(b))throw Error(k(200));return nd(null,a,b,!0,c)};I.render=function(a,b,c){if(!bc(b))throw Error(k(200));return nd(null,a,b,!1,c)};I.unmountComponentAtNode=function(a){if(!bc(a))throw Error(k(40));return a._reactRootContainer?
(Rh(function(){nd(null,null,a,!1,function(){a._reactRootContainer=null;a[Lb]=null})}),!0):!1};I.unstable_batchedUpdates=Qh;I.unstable_createPortal=function(a,b){return Xh(a,b,2<arguments.length&&void 0!==arguments[2]?arguments[2]:null)};I.unstable_renderSubtreeIntoContainer=function(a,b,c,d){if(!bc(c))throw Error(k(200));if(null==a||void 0===a._reactInternalFiber)throw Error(k(38));return nd(a,b,c,!1,d)};I.version="16.13.1"});
</script>
    <script>const e = React.createElement;

function pathToString(path) {
  if (path[0] === '/') {
    return '/' + path.slice(1).join('/');
  } else {
    return path.join('/');
  }
}

function findCommonPath(files) {
  if (!files || !files.length) {
    return [];
  }

  function isPrefix(arr, prefix) {
    if (arr.length < prefix.length) {
      return false;
    }
    for (let i = prefix.length - 1; i >= 0; --i) {
      if (arr[i] !== prefix[i]) {
        return false;
      }
    }
    return true;
  }

  let commonPath = files[0].path.slice(0, -1);
  while (commonPath.length) {
    if (files.every(file => isPrefix(file.path, commonPath))) {
      break;
    }
    commonPath.pop();
  }
  return commonPath;
}

function findFolders(files) {
  if (!files || !files.length) {
    return [];
  }

  let folders = files.filter(file => file.path.length > 1).map(file => file.path[0]);
  folders = [...new Set(folders)]; // unique
  folders.sort();

  folders = folders.map(folder => {
    let filesInFolder = files
      .filter(file => file.path[0] === folder)
      .map(file => ({
        ...file,
        path: file.path.slice(1),
        parent: [...file.parent, file.path[0]],
      }));

    const children = findFolders(filesInFolder); // recursion

    return {
      is_folder: true,
      path: [folder],
      parent: files[0].parent,
      children,
      covered: children.reduce((sum, file) => sum + file.covered, 0),
      coverable: children.reduce((sum, file) => sum + file.coverable, 0),
      prevRun: {
        covered: children.reduce((sum, file) => sum + file.prevRun.covered, 0),
        coverable: children.reduce((sum, file) => sum + file.prevRun.coverable, 0),
      },
    };
  });

  return [...folders, ...files.filter(file => file.path.length === 1)];
}

class App extends React.Component {
  constructor(...args) {
    super(...args);

    this.state = {
      current: [],
    };
  }

  componentDidMount() {
    this.updateStateFromLocation();
    window.addEventListener('hashchange', () => this.updateStateFromLocation(), false);
  }

  updateStateFromLocation() {
    if (window.location.hash.length > 1) {
      const current = window.location.hash.slice(1).split('/');
      this.setState({current});
    } else {
      this.setState({current: []});
    }
  }

  getCurrentPath() {
    let file = this.props.root;
    let path = [file];
    for (let p of this.state.current) {
      file = file.children.find(file => file.path[0] === p);
      if (!file) {
        return path;
      }
      path.push(file);
    }
    return path;
  }

  render() {
    const path = this.getCurrentPath();
    const file = path[path.length - 1];

    let w = null;
    if (file.is_folder) {
      w = e(FilesList, {
        folder: file,
        onSelectFile: this.selectFile.bind(this),
        onBack: path.length > 1 ? this.back.bind(this) : null,
      });
    } else {
      w = e(DisplayFile, {
        file,
        onBack: this.back.bind(this),
      });
    }

    return e('div', {className: 'app'}, w);
  }

  selectFile(file) {
    this.setState(
      ({current}) => {
        return {current: [...current, file.path[0]]};
      },
      () => this.updateHash(),
    );
  }

  back(file) {
    this.setState(
      ({current}) => {
        return {current: current.slice(0, current.length - 1)};
      },
      () => this.updateHash(),
    );
  }

  updateHash() {
    if (!this.state.current || !this.state.current.length) {
      window.location = '#';
    } else {
      window.location = '#' + this.state.current.join('/');
    }
  }
}

function FilesList({folder, onSelectFile, onBack}) {
  let files = folder.children;
  return e(
    'div',
    {className: 'display-folder'},
    e(FileHeader, {file: folder, onBack}),
    e(
      'table',
      {className: 'files-list'},
      e('thead', {className: 'files-list__head'}, e('tr', null, e('th', null, 'Path'), e('th', null, 'Coverage'))),
      e(
        'tbody',
        {className: 'files-list__body'},
        files.map(file => e(File, {file, onClick: onSelectFile})),
      ),
    ),
  );
}

function File({file, onClick}) {
  const coverage = file.coverable ? (file.covered / file.coverable) * 100 : -1;
  const coverageDelta =
    file.prevRun && (file.covered / file.coverable) * 100 - (file.prevRun.covered / file.prevRun.coverable) * 100;

  return e(
    'tr',
    {
      className:
        'files-list__file' +
        (coverage >= 0 && coverage < 50 ? ' files-list__file_low' : '') +
        (coverage >= 50 && coverage < 80 ? ' files-list__file_medium' : '') +
        (coverage >= 80 ? ' files-list__file_high' : '') +
        (file.is_folder ? ' files-list__file_folder' : ''),
      onClick: () => onClick(file),
    },
    e('td', null, e('a', null, pathToString(file.path))),
    e(
      'td',
      null,
      file.covered + ' / ' + file.coverable + (coverage >= 0 ? ' (' + coverage.toFixed(2) + '%)' : ''),
      e(
        'span',
        {title: 'Change from the previous run'},
        coverageDelta ? ` (${coverageDelta > 0 ? '+' : ''}${coverageDelta.toFixed(2)}%)` : '',
      ),
    ),
  );
}

function DisplayFile({file, onBack}) {
  return e('div', {className: 'display-file'}, e(FileHeader, {file, onBack}), e(FileContent, {file}));
}

function FileHeader({file, onBack}) {
  const coverage = (file.covered / file.coverable) * 100;
  const coverageDelta = file.prevRun && coverage - (file.prevRun.covered / file.prevRun.coverable) * 100;

  return e(
    'div',
    {className: 'file-header'},
    onBack ? e('a', {className: 'file-header__back', onClick: onBack}, 'Back') : null,
    e('div', {className: 'file-header__name'}, pathToString([...file.parent, ...file.path])),
    e(
      'div',
      {className: 'file-header__stat'},
      'Covered: ' + file.covered + ' of ' + file.coverable + (file.coverable ? ' (' + coverage.toFixed(2) + '%)' : ''),
      e(
        'span',
        {title: 'Change from the previous run'},
        coverageDelta ? ` (${coverageDelta > 0 ? '+' : ''}${coverageDelta.toFixed(2)}%)` : '',
      ),
      e('input', {id: 'theme-toggle', type: 'checkbox', hidden: true}),
      e('label', {for: 'theme-toggle', id: 'theme-toggle-label'}, '🌙'),
    ),
  );
}

function FileContent({file}) {
  return e(
    'pre',
    {className: 'file-content'},
    file.content.split(/\r?\n/).map((line, index) => {
      const trace = file.traces.find(trace => trace.line === index + 1);
      const covered = trace && trace.stats.Line;
      const uncovered = trace && !trace.stats.Line;
      return e(
        'code',
        {
          className: 'code-line' + (covered ? ' code-line_covered' : '') + (uncovered ? ' code-line_uncovered' : ''),
          title: trace ? JSON.stringify(trace.stats, null, 2) : null,
        },
        line,
      );
    }),
  );
}

(function () {
  const commonPath = findCommonPath(data.files);
  const prevFilesMap = new Map();

  previousData &&
    previousData.files.forEach(file => {
      const path = file.path.slice(commonPath.length).join('/');
      prevFilesMap.set(path, file);
    });

  const files = data.files.map(file => {
    const path = file.path.slice(commonPath.length);
    const {covered = 0, coverable = 0} = prevFilesMap.get(path.join('/')) || {};
    return {
      ...file,
      path,
      parent: commonPath,
      prevRun: {covered, coverable},
    };
  });

  const children = findFolders(files);

  const root = {
    is_folder: true,
    children,
    path: commonPath,
    parent: [],
    covered: children.reduce((sum, file) => sum + file.covered, 0),
    coverable: children.reduce((sum, file) => sum + file.coverable, 0),
    prevRun: {
      covered: children.reduce((sum, file) => sum + file.prevRun.covered, 0),
      coverable: children.reduce((sum, file) => sum + file.prevRun.coverable, 0),
    },
  };

  ReactDOM.render(e(App, {root, prevFilesMap}), document.getElementById('root'));

  const toggle = document.getElementById('theme-toggle');
  const label = document.getElementById('theme-toggle-label');
  label.textContent = '🌙';

  toggle.addEventListener('change', () => {
    if (toggle.checked) {
      document.documentElement.setAttribute('data-theme', 'dark');
      label.textContent = '☀️';
    } else {
      document.documentElement.removeAttribute('data-theme');
      label.textContent = '🌙';
    }
  });
})();
</script>
</body>
</html>